<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/2021/10/20/Docker/</url>
    <content><![CDATA[<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>以 CentOS7 为例</p>
<h2 id="1-简化安装方法"><a href="#1-简化安装方法" class="headerlink" title="1. 简化安装方法"></a>1. 简化安装方法</h2><p>Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，执行这个脚本后就会自动地将一切准备工作做好，并且把 Docker 的稳定版本安装在系统中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="2-一般安装"><a href="#2-一般安装" class="headerlink" title="2. 一般安装"></a>2. 一般安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载旧的版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum remove docker \</span></span><br><span class="line"><span class="language-bash">                  docker-client \</span></span><br><span class="line"><span class="language-bash">                  docker-client-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-common \</span></span><br><span class="line"><span class="language-bash">                  docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装基本的安装包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置镜像的仓库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager \</span></span><br><span class="line"><span class="language-bash">    --add-repo \</span></span><br><span class="line"><span class="language-bash">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <span class="comment"># 阿里云镜像</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker引擎</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="1-docker-images"><a href="#1-docker-images" class="headerlink" title="1. docker images"></a>1. docker images</h3><p>查看 Docker 中当前拥有哪些镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izrz ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">MySQL         5.7.32    f07dfa83b528   11 days ago     448MB</span><br><span class="line">tomcat        latest    feba8d001e3f   2 weeks ago     649MB</span><br><span class="line">nginx         latest    ae2feff98a0c   2 weeks ago     133MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   12 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<h3 id="2-docker-search"><a href="#2-docker-search" class="headerlink" title="2. docker search"></a>2. docker search</h3><p>搜索仓库中的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search MySQL</span><br></pre></td></tr></table></figure>

<h3 id="3-docker-pull"><a href="#3-docker-pull" class="headerlink" title="3. docker pull"></a>3. docker pull</h3><p>下载镜像，不写版本标志直接执行，则会下载镜像的最新版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull MySQL:5.7</span><br></pre></td></tr></table></figure>
<h3 id="4-docker-image-rm"><a href="#4-docker-image-rm" class="headerlink" title="4. docker image rm"></a>4. docker image rm</h3><p>删除镜像，若是不指定版本，则默认删除的也是最新版本，还可以通过指定镜像 id 进行删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm MySQL:5.5</span><br><span class="line"></span><br><span class="line">docker image rm bf756fb1ae65</span><br></pre></td></tr></table></figure>

<p>简化版本<code>docker rmi 镜像名:版本标志</code><br>删除所有的 MySQL 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images MySQL -q)</span><br></pre></td></tr></table></figure>
<p><code>docker images MySQL -q</code>查询出 MySQL 的所有镜像 id，-q表示仅查询 id，并将这些 id 作为参数传递给docker rmi -f指令，这样所有的 MySQL 镜像就都被删除了</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="1-docker-run"><a href="#1-docker-run" class="headerlink" title="1. docker run"></a>1. docker run</h3><p>通过镜像运行一个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8088:8080 --name tomcat01 tomcat:8.0-jre8</span><br></pre></td></tr></table></figure>
<p>-p进行端口映射，第一个 8088 为宿主机端口，第二个 8080 为容器内的端口，外部访问 8088 端口就会通过映射访问容器内的 8080 端口<br>–name给容器起一个名字</p>
<h3 id="2-docker-ps"><a href="#2-docker-ps" class="headerlink" title="2. docker ps"></a>2. docker ps</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>将运行和非运行的容器全部列举出来</p>
<h3 id="3-docker-rm"><a href="#3-docker-rm" class="headerlink" title="3. docker rm"></a>3. docker rm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm d5b6c177c151</span><br></pre></td></tr></table></figure>
<p>根据id删除容器</p>
<h3 id="4-启动和停止容器"><a href="#4-启动和停止容器" class="headerlink" title="4. 启动和停止容器"></a>4. 启动和停止容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start</span><br><span class="line">docker restart</span><br><span class="line">docker stop</span><br><span class="line">docker kill</span><br></pre></td></tr></table></figure>

<h3 id="5-容器内部"><a href="#5-容器内部" class="headerlink" title="5. 容器内部"></a>5. 容器内部</h3><p>进入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>
<p>退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>Docker 中的数据卷能够实现宿主机与容器之间的文件共享，它的好处在于对宿主机的文件进行修改将直接影响容器，而无需再将宿主机的文件再复制到容器中。本质上是一个目录挂载，将容器内的目录挂载到虚拟机上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name tomcat01 -v /opt/apps:/usr/local/tomcat/webapps tomcat:8.0-jre8</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2021/08/25/Git/</url>
    <content><![CDATA[<h1 id="git日常使用的小问题"><a href="#git日常使用的小问题" class="headerlink" title="git日常使用的小问题"></a>git日常使用的小问题</h1><h2 id="嵌套仓库"><a href="#嵌套仓库" class="headerlink" title="嵌套仓库"></a>嵌套仓库</h2><p>如果在一个git仓库中嵌套了一个git仓库，那么被嵌套的git仓库的改动，不能被大git仓库检测到。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>可以使用submodule，当引入子仓库时，使用如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/子仓库</span><br></pre></td></tr></table></figure>

<p>作用类似git clone，但是他会在父仓库的下面新建.gitmodules文件，并且包含以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;apps/firstApp&quot;]</span><br><span class="line">	path = apps/firstApp</span><br><span class="line">	url = https://github.com/muchang/mean-seed-app.git</span><br></pre></td></tr></table></figure>

<p>这一段表示子仓库的位置，以及子仓库的远程仓库的地址。</p>
<p>删除子仓库并且commit之后，这个文件和这个子仓库有关的部分就会消失。</p>
</li>
<li><p>本质和第一个方案类似，它会把总仓库内的所有内容拉取下来（<strong>包含子仓库</strong>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recursive https://github.com/总仓库</span><br></pre></td></tr></table></figure>

<p><strong>这两种方案可以同时维护两个仓库，字仓库也可以随时拉取更新</strong></p>
</li>
<li><p>删除子仓库</p>
<ol>
<li>卸载子模块	<code>git submodule deinit &lt;submodule_path&gt;</code></li>
<li>删除子模块目录   <code>git rm &lt;submodule_path&gt;</code></li>
<li><code>git add</code></li>
<li><code>git commit -m &quot;Remove submodule &lt;submodule_path&gt;&quot;</code></li>
</ol>
</li>
</ul>
<h2 id="复杂命令"><a href="#复杂命令" class="headerlink" title="复杂命令"></a>复杂命令</h2><ul>
<li><p><strong>git reset commitId</strong> ：<code>head</code>指针移动到指定的commit，并且之前的HEAD -&gt;commitId之间的所有修改的内容会<strong>被置于工作区</strong>，需要重新add、commit。</p>
<blockquote>
<p>慎重使用 <code>--hard </code>指令，在回滚HEAD指针的时候，很强硬的将所有HEAD -&gt;commitId之间的改动内容“全部删除”！</p>
</blockquote>
</li>
<li><p><strong>git rebase</strong>：<code>merge</code>命令会形成一个钻石结构，如果多个feature分支同时开发，最终合并到主分支会带来多个钻石分叉，影响master分支的历史美观度，master对长分叉历史不敏感。为了解决这种问题，在merge分支后通常对master进行变基操作，去除掉那些分叉的历史，保证master的连续性。</p>
</li>
<li><p><strong>git checkout</strong>：丢弃工作区的修改，返回到上次提交状态</p>
</li>
<li><p><strong>git reflog</strong>：当reset HEAD指针之后，git log里只会显示当前分支HEAD之前的所有commitId，而git reflog可以显示所有的commit Id。</p>
</li>
<li><p><strong>git revert</strong>：revert命令实现了HEAD指针的继续前进，新生成的commit和要撤销的目标提交具有相反的操作，实现了“后悔”的操作。</p>
</li>
</ul>
<h1 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h1><p><strong>Git是目前世界上最先进的分布式版本控制系统</strong>,与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<p>集中式vs分布式:<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">Git教程- 廖雪峰的官方网站</a></p>
<blockquote>
<ul>
<li>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</li>
<li>段落引用分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li>
</ul>
</blockquote>
<p>Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待 数据更像是一个 快照流。++这是 Git 与几乎所有其它版本控制系统的重要区别。</p>
<img src="/2021/08/25/Git/%E5%AD%98%E5%82%A8%E9%A1%B9%E7%9B%AE%E9%9A%8F%E6%97%B6%E9%97%B4%E6%94%B9%E5%8F%98%E7%9A%84%E5%BF%AB%E7%85%A7-2494d6dda12142d58eef358e12fa39a8.png" class="" title="存储项目随时间改变的快照.png">

<p>Git 有三种状态，你的文件可能处于其中之一: 已提交(committed)、已修改(modified) 和 已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 </li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让Git项目拥有三个阶段:工作区、暂存区以及 Git 目录。</p>
<h1 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h1><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置:</p>
<ol>
<li>&#x2F;etc&#x2F;gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 –system 选项，那么它就会读写该文件中的配置变量。</li>
<li>~&#x2F;.gitconfig 或 ~&#x2F;.config&#x2F;git&#x2F;config 文件:只针对当前用户。 你可以传递 –global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。</li>
<li>当前使用仓库的 Git 目录中的 config 文件(即 .git&#x2F;config):针对该仓库。 你可以传递 –local 选 项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 (当然，你需要进入某个 Git 仓库中才能让该选项生效。)</li>
</ol>
<p>每一个级别会覆盖上一级别的配置，所以 .git&#x2F;config 的配置变量会覆盖 &#x2F;etc&#x2F;gitconfig 中的配置变量。</p>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使 用这些信息，它们会写入到你的每一次提交中，不可更改:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<h2 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h1 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/testgit/.git/</span><br><span class="line"></span><br><span class="line">//克隆一个仓库并命名为mylibgit</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>
<h2 id="把新增文件添加仓库"><a href="#把新增文件添加仓库" class="headerlink" title="把新增文件添加仓库"></a>把新增文件添加仓库</h2><figure class="highlight plaintext"><figcaption><span>add```告诉Git，把文件添加到仓库,```git add```后跟文件名或者```.```,```.```表示所有文件</span></figcaption><table><tr><td class="code"><pre><span class="line">```bash</span><br><span class="line">git add readme.txt</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h2 id="文件提交到仓库"><a href="#文件提交到仓库" class="headerlink" title="文件提交到仓库"></a>文件提交到仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line">[master (root-commit) 60bffb4] <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>commit```命令，```-m```后面输入的是本次提交的说明，方便在历史记录里方便地找到改动记录。</span></figcaption><table><tr><td class="code"><pre><span class="line">```git commit```命令执行成功后会告诉你，1 file changed：1个文件被改动（新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</span><br><span class="line"></span><br><span class="line">提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时 纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</span><br><span class="line">```bash</span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<p>意思就是，把readme.txt文件在工作区的修改全部撤销，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .gitignore</span><br><span class="line"><span class="comment"># 忽略所有的 .a 文件 </span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 </span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO </span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略任何目录下名为 build 的文件夹 </span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt </span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 </span></span><br><span class="line">doc/**/*.pdf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><p>修改readme.txt文件,增加一些内容,随后查看状态:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>status```查看仓库当前状态,上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index f0ec47f..ee2c1ea 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看修改后的不同之处.之后再次添加和提交即可</p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plaintext"><figcaption><span>log`命令查看历史提交记录.</span></figcaption><table><tr><td class="code"><pre><span class="line">```bash</span><br><span class="line">$ git log</span><br><span class="line">commit 49b50fc00a1af29c9deb45e4eaf01cf168b1dc69 (HEAD -&gt; master)</span><br><span class="line">Author: a</span><br><span class="line">Date:   Wed Aug 25 10:36:17 2021 +0800</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">commit 76aaebb8ba0216719c4e4d9c2bd5c88d55692d8a</span><br><span class="line">Author: a</span><br><span class="line">Date:   Wed Aug 25 10:34:54 2021 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br><span class="line"></span><br><span class="line">commit 60bffb4ec6f9804bdbe7d6d8dd235facea0fdc43</span><br><span class="line">Author: a</span><br><span class="line">Date:   Wed Aug 25 10:11:19 2021 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br></pre></td></tr></table></figure>
<p>不传入任何参数的默认情况下，<code>git log</code>会按时间先后顺序列出所有的提交，最近的更新排在最上面。git log 有许多选项可以帮助你搜寻你所要找的提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//-p 或 --patch ，它会显示每次提交所引入的差异(按 补丁 的格式输出)</span><br><span class="line">//-2 选项来只显示最近的两次提交</span><br><span class="line">$ git <span class="built_in">log</span> -p -2</span><br><span class="line"></span><br><span class="line">//oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 </span><br><span class="line">//另外还 有 short，full 和 fuller 选项</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">49b50fc00a1af29c9deb45e4eaf01cf168b1dc69 (HEAD -&gt; master) 3</span><br><span class="line">76aaebb8ba0216719c4e4d9c2bd5c88d55692d8a add</span><br><span class="line">60bffb4ec6f9804bdbe7d6d8dd235facea0fdc43 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>当<code>oneline</code>与另一个 log 选项<code>--graph</code>结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串 来形象地展示你的分支、合并历史:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on <span class="built_in">trap</span></span><br><span class="line">*  5e3ee11 Merge branch <span class="string">&#x27;master&#x27;</span> of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method <span class="keyword">for</span> getting the current branch.</span><br><span class="line">* | 30e367c <span class="built_in">timeout</span> code and tests</span><br><span class="line">* | 5a09431 add <span class="built_in">timeout</span> protection to grit</span><br><span class="line">* | e1193f8 support <span class="keyword">for</span> heads with slashes <span class="keyword">in</span> them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time <span class="keyword">for</span> xmlschema</span><br><span class="line">*  11d191e Merge branch <span class="string">&#x27;defunkt&#x27;</span> into <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<img src="/2021/08/25/Git/git%20log%E7%9A%84%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9-2cab391a68a6413597bb43d422b5a01c.png" class="" title="git log的常用选项.png">

<p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交49b50f…，上一个版本就是HEAD^ ，往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。<br>如果要把版本回退到上个版本即add这个版本,使用命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD~</span><br><span class="line">HEAD is now at 76aaebb add</span><br></pre></td></tr></table></figure>

<p>回退版本后悔了,需要恢复到新版本<code>git reset --hard 版本号</code>,这时<code>git log</code>无法查看版本号,可以使用命令查看自己的所有操作记录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">76aaebb (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~</span><br><span class="line">49b50fc HEAD@&#123;1&#125;: reset: moving to 49b50</span><br><span class="line">76aaebb (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to HEAD~</span><br><span class="line">49b50fc HEAD@&#123;3&#125;: commit: 3</span><br><span class="line">76aaebb (HEAD -&gt; master) HEAD@&#123;4&#125;: commit: add</span><br><span class="line">60bffb4 HEAD@&#123;5&#125;: commit (initial): <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在文件管理器中把没用的文件删了,这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> test.txt</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>下次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用 强制删除选项 -f(译注:即 force 的首字母)。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这 样的数据不能被 Git 恢复。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除(亦即从暂存区域移除)，但仍然希望保留在当前工作目录中。 换句话说，想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> --cached README</span><br></pre></td></tr></table></figure>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数 据并不会体现出这是一次改名操作。 要在 Git 中对文件改名，可以这么做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> file_from file_to</span><br></pre></td></tr></table></figure>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="将本地仓库与远程仓库关联"><a href="#将本地仓库与远程仓库关联" class="headerlink" title="将本地仓库与远程仓库关联"></a>将本地仓库与远程仓库关联</h2><p><code>git remote add &lt;shortname&gt; &lt;url&gt; </code>添加一个新的远程 Git 仓库，同时指定一个方便 使用的简写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:spring-hao/git-study.git</span><br></pre></td></tr></table></figure>
<p>添加后，远程库的名字就是origin。</p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时 间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作 并将其合并进你的工作后才能推送。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<h2 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看已经配置的远程仓库服务器</span><br><span class="line">git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>
<p><strong>如果没有推送权限，就看不到push的地址。</strong><br>根据名字删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure>
<h2 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/gitskills.git</span><br><span class="line"></span><br><span class="line">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>
<p><code>fetch</code>会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支 的引用，可以随时合并或查看。</p>
<p>如果使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以<code>git fetch origin</code>会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意<code>git fetch</code>命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 </p>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。在Git中列出已有的标签非常简单，只需要输入git tag(可带上可选的-l选项–list):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">  v1.0</span><br><span class="line">  v2.0</span><br></pre></td></tr></table></figure>

<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>使用分支意味着你可以把你的工作从开发主线上分离开来， 以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的 副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>在进行提交操作时，Git会保存一个提交对象—-该对象会包含一个指向暂存内容的指针。不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象</p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一 个仓库都有master分支，是因为git init命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><blockquote>
<p>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">详细介绍</a></p>
</blockquote>
<p>创建dev分支，然后切换到dev分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<p>git switch 命令加上-c参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure>
<p>用git branch命令查看当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>
<p>在dev分支上修改提交后返回master分支,发现之前提交的内容不见了,因为刚才的操作是在dev分支,而master并没有改变.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>
<p>把dev分支的工作成果合并到master分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 4fad4f3..199e6c3</span><br><span class="line">Fast-forward</span><br><span class="line"> 4.txt     | 0</span><br><span class="line"> git-study | 1 +</span><br><span class="line"> 2 files changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 4.txt</span><br><span class="line"> create mode 160000 git-study</span><br></pre></td></tr></table></figure>
<p>在合并的时候，你应该注意到了“快进(fast-forward)”这个词。当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进 (指针右移)，因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进(fast-forward)”。</p>
<p>合并完成后，就可以放心地删除dev分支了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 Git 的分支实质上仅是包含所指对象校验和(长度为 40 的 SHA-1 值字符串)的文件，所以它的创建和销毁 都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节。<br>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录，所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础(译注:即共同祖先)也是同样的简单和高效。 </p>
</blockquote>
<h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><img src="/2021/08/25/Git/git%E5%B7%A5%E4%BD%9C%E6%B5%81-4e949255699145e2811f45967aa734d3.png" class="" title="git工作流">]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JSR303校验</title>
    <url>/2021/08/29/JSR303%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>处理一段业务逻辑，首先要确保数据输入的正确性，所以需要先对数据进行检查，保证数据在语义上的正确性，再根据数据进行下一步的处理。<br>前端可以通过 js 程序校验数据是否合法，后端同样也需要进行校验。而后端最简单的实现就是直接在业务方法中对数据进行处理，但是不同的业务方法可能会出现同样的校验操作，这样就出现了数据的冗余。为了解决这个情况，JSR 303 出现了。<br>JSR 303 使用 Bean Validation，即在 Bean 上添加相应的注解，去实现数据校验。这样在执行业务方法前，都会根据注解对数据进行校验，从而减少自定义的校验逻辑，减少代码冗余。</p>
<h1 id="2-springboot中JSR的使用"><a href="#2-springboot中JSR的使用" class="headerlink" title="2. springboot中JSR的使用"></a>2. springboot中JSR的使用</h1><h2 id="2-1引入依赖"><a href="#2-1引入依赖" class="headerlink" title="2.1引入依赖"></a>2.1引入依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-构建一个需要校验的java-Bean，通过校验注解进行对应的操作"><a href="#2-2-构建一个需要校验的java-Bean，通过校验注解进行对应的操作" class="headerlink" title="2.2 构建一个需要校验的java Bean，通过校验注解进行对应的操作"></a>2.2 构建一个需要校验的java Bean，通过校验注解进行对应的操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Null</span>    被注释的元素必须为 <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span>    被注释的元素必须不为 <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@AssertTrue</span>    被注释的元素必须为 <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@AssertFalse</span>    被注释的元素必须为 <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Min(value)</span>    被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"></span><br><span class="line"><span class="meta">@Max(value)</span>    被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"></span><br><span class="line"><span class="meta">@DecimalMin(value)</span>    被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"></span><br><span class="line"><span class="meta">@DecimalMax(value)</span>    被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"></span><br><span class="line"><span class="meta">@Size(max, min)</span>    被注释的元素的大小必须在指定的范围内</span><br><span class="line"></span><br><span class="line"><span class="meta">@Digits</span> (integer, fraction)    被注释的元素必须是一个数字，其值必须在可接受的范围内</span><br><span class="line"></span><br><span class="line"><span class="meta">@Past</span>    被注释的元素必须是一个过去的日期</span><br><span class="line"></span><br><span class="line"><span class="meta">@Future</span>    被注释的元素必须是一个将来的日期</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pattern(value)</span>    被注释的元素必须符合指定的正则表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-3-添加-Valid-开启校验"><a href="#2-3-添加-Valid-开启校验" class="headerlink" title="2.3 添加 @Valid 开启校验"></a>2.3 添加 @Valid 开启校验</h2><p>在请求方法中，使用校验注解@Valid，开启校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;</span><br><span class="line">brandService.save(brand);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> R.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>想要自定义错误消息，可以覆盖默认的错误提示信息,在添加注解的时候，修改message：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名必须非空&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-BindResult-可选"><a href="#2-4-BindResult-可选" class="headerlink" title="2.4 BindResult(可选)"></a>2.4 BindResult(可选)</h2><p>给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。加完以后，如果参数验证不通过，那就直接进入if语句里面，在语句里面做相应的返回结果.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( result.hasErrors())&#123;</span><br><span class="line">           Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="comment">//1.获取错误的校验结果</span></span><br><span class="line">           result.getFieldErrors().forEach((item)-&gt;&#123;</span><br><span class="line">               <span class="comment">//获取发生错误时的message</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">               <span class="comment">//获取发生错误的字段</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">               map.put(field,message);</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不合法&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">	brandService.save(brand);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.ok();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-定义全局异常类"><a href="#2-5-定义全局异常类" class="headerlink" title="2.5 定义全局异常类"></a>2.5 定义全局异常类</h2><p>使用Springboot所提供的@ControllerAdvice，通过“basePackages”能够说明处理哪些路径下的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中处理所有异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.bigdata..controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">handleValidException</span><span class="params">(MethodArgumentNotValidException exception)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> exception.getBindingResult();</span><br><span class="line">        bindingResult.getFieldErrors().forEach(fieldError -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> fieldError.getDefaultMessage();</span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> fieldError.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,exception.getMessage(),exception.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;数据校验出现问题&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java实战</category>
      </categories>
      <tags>
        <tag>JSR303校验</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2021/12/11/JUC/</url>
    <content><![CDATA[<h1 id="JUC概述"><a href="#JUC概述" class="headerlink" title="JUC概述"></a>JUC概述</h1><h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><ol>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类(很少使用，单继承原因)。</li>
<li>线程池<br>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用</li>
</ol>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread 类本身也是实现了 Runnable 接口，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable的run()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，多个FutureTask 进行同样的计算，只会运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">	<span class="comment">//重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    <span class="comment">//FutureTask 就是 Runnable 对象，因为 Thread 类只能执行 Runnable 实例的任务对象，所以把 Callable 包装成未来任务对象</span></span><br><span class="line"></span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：get()的行为取决于任务的状态，如果任务已经完成，那么get会立刻返回结果，否则get将<strong>阻塞直到任务完成</strong>，然后返回结果或者抛出异常。</p>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</li>
<li>线程的启动<strong>必须</strong>调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li>
<li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Thread 类 API：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public void start()</td>
<td align="left">启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td align="left">public void run()</td>
<td align="left">线程启动后调用该方法</td>
</tr>
<tr>
<td align="left">public void setName(String name)</td>
<td align="left">给当前线程取名字</td>
</tr>
<tr>
<td align="left">public void getName()</td>
<td align="left">获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td align="left">public static Thread currentThread()</td>
<td align="left">获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td align="left">public static void sleep(long time)</td>
<td align="left">让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td align="left">public static native void yield()</td>
<td align="left">提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td align="left">public final int getPriority()</td>
<td align="left">返回此线程的优先级</td>
</tr>
<tr>
<td align="left">public final void setPriority(int priority)</td>
<td align="left">更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td align="left">public void interrupt()</td>
<td align="left">中断这个线程，异常处理机制</td>
</tr>
<tr>
<td align="left">public static boolean interrupted()</td>
<td align="left">判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td align="left">public boolean isInterrupted()</td>
<td align="left">判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td align="left">public final void join()</td>
<td align="left">等待这个线程结束</td>
</tr>
<tr>
<td align="left">public final void join(long millis)</td>
<td align="left">等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td align="left">public final native boolean isAlive()</td>
<td align="left">线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td align="left">public final void setDaemon(boolean on)</td>
<td align="left">将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<h3 id="Runnable，Callable与Future关系"><a href="#Runnable，Callable与Future关系" class="headerlink" title="Runnable，Callable与Future关系"></a>Runnable，Callable与Future关系</h3><p>Thread只能接受Runnable参数，因此使用有返回值的Callable需要封装。</p>
<img src="/2021/12/11/JUC/Thread%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" class="" title="Thread构造方法">

<p>而Future接口提供了打断线程、获取返回值等功能。</p>
<img src="/2021/12/11/JUC/RunnableFuture.png" class="" title="RunnableFuture">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask接口通过构造函数注入，将Future于Callable结合。</p>
<img src="/2021/12/11/JUC/FutureTask.png" class="" title="FutureTask">

<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>CompletableFuture出现原因：</p>
<ol>
<li><code>Future.get()</code>会出现阻塞现象</li>
<li><code>Future.isDone()</code>会耗费CPU空转</li>
</ol>
<p>因此在jdk8出现了CompletableFuture接口，在Future处理完毕<strong>自动调用回调函数</strong>，展现了一种观察者模式的机制。 它可能代表一个明确完成的Future,也有可能代表一个完成阶段(CompletionStage),它支持在计算完成以后触发一些函数或执行某些动作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new incomplete CompletableFuture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompletableFuture创建"><a href="#CompletableFuture创建" class="headerlink" title="CompletableFuture创建"></a>CompletableFuture创建</h3><p><del>默认构造方法不建议使用</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//runAsync方法不支持返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="comment">//supplyAsync可以支持返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数式接口名称</th>
<th>方法名称</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>run</td>
<td>无参</td>
<td>无返回值</td>
</tr>
<tr>
<td>Function</td>
<td>apply</td>
<td>1个参数</td>
<td>有返回值</td>
</tr>
<tr>
<td>Consume</td>
<td>accept</td>
<td>1个参数</td>
<td>无返回值</td>
</tr>
<tr>
<td>Supplier</td>
<td>get</td>
<td>没有参数</td>
<td>有返回值</td>
</tr>
<tr>
<td>BiConsume</td>
<td>accept</td>
<td>2个参数</td>
<td>无返回值</td>
</tr>
</tbody></table>
<p><strong>使用实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         1.当一个线程依赖另一个线程时,可以使用thenApply()方法来把这两个线程串行化(第二个任务依赖第一个任务的结果)</span></span><br><span class="line"><span class="comment">         public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</span></span><br><span class="line"><span class="comment">         2.它可以处理正常的计算结果,或者异常情况</span></span><br><span class="line"><span class="comment">         public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</span></span><br><span class="line"><span class="comment">         3.异常的处理操作</span></span><br><span class="line"><span class="comment">         public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;).thenApply(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> result+<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// whenComplete虽然得到异常信息,但是无法修改返回数据</span></span><br><span class="line">        &#125;).whenComplete((v,e)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(e==<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result = &quot;</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// exceptionally: 同时感知异常,同时返回默认值</span></span><br><span class="line">        .exceptionally(e-&gt;&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;over...&quot;</span>);</span><br><span class="line">        <span class="comment">//主线程不要立即结束,否则CompletableFuture默认使用的线程池会立即关闭,暂停几秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="获得结果和触发计算-get、getNow、join、complete"><a href="#获得结果和触发计算-get、getNow、join、complete" class="headerlink" title="获得结果和触发计算(get、getNow、join、complete)"></a>获得结果和触发计算(get、getNow、join、complete)</h4><ol>
<li>public T get( ) 不见不散(会抛出异常) 只要调用了get( )方法,不管是否计算完成都会导致阻塞</li>
<li>public T get(long timeout, TimeUnit unit) 过时不候</li>
<li>public T getNow(T valuelfAbsent):没有计算完成的情况下给一个替代结果，计算完返回计算完成后的结果、没算完,返回设定的valuelfAbsent。<strong>立刻获取结果不阻塞</strong></li>
<li>public T join( ):join方法和get( )方法作用一样,不同的是,join方法不抛出异常</li>
<li>public boolean complete(T value ):若计算完成则正常返回，否则打断计算并返回value。<img src="/2021/12/11/JUC/%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%9C%E5%92%8C%E8%A7%A6%E5%8F%91%E8%AE%A1%E7%AE%97.png" class="" title="获得结果和触发计算"></li>
</ol>
<h4 id="对计算结果进行处理-thenApply、handle"><a href="#对计算结果进行处理-thenApply、handle" class="headerlink" title="对计算结果进行处理(thenApply、handle)"></a>对计算结果进行处理(thenApply、handle)</h4><ol>
<li><code>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply</code><br>计算结果存在依赖关系,这两个线程串行化<br>由于存在依赖关系(当前步错,不走下一步),当前步骤有异常的话就叫停</li>
<li><code>public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</code><br>有异常也可以往下一步走,根据带的异常参数可以进一步处理</li>
<li><code>whenComplete</code>:是执行当前任务的线程执行继续执行whenComplete的任务</li>
<li><code>whenCompleteAsync</code>:是执行把whenCompleteAsync这个任务继续提交给线程池来进行执行</li>
</ol>
<h4 id="对计算结果进行消费-thenRun、thenAccept、thenApply"><a href="#对计算结果进行消费-thenRun、thenAccept、thenApply" class="headerlink" title="对计算结果进行消费(thenRun、thenAccept、thenApply)"></a>对计算结果进行消费(thenRun、thenAccept、thenApply)</h4><ol>
<li><code>thenRun(Runnable runnable)</code><br>任务A执行完执行B,并且B不需要A的结果</li>
<li><code>CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code><br>任务A执行完成执行B,B需要A的结果,但是任务B无返回值</li>
<li><code>public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</code><br>任务A执行完成执行B,B需要A的结果,同时任务B有返回值</li>
<li>线程串行化<br>带了Async的方法表示的是:会重新在线程池中启动一个线程来执行任务<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span></span><br><span class="line"><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">                                                   Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span>         </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对计算速度进行选用-applyToEither、acceptEither、runAfterEither"><a href="#对计算速度进行选用-applyToEither、acceptEither、runAfterEither" class="headerlink" title="对计算速度进行选用(applyToEither、acceptEither、runAfterEither)"></a>对计算速度进行选用(applyToEither、acceptEither、runAfterEither)</h4><ol>
<li>applyToEither:两个任务有一个执行完成,获取它的返回值,处理任务并有新的返回值,谁快就用谁的结果</li>
<li>acceptEither:两个任务有一个执行完成,获取它的返回值,处理任务,没有新的返回值</li>
<li>runAfterEither:两个任务有一个执行完成,不需要获取 future 的结果,处理任务,也没有返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T, U&gt; fn,</span></span><br><span class="line"><span class="params">        Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(</span></span><br><span class="line"><span class="params">        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">    Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span><br><span class="line">                                                  </span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span>   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,</span></span><br><span class="line"><span class="params">                                                       Runnable action,</span></span><br><span class="line"><span class="params">                                                       Executor executor)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="对计算结果进行合并-thenCombine、thenAcceptBoth、runAfterBoth"><a href="#对计算结果进行合并-thenCombine、thenAcceptBoth、runAfterBoth" class="headerlink" title="对计算结果进行合并(thenCombine、thenAcceptBoth、runAfterBoth)"></a>对计算结果进行合并(thenCombine、thenAcceptBoth、runAfterBoth)</h4><ol>
<li><code>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code><br>两个CompletionStage任务都完成后,最终把两个任务的结果一起交给thenCombine来处理<br>先完成的先等着,等待其他分支任务</li>
</ol>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">resourse</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object lockA;</span><br><span class="line">    <span class="keyword">private</span> Object lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">resourse</span><span class="params">(Object lockA, Object lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有&quot;</span>+lockA+<span class="string">&quot;尝试&quot;</span>+lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;持有&quot;</span>+lockB+<span class="string">&quot;尝试&quot;</span>+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">resourse</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>), <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">resourse</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>), <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol>
<li>破坏请求与保持条件 ：一次性申请所有的资源。</li>
<li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>Monitor是一种同步机制，为了保证只有一个线程能访问到被保护的资源。JVM中同步是基于进入和退出监视器对象（ Monitor 管程对象）来实现的，每个对象实例都有一个Monitor对象。管程内部可以有多个条件变量，如果进入管程的线程发现条件不满足便会进入到对应的条件变量等待队列中。</p>
<p>Monitor对象会和Java对象一起创建和销毁，底层由C++实现。管程发展到现在共出现过三种不同的模型：Hasen 模型、Hoare 模型和 MESA 模型。Java 中管程的实现使用的就是MESA 模型，synchronized使用管程模型的方法，在代码编译的时候会自动封装起共享变量并提供一个线程安全的方法来访问，如下图所示。不过Java中synchronized使用的管程只有一个条件变量，Lock 接口下可以创建多个条件变量。</p>
<img src="/2021/12/11/JUC/839377608f47e7b3b9c79b8fad144065.png" class="" title="img">

<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是程序的一次执行过程，是<strong>系统进行资源分配的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程<strong>共享进程的堆和方法区资源</strong>，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，<strong>负担要比进程小得多</strong>，也正因为如此，线程也被称为轻量级进程。</p>
<p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p>
<h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><ol>
<li>用户线程<br>开发者自定义使用的线程<br>主线程结束，用户线程还在运行，jvm存活</li>
<li>守护线程<br>系统使用的线程，如垃圾回收</li>
</ol>
<p>用户线程和主线程都结 束，只剩守护线程运行，jvm结束</p>
<h4 id="线程的不同状态"><a href="#线程的不同状态" class="headerlink" title="线程的不同状态"></a>线程的不同状态</h4><p>线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<img src="/2021/12/11/JUC/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81-0d6ff91893194aa2ab28c668c83c8e03.png" class="" title="Java线程状态变迁.png">

<ol>
<li><p>NEW(新建)<br>表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</p>
</li>
<li><p>RUNABLE(准备就绪)<br>表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。</p>
</li>
<li><p>BLOCKED(阻塞)<br>阻塞状态,表明线程阻塞于锁.要结束该状态从而进入 RUNABLE 需要其他线程释放锁</p>
</li>
<li><p>WAITING(不见不散)<br>表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。<br>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有设置 Timeout 参数的 Object.wait() 方法</td>
<td align="center">Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td align="center">没有设置 Timeout 参数的 Thread.join() 方法</td>
<td align="center">被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.park() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<ol start="5">
<li>TIMED_WAITING(过期不候)<br>超时等待状态,无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</li>
</ol>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread.sleep() 方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Object.wait() 方法</td>
<td align="center">时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Thread.join() 方法</td>
<td align="center">时间结束 &#x2F; 被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.parkNanos() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td align="center">LockSupport.parkUntil() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td align="center">调用 Thread.sleep() 方法使线程进入超时等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入超时等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol start="6">
<li>TERMINATED(终结)<br>不管是意外退出还是正常执行结束，线程已经完成使命，终止运行</li>
</ol>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><img src="/2021/12/11/JUC/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8-ebdf0e2c64844e1dbe2775adcff026cb.png" class="" title="Java运行时数据区域JDK1.8">

<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存，不同的线程拥有不同的虚拟机栈</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park 等方法</li>
<li>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p>
<p>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）<br><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能<br>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li>并发： 是在同一实体上的多个事件，一台处理器同时处理多个任务，同一时刻只有一个事件在发生。多个线程对一个点（秒杀商品）</li>
<li>并行：是在不同实体上的多个事件，多台处理器处理多个任务，同一时刻多个事件一起发生</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="线程中断机制"><a href="#线程中断机制" class="headerlink" title="线程中断机制"></a>线程中断机制</h2><p>一个线程不应该由其他线程来强制中断或停止，<strong>而应该由自己决定自己的命运</strong>。因此，Thread.stop()等方法已经被废弃。</p>
<p>Java中没有办法立刻停止一个线程，然而停止线程却又非常重要，如取消一个耗时操作。因此Java提供了一种用于停止线程的协商机制-中断，<strong>即中断标识协商机制</strong>。</p>
<p>中断只是一种协商机制，中断的具体过程需要自己编写程序实现，若要中断一个线程，需要手动调用interrupt方法，该方法仅仅将线程的中断标识设为true。<strong>中断已经停止的线程不会产生任何影响</strong></p>
<ol>
<li><code>void interrupt( )</code><br>Thread提供了interrupt()，每个线程都有一个布尔类型的属性用来表示线程的中断状态，当中断线程时将设置这个状态。</li>
<li><code>boolean isInterrupted( )</code><br>判断当前线程是否被中断(通过检查中断标识位)</li>
<li><code>static boolean interrupted( )</code><br>返回当前线程的中断状态 并<strong>将当前线程的中断状态设为false</strong></li>
</ol>
<p>如果线程处于被阻塞状态(例如处于sleep、wait、join等状态),在别的线程中调用当前线程对象的interrupt方法,那么抛出一个InterruptedException异常并且<strong>中断标识也被清空</strong>置为false</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><ol>
<li>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作,解决了必须获取锁再阻塞的痛点</li>
<li>LockSupport是一个线程阻塞工具类,所有的方法都是静态方法,可以让线程在任意位置阻塞,阻塞之后也有对应的唤醒方法。归根结底,LockSupport调用的Unsafe中的native代码</li>
<li>LockSupport类使用了一种名为Permit(许可)的概念来做到阻塞和唤醒线程的功能,每个线程都有一个许可(permit),permit只有两个值1和零,默认是零</li>
</ol>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p><strong>结论</strong>：yield()从未导致线程转到等待&#x2F;睡眠&#x2F;阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。<strong>会放弃 CPU 资源，锁资源不会释放</strong></p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程(虚假唤醒问题,在哪里等待在哪里唤醒,因此wait需要放在循环中)。</p>
<p>它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h2 id="await-signalAll"><a href="#await-signalAll" class="headerlink" title="await()  signalAll()"></a>await()  signalAll()</h2><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">condition.signalAll();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>await(), signal()，signalAll() 的功能和 wait(), notify(), notifyAll() 基本相同， 区别是，基于 Condition 的 await(), signal(), signalAll() 使得我们可以在同一个锁的代码块内，优雅地实现基于多个条件的线程间挂起与唤醒操作</p>
<h2 id="wait-和-sleep-的区别"><a href="#wait-和-sleep-的区别" class="headerlink" title="wait() 和 sleep() 的区别"></a>wait() 和 sleep() 的区别</h2><ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会释放锁</li>
<li>可以被interruped方法中断，这时 sleep 方法会抛出 InterruptedException</li>
</ul>
<h1 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h1><h2 id="减少计数CountDownLatch"><a href="#减少计数CountDownLatch" class="headerlink" title="减少计数CountDownLatch"></a>减少计数CountDownLatch</h2><p><code>CountDownLatch</code>类可以设置一个计数器,然后通过<code>countDown()</code>方法来进行减1的操作,使用<code>await()</code>方法等待计数器变为0，如果计数器的值非0，那么<code>await()</code>会一直阻塞，或者等待中的线程中断或等待超时</p>
<ul>
<li><code>CountDownLatch</code>主要有两个方法,当一个或多个线程调用<code>await()</code>方法时,这些线程会阻塞</li>
<li>其他线程调用<code>countDown()</code>方法会将计数器减1(调用<code>countDown()</code>方法的线程不会阻塞)</li>
<li>当计数器的值变为0时,因<code>await()</code>方法阻塞的线程会被唤醒,继续执行</li>
</ul>
<h2 id="循环栅栏CycliBarrier"><a href="#循环栅栏CycliBarrier" class="headerlink" title="循环栅栏CycliBarrier"></a>循环栅栏CycliBarrier</h2><p><code>CycliBarrier</code>构造方法的第一个参数是目标障碍数,每次执行<code>CycliBarrier</code>障碍数会加一,如果达到了目标障碍数,才会执行<code>cycliBarrier.await()</code>之后的语句</p>
<p>让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，所有被阻塞的线程才能继续工作，线程通过<code>cycliBarrier.await()</code>方法</p>
<h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>信号量主要有两个目的：一个是用于多个共享资源的互斥使用，另一个是用于并发线程数的控制</p>
<p>Semaphore构造方法的参数是目标信号灯个数,每次执行<code>acquire()</code>会申请一个信号灯,<code>release()</code>会释放一个信号灯,申请不到灯就一直阻塞线程</p>
<h1 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h1><blockquote>
<p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么就称这个对象时线程安全的。<br>– Java并发编程实战</p>
</blockquote>
<p>管程（锁）：一种同步机制，保证同一时间，只有一个线程访问被保护的资源</p>
<p><strong>jvm同步基于进入和退出，使用管程对象实现</strong></p>
<h2 id="互斥同步-悲观"><a href="#互斥同步-悲观" class="headerlink" title="互斥同步(悲观)"></a>互斥同步(悲观)</h2><p>除非需要使用 ReentrantLock 的高级功能，比如可定时的、可轮询的、可中断的、公平队列，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="synchronized-JVM-实现"><a href="#synchronized-JVM-实现" class="headerlink" title="synchronized(JVM 实现)"></a>synchronized(JVM 实现)</h3><p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个指令都需要一个引用类型的参数来指明要锁定和解锁的对象。<br>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件阻塞后边其他线程的进入。</p>
<p>synchronized 修饰的方法<strong>不具备继承性</strong>，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是子类对象作为锁</p>
<h4 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;                </span><br><span class="line"><span class="comment">// ...        </span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>指定加锁对象，对给定对象&#x2F;类加锁。<code>synchronized(this|object)</code>表示进入同步代码库前要获得给定对象的锁。<code>synchronized(类.class)</code>表示进入同步代码前要获得当前class的锁</p>
<h4 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2. 同步一个方法"></a>2. 同步一个方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于同一个对象</p>
<h4 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3. 同步一个类"></a>3. 同步一个类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<h4 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4. 同步一个静态方法"></a>4. 同步一个静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类。但是对于其他线程调用非静态方法不会产生影响，因为访问静态 synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁</p>
<h3 id="Lock接口-JDK实现"><a href="#Lock接口-JDK实现" class="headerlink" title="Lock接口(JDK实现)"></a>Lock接口(JDK实现)</h3><p>Lock锁相比<code>synchronized</code>增加了一些高级功能，可以允许更灵活的结构，主要有：等待可中断、可实现公平锁、锁可以绑定多个条件</p>
<p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。                </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol>
<li><p>两者都是可重入锁（递归锁）<br><strong>可重入锁</strong> 指的是同一线程外层函数获得锁之后，再进入该线程的内层方法会自动获取锁（前提，锁对象得是同一个对象），不会因为之前已经获取过还没释放而阻塞。也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。如果加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直再等待</p>
<p>可重入锁最大的最用就是避免死锁</p>
</li>
<li><p>等待可中断<br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</p>
<p>使用synchronized 时,等待的线程会一直等待下去,不能够响应中断，除非抛出异常或正常运行完成</p>
<p>ReentrantLock 可中断：</p>
<ol>
<li>设置超时方法</li>
<li>调用interrupt()方法可中断</li>
</ol>
</li>
<li><p>公平锁<br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的</p>
<p>非公平锁的优点在于吞吐量比公平锁大</p>
</li>
<li><p>原始构成<br>Lock是一个接口，而synchronized是关键字。Lock在发生异常时，如果没主动<code>unlock()</code>去释放锁，则很可能造成死锁现象；synchronized是内置实现，jvm原生支持，由jvm保证不会发生死锁现象，只有在同步代码块中才能调用wait&#x2F;notify方法。</p>
</li>
<li><p>通过Lock可以知道有没有成功获取到锁,而synchronized无法办到。</p>
</li>
<li><p>锁绑定多个条件<br>synchronized不能精确唤醒，与wait()和notify()&#x2F;notifyAll()方法相结合可以实现一个等待&#x2F;通知机制</p>
<p>ReentrantLock可以和多个条件关联，只需多次调用newCondition()方法即可，Condition实例的signalAll()方法只会唤醒注册在该Condition实例中的所有等待线程。如ArrayBlockingQueue</p>
</li>
</ol>
<h2 id="非阻塞同步-乐观"><a href="#非阻塞同步-乐观" class="headerlink" title="非阻塞同步(乐观)"></a>非阻塞同步(乐观)</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p><strong>互斥同步</strong>属于一种<strong>悲观</strong>的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁</p>
<p><strong>乐观并发策略</strong>：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为<strong>非阻塞同步</strong></p>
<blockquote>
<p>参考JVM中关于CAS部分</p>
</blockquote>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>同步与线程安全没有必要联系，同步只是保证存在共享数据争用时正确性的手段，若能让一个方法本来就不设计共享数据，那么它自然就是安全的。</p>
<p>线程本地存储(ThreadLocal)：把共享数据的可见范围限制在同一个线程之内。在Java中，如果一个变量要被多线程访问，可以使用volatile关键字声明；如果一个变量只要被一个线程独享，可以通过ThreadLocal来实现线程本地存储的功能。</p>
<p>每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocalHashCode为键，以本地线程变量为值的K-V键值对，使用每个ThreadLocal对象的hashcode值就能找回对应的本地线程变量。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>通过一个共享的队列,可以使得数据由队列的一段输入,从另一端输出。阻塞队列内部包含了足够的内部同步机制，可以安全的入队出队</p>
<img src="/2021/12/11/JUC/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-460e4241c3c04ecc987559a73478efa7.png" class="" title="阻塞队列">

<p>当队列是空的,从队列中获取元素的操作将会被阻塞</p>
<p>当队列是满的,从队列中添加元素的操作将会被阻塞</p>
<p>试图从空的队列中获取元素的线程将会被阻塞,直到其他线程往空队列中插入新的元素</p>
<p>试图向已满的队列中添加元素的线程将会被阻塞,直到其他线程从队列中移除一个或多个元素,使队列变得空闲起来并后续新增</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p><strong>ArrayBlockingQueue</strong><br>基于数组的阻塞队列,除了维护一个定长数组外,ArrayBlockingQueue内部还保存两个整形变量,分别表示队列的头部和尾部，FIFO。使用Lock的条件变量绑定多个条件，将 wait、notify、notifyAll 等操作转化为相应的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">	<span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">	lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">	notEmpty = lock.newCondition();</span><br><span class="line">	notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	使用条件 notEmpty 完成take阻塞操作</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        	notEmpty.await();</span><br><span class="line">    	<span class="keyword">return</span> dequeue();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedBlockingQueue</strong><br>基于链表的阻塞队列,由链表结构组成的有界(大小默认值为integer.MAX_VALUE)阻塞队列，慎用，FIFO</p>
</li>
<li><p>DelayQueue<br>使用优先级队列实现的延迟无界阻塞队列</p>
</li>
<li><p>PriorityBlockingQueue<br>支持优先级排序的无界阻塞队列</p>
</li>
<li><p><strong>SynchronousQueue</strong><br>不存储元素的阻塞队列，即单个元素的队列。每个put操作必须等待一个take操作，否则不能继续添加元素，<code>Executors.newCachedThreadPool()</code>根据需要创建新的线程</p>
</li>
<li><p>LinkedTransferQueue<br>由链表组从的无界阻塞队列</p>
</li>
<li><p>LinkedBlockingDeque<br>由链表组成的<strong>双向</strong>阻塞队列</p>
</li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><img src="/2021/12/11/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84-2f4a6690f4904fe089a0d3cb01562fe1.png" class="" title="线程池架构">

<p>优点：</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>《阿里巴巴Java开发手册》中强制线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险</p>
<h3 id="1-通过构造方法实现"><a href="#1-通过构造方法实现" class="headerlink" title="1. 通过构造方法实现"></a>1. 通过构造方法实现</h3><img src="/2021/12/11/JUC/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2a5650e5b932445aaf30fa0840f1c58c.png" class="" title="ThreadPoolExecutor构造方法">

<h3 id="2-通过工具类Executors来实现"><a href="#2-通过工具类Executors来实现" class="headerlink" title="2. 通过工具类Executors来实现"></a>2. 通过工具类<code>Executors</code>来实现</h3><p>工具类中的方法内部实际调用了ThreadPoolExecutor的构造方法</p>
<ul>
<li>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务，线程池的规模不受限制。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>shutdown()方法将执行平稳的关闭过程：不再接受新的任务，同时等待已提交的任务执行完成——包括那些还未开始执行的任务。</p>
<h2 id="ThreadPoolExecutor类分析"><a href="#ThreadPoolExecutor类分析" class="headerlink" title="ThreadPoolExecutor类分析"></a>ThreadPoolExecutor类分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory</span></span><br><span class="line"><span class="params">        threadFactory,RejectedExecutionHandler handler)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(corePoolSize&lt; <span class="number">0</span>||maximumPoolSize&lt;=<span class="number">0</span>||maximumPoolSize&lt;corePoolSize ||keepAliveTime&lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span>(workQueue==<span class="literal">null</span>||threadFactory==<span class="literal">null</span>||handler==<span class="literal">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize=corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize=maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue=workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime=unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory=threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler=handler;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数参数分析"><a href="#构造函数参数分析" class="headerlink" title="构造函数参数分析"></a>构造函数参数分析</h3><ul>
<li><strong>corePoolSize</strong>: 常驻线程数量(核心线程数)</li>
<li><strong>maximumPoolSize</strong>: 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为<strong>最大线程数量</strong>。</li>
<li><strong>workQueue</strong>: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory :表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。<ul>
<li>默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。</li>
</ul>
</li>
<li>handler:拒绝策略</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务,则会按照策略执行</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy(默认)： 抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy： “调用者运行”调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</li>
<li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃等待最久的任务请求,然后把当前任务加入队列。</li>
</ul>
<blockquote>
<p>如果在代码中模拟了10个任务，配置的核心线程数为5、等待队列容量为100，&gt; &gt; 所以每次只可能存在5个任务同时执行，剩下的5个任务会被放到等待队列中去。&gt; 当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h2 id="execute方法和submit方法"><a href="#execute方法和submit方法" class="headerlink" title="execute方法和submit方法"></a>execute方法和submit方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execute方法，无返回值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">//submit方法</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p><code>execute()</code> 提交没有返回值，也就不能判断是否执行成功。</p>
<p><code>submit()</code>会返回一个<code>Future</code>对象，通过future的get方法来获取返回值，不过get方法会阻塞住直到任务完成。</p>
<h1 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h1><p>Fork&#x2F;Join可以将一个大的任务拆分成多个子任务进行并行处理,最后将子任务结果合并成最后的计算结果,并进行输出</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote>
<p>Java并发编程实战P253</p>
</blockquote>
<h2 id="前置-LockSupport"><a href="#前置-LockSupport" class="headerlink" title="前置:LockSupport"></a>前置:LockSupport</h2><p>用于创建锁和其他同步类的基本线程阻塞原语,LockSupport类使用了一种名为Permit(许可)的概念来做到<strong>阻塞和唤醒线程</strong>,每个线程都有一个Permit,Permit只有1和0,默认是0</p>
<p>可以把Permit看成是一种(0,1)信号量,但与信号量不同的是,Permit的累加上限是1.</p>
<p>唤醒线程:</p>
<ol>
<li>使用Object中的wait()方法让线程等待,使用Object中的notify()方法唤醒线程<ol>
<li>必须在同步代码块中使用wait()方法和notify()方法,否则会出现异常</li>
<li>将notify()方法放在wait()前面,程序无法执行,无法唤醒</li>
</ol>
</li>
<li>使用JUC包中Condition的await()方法让现场等待,使用signal()方法唤醒线程<ol>
<li>必须在同步代码块中使用,否则会出现异常</li>
<li>signal()方法放在await()方法前面,程序无法执行,无法唤醒</li>
</ol>
</li>
<li>LockSupport的park()和unpark()作用分别是阻塞线程和解除阻塞线程</li>
</ol>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>park()&#x2F;park(Object blocker)<br>permit默认是0,所以一开始调用park()方法,当前线程就会阻塞,直到别的线程将当前线程的permit设置为1时,park()方法会被唤醒,然后会将permit再次设置为0并返回</li>
<li>unpark(Thread thread)<br>调用unpark(thread)方法后,就会将thread线程的permit设置成1(多次调用不会累加,最大为1)会自动唤醒thread线程,即之前阻塞中的park()方法会立即返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;</span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">    UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LockSupport是一个线程阻塞工具类,所有的方法都是静态方法,可以让线程在任意位置阻塞,阻塞后也有对应的唤醒方法.归根到底,LockSupport调用的Unsafe中的native代码.</p>
<h2 id="AQS入门"><a href="#AQS入门" class="headerlink" title="AQS入门"></a>AQS入门</h2><p><code>AbstractQueuedSynchronizer</code>简称AQS，是一个抽象类(模板设计模式)，作为顶层设计供其余类继承，是用来构建锁或者其他同步器组件的<strong>重量级基础框架以及整个JUC体系的基石</strong>。</p>
<p>AQS使用一个volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装呈一个Node节点来实现锁的分配，通过CAS完成对State值的修改</p>
<blockquote>
<p>例如ReentrantLock用state来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数。</p>
</blockquote>
<p>根据同步器的不同，获取操作可以是独占的(ReentrantLock.tryRelease)，也可以是非独占操作的(Semaphore.tryReleaseShared)。</p>
<img src="/2021/12/11/JUC/AQS-9b5799ca7b994376ab553bed7376cd7b.png" class="" title="AQS">

<p>AQS具有头尾指针,前后指针.Node内部类的等待状态变量<code>waitStatus</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractQueuedSynchronizer的内部Node类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="comment">//共享</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//独占</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程被取消了</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后继线程需要唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待condition唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//共享式同步状态获取将会无条件传播下去</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始0,状态是以上介绍</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AQS解读-Lock"><a href="#AQS解读-Lock" class="headerlink" title="AQS解读(Lock)"></a>AQS解读(Lock)</h2><p>Lock接口的实现类,基本都是通过<strong>聚合</strong>了一个<strong>队列同步器</strong>的子类完成线程访问控制的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/12/11/JUC/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AF%B9%E6%AF%94-0a43f56dfbea4baa9cfa80542330afa2.png" class="" title="非公平锁与公平锁对比">

<p>存储线程的双向链表中,第一个节点为虚节点(哨兵节点),并不存储任何信息,只是占位.真正的第一个有数据的节点,是从第二个节点开始的</p>
<h1 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">share</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">share</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pro</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> res;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            res = blockingQueue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + data + <span class="string">&quot;插入队列成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;插入队列失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cus</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            res = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">null</span> || res.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;超过两秒没有取到,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + res + <span class="string">&quot;消费队列成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile/CAS/AtomicInteger/BlockingQueue/线程交互/原子引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">share</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                share.pro();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                share.cus();</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        share.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2021/11/17/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="i与i"><a href="#i与i" class="headerlink" title="++i与i++"></a><code>++i</code>与<code>i++</code></h2><p>无论是<code>i++</code>和<code>++i</code>，对于 i 变量本身来说没有任何区别，执行的结果都是i变量的值加1,关键在于和&#x3D;的结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">++i;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span> + i);<span class="comment">//i=3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++;</span><br><span class="line">System.out.println(<span class="string">&quot;j=&quot;</span> + j);<span class="comment">//先将i赋值给j,再将i自增.i=4,j=3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ++i;</span><br><span class="line">System.out.println(<span class="string">&quot;m=&quot;</span> + m);<span class="comment">//先将i自增,再将自增后的值赋给m,m=5,i=5</span></span><br><span class="line">System.out.println(m++);<span class="comment">//先打印m后将m自增,打印结果是5,m=6</span></span><br><span class="line">System.out.println(++m);<span class="comment">//m先自增后打印,打印结果是7</span></span><br></pre></td></tr></table></figure>

<h2 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D;和 equals 的区别"></a>&#x3D;&#x3D;和 equals 的区别</h2><p>对于基本数据类型来说，&#x3D;&#x3D;比较的是值。对于引用数据类型来说，&#x3D;&#x3D;比较的是内存的地址。</p>
<blockquote>
<p>Java只有值传递，所以，对于&#x3D;&#x3D;来说，不管是比较基本数据类型还是引用数据类型，其本质都是比较值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong>注意</strong>：string类型重写了equals方法,比较的是值<br><code>Object</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a == b);	<span class="comment">//true</span></span><br><span class="line">System.out.println(a == c);	<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));	<span class="comment">//true</span></span><br><span class="line">System.out.println(a.equals(c));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>解析:<br><code>String a = &quot;aaa&quot;</code>,内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址付给栈指针，如果已经有了”aaa”的内存，直接把地址赋给栈指针。只在常量池中有一份内存空间，地址全部相同</p>
<p>只要是new String()，则，栈中的地址都是指向最新的new出来的堆中的地址</p>
<h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h2><ol>
<li><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p>
<blockquote>
<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
</li>
<li><p>HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
</li>
</ol>
<h2 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h2><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序 </li>
<li><code>comparator</code>接口实际上是出自<code>java.util</code>包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>需要对一个集合使用自定义排序时，就要重写<code>compareTo()</code>方法或<code>compare()</code>方法</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>JAVA的赋值运算是有返回值的，赋了什么值，就返回什么值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (flag = <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出true</p>
<h2 id="amp-amp-与-amp-，-与-的区别"><a href="#amp-amp-与-amp-，-与-的区别" class="headerlink" title="&amp;&amp;与&amp;，||与|的区别"></a>&amp;&amp;与&amp;，||与|的区别</h2><p>&amp;&amp;和&amp;都是表示与，区别是&amp;&amp;只要第一个条件不满足，后面条件就不再判断。而&amp;要对所有的条件都进行判断。</p>
<h1 id="int和Integer"><a href="#int和Integer" class="headerlink" title="int和Integer"></a>int和Integer</h1><p><strong>Java 语言虽然号称一切都是对象，但原始数据类型是例外</strong>。8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：byte、short、int、long、float、double，所占大小分别为1，2，4，8，4，8字节</li>
<li>1 种字符类型：char，2字节</li>
<li>1 种布尔型：boolean，1字节</li>
</ol>
<blockquote>
<p>int是基本数据类型，默认值为0<br>Integer是类，属于引用数据类型，默认值为null</p>
</blockquote>
<p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能，Java 可以根据上下文自动进行转换，极大地简化了相关编程。<strong>默认缓存是 -128 到 127 之间。</strong></p>
<h2 id="理解自动装箱、拆箱"><a href="#理解自动装箱、拆箱" class="headerlink" title="理解自动装箱、拆箱"></a>理解自动装箱、拆箱</h2><p>自动装箱实际上算是一种<strong>语法糖</strong>。 Java 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()，保证不同的写法在运行时等价，它们发生在<strong>编译阶段</strong>，也就是生成的字节码是一致的。</p>
<p>原则上，<strong>建议避免无意中的装箱、拆箱行为</strong>，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>缓存上限值实际是可以根据需要调整的，实现在 IntegerCache 的静态初始化块里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>包装类里存储数值的成员变量“value”，不管是 Integer 还 Boolean 等，都被声明为“private final”，所以，它们同样是不可变类型！</p>
<h2 id="原始类型线程安全"><a href="#原始类型线程安全" class="headerlink" title="原始类型线程安全"></a>原始类型线程安全</h2><ul>
<li>原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全，如果有线程安全的计算需要，建议考虑使用类似 AtomicInteger、AtomicLong 这样的线程安全类。</li>
<li>特别的是，部分比较宽的数据类型，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！</li>
</ul>
<h2 id="Java-原始数据类型和引用类型局限性"><a href="#Java-原始数据类型和引用类型局限性" class="headerlink" title="Java 原始数据类型和引用类型局限性"></a>Java 原始数据类型和引用类型局限性</h2><ul>
<li><p>原始数据类型和 Java 泛型并不能配合使用<br>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种<strong>编译期的技巧</strong>，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p>
</li>
<li><p>无法高效地表达数据，也不便于表达复杂的数据结构，比如 vector 和 tuple<br>Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</p>
</li>
</ul>
<h1 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String, StringBuffer, StringBuilder"></a>String, StringBuffer, StringBuilder</h1><p>String 被声明为 final，因此它不可被继承，不可变，线程安全。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。<br><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串<code>char[]value</code>，但是没有用<code>final</code>关键字修饰，所以这两种对象都是可变的。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销</p>
<h2 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1. 可变性"></a>1. 可变性</h2><ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<h2 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2. 线程安全"></a>2. 线程安全</h2><ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h2 id="3-字符串缓存"><a href="#3-字符串缓存" class="headerlink" title="3. 字符串缓存"></a>3. 字符串缓存</h2><p>intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。Intern 是一种<strong>显式地排重机制</strong>，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()    new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> s4.intern();<span class="comment">//将这个字符串对象尝试放入串池,如果有则不放入,如果没有就放入并返回串池中的对象</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == intern);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="使用的总结："><a href="#使用的总结：" class="headerlink" title="使用的总结："></a>使用的总结：</h2><ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="instance-关键字"><a href="#instance-关键字" class="headerlink" title="instance 关键字"></a>instance 关键字</h2><p>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</p>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>最终的、不可修改的，用来修饰<strong>类、方法和变量</strong>，具有以下特点：</p>
<ol>
<li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li>
<li>final 修饰的方法不能被重写；</li>
<li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>
</ol>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用，this引用会自动应用于同一个类中的其他方法，只有当需要明确指出对当前对象的引用时才需要使用this关键字。</p>
<p><code>return this</code>直接返回当前对象的引用，常常用于链式操作。</p>
<p>在构造器中如果为this添加了参数列表，那么将产生对符合此参数列表的某个构造器的明确调用。尽管可以用this调用一个构造器，但却不能调用两个，除此之外，必须将构造器调用置于最起始处，否则会编译报错。除构造器之外，编译器禁止在其他任何方法中调用构造器</p>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><ol>
<li>修饰<strong>成员变量和成员方法</strong>，不能修饰接口，接口只能用public和abstract修饰</li>
<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块<strong>只执行一次</strong>.</li>
<li>静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：a. 它的创建是不需要依赖外围类的创建。b. 它不能使用任何外围类的非 static 成员变量和方法。</li>
</ol>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>用于从子类访问父类的变量和方法<br><strong>注意:</strong></p>
<ul>
<li>构造器中使用<code>super()</code>调用父类中的其他构造方法时，该语句必须处于构造器的首行，this 调用本类中的其他构造方法时，也要放在首行</li>
<li>this、super 不能用在 static 方法中</li>
</ul>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table>
<thead>
<tr>
<th>访问修饰符</th>
<th>访问范围</th>
<th>继承性</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>本类内部</td>
<td>不可继承</td>
</tr>
<tr>
<td>default</td>
<td>本类+同包</td>
<td>同包子类可以继承</td>
</tr>
<tr>
<td>protected</td>
<td>本类+同包+子类</td>
<td>可以继承</td>
</tr>
<tr>
<td>public</td>
<td>公开</td>
<td>可以继承</td>
</tr>
</tbody></table>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在没有泛型类之前，必须使用Object编写适用于多种类型的代码，这中操作繁琐且不安全。在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是会丢失子类特有的方法，若子类重写父类的方法则不会丢失。而除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的，如果向下转型为错误的类型，就会得到一个运行时错误的异常。</p>
<p>泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。在进行泛型操作时，编译器会检查传入的参数是否为指定泛型，这比传一个Object类型的参数要安全得多。出现编译错误要比运行时出现类的强制类型转换异常好得多，泛型使程序更易读、更安全。</p>
<h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><ol>
<li>无参数无返回值的方法</li>
<li>有参数无返回值的方法</li>
<li>有返回值无参数的方法</li>
<li>有返回值有参数的方法</li>
<li>return 在无返回值方法的特殊使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f5</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h2><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法）<code>类名.方法名</code>，而实例方法不存在这个限制。</p>
<h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><p>重载是方法根据传入参数名字的不同，自动选择不同的方法执行(编译时就确定)<br>重写的本质是根据方法接收者的实际类型来选择方法版本</p>
<blockquote>
<p>深入理解Java虚拟机 P311</p>
</blockquote>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法<strong>返回值和访问修饰符</strong>可以不同</p>
<blockquote>
<p>不能有两个名字相同，参数相同，返回值或修饰符不同的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态分派与重载</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态类型Human   实际类型Man</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Random</span>()).nextBoolean() ? <span class="keyword">new</span> <span class="title class_">Man</span>() : <span class="keyword">new</span> <span class="title class_">Woman</span>();<span class="comment">//父类指向子类对象,多态</span></span><br></pre></td></tr></table></figure>
<ul>
<li>静态类型：静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知</li>
<li>实际类型：实际类型变化的结果在运行时才确定，编译器在编译时不知道一个对象的实际类型是什么<blockquote>
<p>代码中对象human的实际类型在编译器是一个“薛定谔的人”，必须等到程序运行到这行代码才能确定。而human的静态类型编译时就知道了，也可以在使用时强制类型转换来改变这个类型，但这个改变在编译器仍然可知。</p>
</blockquote>
</li>
</ul>
<p>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的，由于静态类型在编译器已知，所以在编译期间就决定了使用哪个重载版本。</p>
<p>所有依赖静态类型来决定方法执行版本的分派动作都成为静态分派，静态分派最典型的表现就是方法重载，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机执行的。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类对父类的<strong>允许访问</strong>的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明</li>
<li>构造方法无法被重写</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>名字与类名相同</li>
<li><strong>没有返回值</strong>，但是不能用void声明构造函数</li>
<li>生成对象时自动执行</li>
</ol>
<p>构造方法不能被 override（重写），但是可以 overload（重载）</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li>error：属于程序无法处理的错误，没办法通过 catch 来进行捕获，大多数错误与代码编写者所执行的操作无关</li>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。代码在编译过程中，如果受检查异常没有被 catch&#x2F;throw 处理的话，就没办法通过编译</li>
<li>运行时异常：运行时异常程序员导致的异常。即使不处理此类异常也可以正常通过编译，并不强制进行显示处理</li>
</ul>
<h2 id="异常的结构"><a href="#异常的结构" class="headerlink" title="异常的结构"></a>异常的结构</h2><img src="/2021/11/17/Java%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE-c444dd42d5db472bb4c305f9281e7b15.png" class="" title="Java异常类层次结构图.png">

<p><code>RuntimeException</code>及其子类都统称为非受检性异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><ul>
<li>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块： 用于处理 try 捕获到的异常。若有一个catch语句匹配到了，则执行该catch块中的异常处理代码，就不再尝试匹配别的catch块了。</li>
<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p>当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值</span></span><br></pre></td></tr></table></figure>
<h1 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h1><h2 id="1-运算符关系"><a href="#1-运算符关系" class="headerlink" title="1. 运算符关系"></a>1. 运算符关系</h2><ul>
<li>赋值&#x3D;，最后计算</li>
<li>&#x3D;右边的从左到又依次压入<strong>操作数栈</strong></li>
<li>实际计算过程看运算符优先级</li>
<li>自增，自减操作都是直接修改变量值，不经过<strong>操作数栈</strong></li>
<li>临时结果也是存储在<strong>操作数栈</strong>中</li>
</ul>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()、[]、{}</td>
<td>从左向右</td>
</tr>
<tr>
<td>2</td>
<td>!、+、-、~、++、--</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*、&#x2F;、%</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>«、»、&gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>&#x3D;&#x3D;、!&#x3D;</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;、~&#x3D;、«&#x3D;、»&#x3D;、&gt;&gt;&gt;&#x3D;</td>
<td>从右向左</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>,y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (++x == y-- &amp; x++ ==1 || --y == 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y);      //x = 2,y = 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    System.out.println(&quot;y=&quot;+y+&quot;,x=&quot;+x);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(++x == y--)</span><br><span class="line">    System.out.println(<span class="string">&quot;y=&quot;</span>+y+<span class="string">&quot;,x=&quot;</span>+x); <span class="comment">//成立！  //y=0 x=1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br></pre></td></tr></table></figure>
<p>其中：<br><code>++x</code>先计算再其他，<code>x++</code>先其他再计算，输出为计算后的结果！</p>
<p>第二个if语句输出：先计算<code>++x</code>为1，再判断是否与y相等（y判断后<code>--</code>）；结果y计算了一遍，输出了<code>y--</code>为0</p>
<p><code>||</code>左边成立不再计算右边；<code>|</code>即使左边成立也要计算右边！</p>
<h2 id="2-代码注释问题"><a href="#2-代码注释问题" class="headerlink" title="2. 代码注释问题"></a>2. 代码注释问题</h2><p>Java中注释不会被编译，注释量不影响编译后的程序大小</p>
<h2 id="3-Java单例模式-线程安全"><a href="#3-Java单例模式-线程安全" class="headerlink" title="3. Java单例模式(线程安全)"></a>3. Java单例模式(线程安全)</h2><p>单例模式要点: </p>
<ol>
<li>只能有一个实例<ul>
<li>构造器私有化</li>
</ul>
</li>
<li>必须自行创建这个实例<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
</li>
<li>必须自行向整个系统提供这个实例<ul>
<li>对外提供获取该实例对象的方式</li>
</ul>
</li>
</ol>
<p><strong>静态内部类方式</strong></p>
<p>不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。<br>静态内部类有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleObject</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//静态内部类（不会随着外部类的初始化而初始化）创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">SingleObject</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Inner.instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance</code>采用<code>volatile</code>关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton()</code>; 这段代码分三步执行： </p>
<ol>
<li>为<code>uniqueInstance</code>分配内存空间 </li>
<li>初始化<code>uniqueInstance</code></li>
<li>将<code>uniqueInstance</code>指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<code>getUniqueInstance()</code>后发现<code>uniqueInstance</code>不为空，因此返回<code>uniqueInstance</code>，但此时<code>uniqueInstance</code>还未被初始化。</p>
<h2 id="4-try-catch-finally-普通"><a href="#4-try-catch-finally-普通" class="headerlink" title="4. try-catch-finally-普通"></a>4. try-catch-finally-普通</h2><p>首先进入try代码块，若不抛出异常，则catch不运行，finally运行，接着继续往下运行普通代码；若抛出异常，则运行catch，由于catch中有return语句，finally中会在catch中的return语句之前运行</p>
<p>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">sRet</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            sRet += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            sRet += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sRet += <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        func(<span class="number">1</span>);	<span class="comment">//12</span></span><br><span class="line"><span class="comment">//        func(2);	//01</span></span><br><span class="line">        System.out.println(sRet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-类的加载顺序"><a href="#5-类的加载顺序" class="headerlink" title="5. 类的加载顺序"></a>5. 类的加载顺序</h2><ol>
<li>父类静态对象和静态代码块</li>
<li>子类静态对象和静态代码块</li>
<li>父类非静态对象和非静态代码块</li>
<li>父类构造函数</li>
<li>子类非静态对象和非静态代码块</li>
<li>子类构造函数</li>
</ol>
<p>其中：类中静态区域按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(在类加载到方法区的时候执行)</p>
<p>静态块：用staitc声明，jvm加载类时执行，仅执行一次<br>构造代码块：类中直接用{}定义，每一次创建对象时执行<br><strong>执行顺序优先级：静态域,main(),构造代码块,构造方法。</strong></p>
<h2 id="6-重写原则"><a href="#6-重写原则" class="headerlink" title="6. 重写原则"></a>6. 重写原则</h2><p>方法名相同，参数类型相同，子类中可能需要调用父类方法，因此需要满足两同两小一大原则：</p>
<ul>
<li>方法名相同，参数类型相同</li>
<li>子类返回类型小于等于父类方法返回类型</li>
<li>子类抛出异常小于等于父类方法抛出异常</li>
<li>子类访问权限大于等于父类方法访问权限</li>
</ul>
<h2 id="7-类型转换"><a href="#7-类型转换" class="headerlink" title="7. 类型转换"></a>7. 类型转换</h2><p>(byte1，short2，char2)–int4–long8–float4–double8<br>按照字节数由高到低<br>小数如果不加 f 后缀，默认是double类型。</p>
<h2 id="8-成员变量与局部变量"><a href="#8-成员变量与局部变量" class="headerlink" title="8. 成员变量与局部变量"></a>8. 成员变量与局部变量</h2><ul>
<li>就近原则</li>
<li>变量的分类<ul>
<li>成员变量:类变量,实例变量</li>
<li>局部变量</li>
</ul>
</li>
<li>非静态代码块:每次创建实例都会执行</li>
<li>方法调用:调用一次执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        j++;</span><br><span class="line">        i++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test1.test(<span class="number">10</span>);</span><br><span class="line">        test1.test(<span class="number">20</span>);</span><br><span class="line">        test2.test(<span class="number">30</span>);</span><br><span class="line">        System.out.println(test1.i + <span class="string">&quot;,&quot;</span> + test1.j + <span class="string">&quot;,&quot;</span> + test1.s);<span class="comment">//2,1,5</span></span><br><span class="line">        System.out.println(test2.i + <span class="string">&quot;,&quot;</span> + test2.j + <span class="string">&quot;,&quot;</span> + test2.s);<span class="comment">//1,1,5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>踩坑点:</p>
<ol>
<li>用<code>static</code>修饰的所有类共享,不管用哪个对象,指向的都是同一数据</li>
<li>代码块中定义的变量同样有作用域</li>
<li><code>int</code>类型的默认值是0</li>
<li>就近原则可以被<code>this</code>关键字打破</li>
</ol>
<h2 id="9-抽象类和接口"><a href="#9-抽象类和接口" class="headerlink" title="9. 抽象类和接口"></a>9. 抽象类和接口</h2><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义</p>
<p>抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p>
<p><strong>Java 不支持多继承，</strong>为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法，否则会出现编译错误。对于抽象类，如果我们添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</p>
<p>接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。有一类没有任何方法的接口，通常叫作 Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如熟知的 Cloneable、Serializable 等。</p>
<p>Java 8 增加了函数式编程的支持，所以又增加了一类定义，即所谓 functional interface，简单说就是只有一个抽象方法的接口，通常建议使用 @FunctionalInterface Annotation 来标记。Lambda 表达式本身可以看作是一类 functional interface<br><strong>语法层面上的区别：</strong></p>
<ol>
<li>抽象类可以提供成员<strong>方法的实现</strong>细节，而接口中方法无实现；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>抽象类不允许被实例化，只能被继承。</li>
</ol>
<p><strong>设计层面上的区别：</strong></p>
<ol>
<li>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅 仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问 题，隔离接口和具体的实现，提高代码的扩展性。</li>
<li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</li>
</ol>
<p>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题， 那么就用抽象类;如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那就用接口。</p>
<h2 id="10-finalize"><a href="#10-finalize" class="headerlink" title="10. finalize"></a>10. finalize</h2><p>它是object中的一个方法，若子类重写它，垃圾回收是就会调用此方法，不过将一些资源释放操作或清理操作放在finalize方法中非常不好，严重影响性能，甚至可能会导致OOM，从Java9开始已经被标记为废弃不建议使用了。</p>
<ul>
<li>当重写了finalize方法的对象，在构造方法调用时，JVM会将其包装成Finalizer对象并将其加入到unfinalize队列中。 </li>
<li>不同对象的finalize方法调用顺序并没有保证</li>
<li>finalize方法中若出现异常，不会进行输出</li>
<li>重写了finalize方法的对象在第一次被gc时，并不能及时释放它所占用的内存，要等守护线程执行完finalize方法并把它从unfinalize队列移除后，第二次gc时才能彻底移除。这就导致不能及时释放内存，增加出现OOM的错误。</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2021/12/10/JVM/</url>
    <content><![CDATA[<h1 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h1><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作</p>
<img src="/2021/12/10/JVM/JVM-%E6%A6%82%E8%BF%B0%E5%9B%BE-6b0f1b0647494d45892416333482c87a.png" class="" title="JVM-概述图">

<p>Java 代码执行流程：java程序 –（编译）–&gt; 字节码文件 –（解释执行）–&gt; 操作系统（Win，Linux）</p>
<h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p>
<ul>
<li>基于栈式架构的特点：<ul>
<li>设计和实现简单，适用于资源受限的系统</li>
<li>使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现<ul>
<li>零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器</li>
<li>一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数</li>
</ul>
</li>
<li>不需要硬件的支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点：<ul>
<li>需要硬件的支持，可移植性差</li>
<li>性能更好，执行更高效，寄存器比内存快</li>
<li>以一地址指令、二地址指令、三地址指令为主</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡。</p>
<ul>
<li><p><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</p>
</li>
<li><p><strong>运行</strong>：</p>
<ul>
<li><p>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</p>
</li>
<li><p>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，<strong>JVM 使用的是守护线程，main() 和其他线程使用的是用户线程</strong>，守护线程会随着用户线程的结束而结束</p>
</li>
<li><p>执行一个 Java 程序时，真真正正在执行的是一个 Java 虚拟机的进程</p>
</li>
<li><p>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</p>
<p>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</p>
</li>
</ul>
</li>
<li><p><strong>死亡</strong>：</p>
<ul>
<li>当程序中的用户线程都中止，JVM 才会退出</li>
<li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li>
<li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 java 安全管理器允许这次 exit 或 halt 操作</li>
</ul>
</li>
</ul>
<h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域</p>
<img src="/2021/12/10/JVM/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png" class="" title="Java运行时数据区域JDK1.8">

<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧（<strong>一个方法一个栈帧</strong>）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程</p>
<p>虚拟机栈特点：</p>
<ul>
<li>虚拟机栈是<strong>每个线程私有的</strong>，对虚拟机来说只有在栈顶的方法才是运行的，位于栈顶的方法被称为”当前栈帧”</li>
<li>栈内存<strong>不需要进行GC</strong>，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</li>
<li>栈内存分配越大越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）</li>
<li>方法内的局部变量是否<strong>线程安全</strong>：<ul>
<li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>异常：</p>
<ul>
<li><code>StackOverFlowError</code> : 线程请求的栈深度超过最大值</li>
<li><code>OutOfMemoryError</code> : 栈帧过多导致栈内存溢出 （超过了栈的容量）</li>
</ul>
<blockquote>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型，其中的数据没有初始化阶段，要想使用必须显示地赋初值。</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈类似，它们之间的区别只是本地方法栈为本地方法服务</p>
<ul>
<li>不需要进行GC，与虚拟机栈类似，也是线程私有的，有 StackOverFlowError 和 OutOfMemoryError 异常</li>
<li>虚拟机栈执行的是 Java 方法，在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一</li>
<li>本地方法一般是由其他语言编写，并且被编译为基于本机硬件和操作系统的程序</li>
<li>当某个线程调用一个本地方法时，就进入了不再受虚拟机限制的世界，和虚拟机拥有同样的权限<ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong></li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
<li>可以直接使用本地处理器中的寄存器</li>
</ul>
</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（寄存器）主要有两个作用：</p>
<ol>
<li>解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而保证线程切换后能恢复到正确的执行位置</li>
</ol>
<p>特点：</p>
<ul>
<li>是线程私有的</li>
<li>是 JVM 规范中唯一一个<strong>不出现 OOM 的区域</strong>，所以这个空间不会进行 GC</li>
</ul>
<p>程序计数器的生命周期随着线程的创建而创建，随着线程的结束而死亡</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>几乎所有对象及数组都在这里分配内存，是垃圾收集的主要区域（”GC 堆”），虚拟机启动时创建，由所有线程共享，堆中对象大部分都需要考虑线程安全的问题<br>存放哪些资源：</p>
<ul>
<li>对象实例：类初始化生成的对象，<strong>基本数据类型的数组也是对象实例</strong>，new 创建对象都使用堆内存</li>
<li>字符串常量池：<ul>
<li>字符串常量池原本存放于方法区，jdk7 开始放置于堆中</li>
<li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li>
</ul>
</li>
<li>静态变量：静态变量是有 static 修饰的变量，jdk7 时从方法区迁移至堆中</li>
<li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li>
</ul>
<p>在 Java7 中堆内会存在<strong>年轻代、老年代和方法区（永久代）</strong>：</p>
<ul>
<li>Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区。Survivor 区某一时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。在 Eden 区变满的时候， GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间</li>
<li>Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区</li>
<li>Perm 代主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区：是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</p>
<p>方法区是一个 JVM 规范，<strong>永久代与本地内存的元空间都是其一种实现方式</strong></p>
<p>方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)</p>
<p>方法区的 GC：针对常量池的回收及对类型的卸载，比较难实现</p>
<p>为了<strong>避免方法区出现 OOM</strong>，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，<strong>静态变量和字符串常量池等放入堆中</strong></p>
<p>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p>
<p>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了<strong>类在编译期间生成的字面量、符号引用</strong>，JVM 为每个已加载的类维护一个常量池</p>
<ul>
<li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li>
<li>符号引用：类、字段、方法、接口等的符号引用</li>
</ul>
<p>运行时常量池是方法区的一部分</p>
<ul>
<li>常量池表（编译器生成的字面量和符号引用）中的数据会在类加载后放入运行时常量池</li>
<li>类在解析阶段将这些符号引用替换成直接引用</li>
<li>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</li>
</ul>
<h2 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h2><p>本地内存：又叫做<strong>堆外内存</strong>，线程共享的区域，本地内存这块区域是不会受到 JVM 的控制的，不会发生 GC；因此对于整个 java 的执行效率是提升非常大，但是如果内存的占用超出物理内存的大小，同样也会报 OOM</p>
<p>本地内存概述图：</p>
<img src="/2021/12/10/JVM/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94-43d46a97971a475ea72f08e65ff6a3d6.png" class="" title="JVM-内存图对比">
<hr>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>永久代被元空间代替，永久代的<strong>类信息、方法、常量池</strong>等都移动到元空间区</p>
<p>元空间与永久代区别：元空间不在虚拟机中，使用的本地内存，默认情况下，元空间的大小仅受本地内存限制</p>
<p>方法区内存溢出：</p>
<ul>
<li><p>JDK1.8 以前会导致永久代内存溢出：java.lang.OutOfMemoryError: PerGen space</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize=8m		<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK1.8 以后会导致元空间内存溢出：java.lang.OutOfMemoryError: Metaspace</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=8m	<span class="comment">#参数设置	</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。不受jvm内存回收管理</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><strong>堆空间的基本结构：</strong></p>
<img src="/2021/12/10/JVM/%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-ea84ba5737524cec9020c64b4f35d79a.png" class="" title="堆空间的基本结构.png">

<h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ol>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快<br><strong>触发条件：</strong><ul>
<li>当 Eden 空间满时，就将触发一次 Minor GC</li>
</ul>
</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多<br><strong>触发条件：</strong><ul>
<li>调用 System.gc()<br>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存</li>
<li>老年代空间不足<br>老年代空间不足的常见场景大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。</li>
<li>空间分配担保失败<br>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC</li>
</ul>
</li>
</ol>
<h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>避免在 Eden 和 Survivor 之间的大量内存复制而降低效率。</p>
<h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>主要是针对对象内存的回收和对象内存的分配，垃圾收集最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a><del>1. 引用计数算法</del></h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>以 GC Roots 作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则<strong>表示可以回收</strong></p>
<img src="/2021/12/10/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-3ae729d2de624472908fc65840ea65fb.png" class="" title="可达性分析算法.png">

<p>GC Roots（Set） 一般包含以下内容：</p>
<ul>
<li>虚拟机栈（局部变量表）中引用的对象</li>
<li>本地方法栈中 JNI（Native方法） 引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>使用 new 一个新对象的方式来创建强引用，此时它储与可达状态，不可能被垃圾回收，即使该对象以后永远不会被用到。因此强引用是造成内存泄漏的主要原因之一</p>
<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。软引用通常用在对内存敏感的程序中，比如高速缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历引用队列，如果有元素，则移除</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">        list.remove(poll);</span><br><span class="line">        <span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">        poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>只具有弱引用的对象拥有更短暂的生命周期。被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>虚引用并不会决定对象的生命周期，也无法通过虚引用得到一个对象。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收，虚引用必须和引用队列联合使用</p>
<p>虚引用的唯一目的是能在这个对象被回收时收到一个系统通知，用来跟踪对象被垃圾回收的活动。</p>
<h3 id="5-终结器引用"><a href="#5-终结器引用" class="headerlink" title="5. 终结器引用"></a>5. 终结器引用</h3><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><img src="/2021/12/10/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4-d583c73e1a3e41debb823b417bc1aae7.png" class="" title="标记清除">

<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li>效率问题</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ol>
<h3 id="2-标记-复制"><a href="#2-标记-复制" class="headerlink" title="2. 标记 - 复制"></a>2. 标记 - 复制</h3><img src="/2021/12/10/JVM/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6-e9558462686544318ee168b6e0ad018c.png" class="" title="标记复制">

<p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<h3 id="3-标记-整理"><a href="#3-标记-整理" class="headerlink" title="3. 标记 - 整理"></a>3. 标记 - 整理</h3><img src="/2021/12/10/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86-27f56b62f84f45a7a33e3cccffb94141.png" class="" title="标记整理">

<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。<br>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：标记 - 复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="/2021/12/10/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-656711ef1db540019b36d53b734595c9.jpg" class="" title="垃圾收集器">
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 <strong>CMS 和 G1</strong>之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="1-Serial-收集器-串行"><a href="#1-Serial-收集器-串行" class="headerlink" title="1. Serial 收集器(串行)"></a>1. Serial 收集器(串行)</h3><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/2021/12/10/JVM/Serial%20%E6%94%B6%E9%9B%86%E5%99%A8-1f8f34505fa741009fd7b3f57812437b.png" class="" title="Serial 收集器">

<p>它以串行的方式执行。<br>它是单线程的收集器，只会使用一个线程进行垃圾收集工作，会暂停所有的用户线程，不适合服务器环境。<br>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<h3 id="2-ParNew-收集器-并行"><a href="#2-ParNew-收集器-并行" class="headerlink" title="2. ParNew 收集器(并行)"></a>2. ParNew 收集器(并行)</h3><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/2021/12/10/JVM/ParNew%20%E6%94%B6%E9%9B%86%E5%99%A8-e8510337c392420aa5b32be7e28fbd7b.png" class="" title="ParNew 收集器">

<p>它是 Serial 收集器的多线程版本。<br>它是 Server 场景下默认的<strong>新生代收集器</strong>，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。<br>它是激活CMS后的默认新生代收集器。</p>
<h3 id="3-Parallel-Scavenge-收集器-吞吐量优先"><a href="#3-Parallel-Scavenge-收集器-吞吐量优先" class="headerlink" title="3. ++Parallel Scavenge 收集器(吞吐量优先)++"></a>3. ++Parallel Scavenge 收集器(吞吐量优先)++</h3><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/2021/12/10/JVM/Parallel%E6%94%B6%E9%9B%86%E5%99%A8-e3c36ed9dffa40cb90c7b4189b4a81b2.png" class="" title="Parallel收集器">

<p>也是使用多线程收集器，是 JDK1.8 <strong>默认收集器</strong><br>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU），CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。Parallel Scavenge 收集器提供自适应调节策略（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以达到最大利用），垃圾收集停顿时间是以牺牲吞吐量和新生代空间换取的。</p>
<hr>
<h3 id="4-Serial-Old-收集器-串行"><a href="#4-Serial-Old-收集器-串行" class="headerlink" title="4. Serial Old 收集器(串行)"></a>4. <del>Serial Old 收集器(串行)</del></h3><p>Serial 收集器的<strong>老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="5-Parallel-Old-收集器-吞吐量优先"><a href="#5-Parallel-Old-收集器-吞吐量优先" class="headerlink" title="5. Parallel Old 收集器(吞吐量优先)"></a>5. Parallel Old 收集器(吞吐量优先)</h3><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量或者注重CPU资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器-并发"><a href="#6-CMS-收集器-并发" class="headerlink" title="6. ++CMS 收集器(并发)++"></a>6. <em>++CMS 收集器(并发)++</em></h3><img src="/2021/12/10/JVM/CMS%20%E6%94%B6%E9%9B%86%E5%99%A8-ce625f3c94114306bff7859daf2e3f2c.jpg" class="" title="CMS 收集器">

<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法，一种以获取最短回收停顿时间为目标的老年代收集器。整个过程分为四个步骤：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：清理删除掉判断死亡的对象，不需要停顿。</li>
</ul>
<p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。</p>
<p>主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感</li>
<li>无法处理浮动垃圾，有可能出现失败进而导致另一次完全stop the world的full gc产生；必须预留部分空间来保证并发时程序运行使用，若预留内存不够使用，则冻结用户线程并启用Serial Old 收集器</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用。也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则会造成回收失败，此时将触发担保机制，Serial Old作为备用将会进行GC，从而造成较大停顿时间。</p>
<hr>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>是一款面向<strong>服务端</strong>的垃圾收集器，以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征，JDK 9以后默认使用，而且替代了CMS 收集器。<strong>整体上是标记-整理算法，两个区域之间是标记-复制算法</strong>，不会产生很多内存碎片</p>
<p>G1把连续的堆内存划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要，扮演新生代的Eden空间、Survvivor空间、老年代空间。收集器对扮演不同角色的Region采用不同的策略处理。Region中还有一类特殊的Humongous区域，专门用来存储大对象。</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作步骤：</p>
<ul>
<li>初始标记：只标记GC Roots能直接关联到的对象，并修改TAMS指针的值，让下一阶段用户线程并发运行时能正确地在可用的Region中分配对象。此阶段需要停顿线程</li>
<li>并发标记：进行GC Roots Tracing的过程，耗时较长，但可与用户程序并发执行</li>
<li>最终标记：对用户线程做一个短暂停顿，用于处理并发标记期间因程序运行导致标记发生变化的那一部分对象</li>
<li>筛选回收：根据时间来进行价值最大化的回收，必须暂停用户线程以移动Region</li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<img src="/2021/12/10/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE-28b4d960958844c0a4ab2d1a971c4604.png" class="" title="G1收集器运行示意图">

<p>可以由用户指定期望的停顿时间是G1收集器很强大的功能，设置不同的期望时间，可使得G1在不同场景下取得关注吞吐量和关注延迟之间的最佳平衡</p>
<p>与CMS相比有点：</p>
<ol>
<li>G1不会产生内存碎片</li>
<li>可以精确控制停顿。G1收集器把整个堆分成多个固定大小的区域，每次根据允许停顿额时间去收集垃圾最多的区域</li>
</ol>
<p>与CMS相比缺点：</p>
<ol>
<li>内存占用高</li>
<li>程序运行时的额外执行负载高</li>
</ol>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><img src="/2021/12/10/JVM/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-3f1c7c15ad654fdaa46aca7816fe76c5.png" class="" title="类的生命周期">

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。包含了加载、++验证、准备、解析++(统称为连接)和初始化这 5 个阶段。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时数据结构。</li>
<li><strong>在内存中生成一个代表该类的<code>Class</code>对象</strong>，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>加载阶段完成后，二进制字节流就存储在方法区中了。</p>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h3><h4 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1. 验证"></a>2.1. 验证</h4><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</p>
<h4 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2. 准备"></a>2.2. 准备</h4><p>为类变量分配内存并设置类变量<strong>初始值</strong>的阶段，初始值一般为 0 值。不包括实例变量，类变量会分配在方法区（JDK8之后类变量都在堆中）中，而实例变量会在对象实例化时随着对象一起被分配在堆中。<br><code>public static int value = 123;</code><br>那么变量value在准备阶段后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，给value赋值123的动作存放于类构造器<code>&lt;clinit&gt;()</code>中，要到类的初始化阶段才会被执行。</p>
<p>此阶段不包含用final修饰的static，因为常量在编译阶段就分配了，准备阶段会显示初始化。</p>
<blockquote>
<p>static+final修饰的其他引用类型常量和final修饰的实例属性，在实例创建的时候才会赋值</p>
</blockquote>
<h4 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3. 解析"></a>2.3. 解析</h4><p>将常量池的符号引用转换为直接引用的过程。</p>
<h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h3><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java代码，将主导权移交给应用程序，此前的几个阶段除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机主导控制。</p>
<p>严格规定有且只有六种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic四条字节码指令</li>
<li>对类型进行反射调用的时候</li>
<li>当初始化类时，发现其父类还没有进行过初始化，则需要先初始化其父类</li>
<li>当虚拟机启动时，用户需指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类</li>
<li>JDK7中的动态语言支持</li>
<li>被default修饰的接口方法的实现类发生初始化，那么该接口要在其之前初始化<blockquote>
<p>一个接口在初始化时，并不要求其父接口全部完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</p>
</blockquote>
</li>
</ol>
<ul>
<li>初始化阶段是执行类构造器方法<code>&lt;clinit&gt; ()</code>的过程。<br>此方法并不是程序员直接在代码中编写的方法，它是javac编译器自动<strong>收集类中的所有类变量的赋值动作和静态代码块中的语句</strong>合并而来，编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">	   i = <span class="number">0</span> ;<span class="comment">//给变量赋值可以正常编译通过</span></span><br><span class="line">	   System.out.print(i) ;<span class="comment">//编译器会提示&quot;非法向前引用&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>&lt;clinit&gt; ()</code>不同于类的构造器（<code>&lt;init&gt; ()</code>），它不需要显示地调用父类构造器，虚拟机会保证子类的<code>&lt;clinit&gt; ()</code>执行前，父类的<code>&lt;clinit&gt; ()</code>已经执行完毕</li>
<li>由于父类的<code>&lt;clinit&gt; ()</code>方法先执行，意味着父类中定义的静态语句块要优于子类的变量赋值操作</li>
<li><code>&lt;clinit&gt; ()</code>方法并不是必须的，若一个类没有静态语句块，也没有对变量的赋值操作，那么就不会生成</li>
<li>执行接口的<code>&lt;clinit&gt; ()</code>方法不会先执行父接口的<code>&lt;clinit&gt; ()</code>，只有父接口中定义的变量被使用时，父接口才会被初始化。此外接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt; ()</code>方法</li>
<li>虚拟机保证一个类的<code>&lt;clinit&gt; ()</code>方法在多线程下被同步加锁</li>
</ul>
<blockquote>
<p>类的初始化顺序：（静态变量、静态代码块：取决于它们在类中的出现顺序）-&gt;（普通成员变量、初始化代码块：取决于它们在类中的出现顺序）-&gt;构造器</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不同。</p>
<p>JVM只有两种类型的类加载器，分别为启动类加载器（BootstrapClassLoader）和自定义类加载器，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>，Java虚拟机规范将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<ol>
<li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载<code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被<code>-Xbootclasspath</code>参数指定的路径中的所有类，用于提供JVM自身所需要的类。启动类加载器无法被Java程序直接引用</li>
<li>ExtensionClassLoader(扩展类加载器) ：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的 jar 包和类，或被<code>java.ext.dirs</code>系统变量所指定的路径下的 jar 包。</li>
<li>AppClassLoader(应用程序类加载器) ：面向用户的加载器，负责加载当前应用<code>classpath</code>下的所有 jar 包和类。</li>
</ol>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器（一般不是以继承实现的）</p>
<p>Java虛拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。如果一个类加载器收到了类加载的请求，它首先不会自己区尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的请求最终都应该传送到顶层的启动类加载器<code>BootstrapClassLoader</code>中。只有当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器<code>BootstrapClassLoader</code>作为父类加载器。</p>
<img src="/2021/12/10/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-f36b2b1145bf47fc82502d6243dcbed4.png" class="" title="双亲委派模型">

<p>优势：</p>
<ol>
<li>保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）</li>
<li>保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，如编写一个称为<code>java.lang.Object</code>类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</li>
</ol>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JAVA内存模型（JMM）本身是一种抽象概念并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量的访问方式。</p>
<p>JMM关于同步的规定：</p>
<ol>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>
<li>加锁解锁是同一把锁</li>
</ol>
<p>JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程私有的数据区域，而JMM规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都能访问，但<u>线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存</u>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<em>变量拷贝副本</em>，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成。</p>
<blockquote>
<p>此时所说的主内存、工作内存于Java内存区域中的堆、栈、方法区并不是同一个层次的对内存的划分，两者几乎没有任何关系</p>
</blockquote>
<p>JMM定义了一套在多线程读写共享数据时(成员变量,数组)时，对数据的可见性、有序性和原子性的规则和保障</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，以上的结果可能是正数、负数、零。</p>
<p>对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自增</span></span><br><span class="line">getstatic i</span><br><span class="line"><span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1</span><br><span class="line"><span class="comment">// 准备常量1</span></span><br><span class="line">iadd</span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line">putstatic i</span><br><span class="line"><span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>多线程下自增自减可能交错运行，导致读取到错误的值</p>
<p><strong>解决方法</strong></p>
<ul>
<li>使用<strong>synchronized</strong>关键字</li>
<li>使用<code>AtomicInteger</code>（原子数据类型，基于CAS实现）</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[]args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (run) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>工作内存与主内存同步延迟现象造成了可见性问题</p>
<p><strong>解决方法</strong></p>
<ul>
<li>使用<strong>volatile</strong>关键字</li>
<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>
</ul>
<p>可见性保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， <strong>不能保证原子性</strong>，仅用在一个写线程，多个读线程的情况</p>
<blockquote>
<p>注意<br>final可以保证可见性<br>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized是属于重量级操作，性能相对更低。</p>
</blockquote>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><strong>指令重排</strong>：JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong>，<strong>多线程下『指令重排』会影响正确性</strong>。</p>
<p><strong>解决办法</strong>：<strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p>
<ul>
<li>禁止的是加volatile关键字变量之前的代码被重排序</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>先行发生（happens-before）是Java内存模型中定义的<strong>两项操作之间的偏序关系</strong>，Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则。它是判断数据是否存在竞争，线程是否安全的有效手段，如果两个操作之间缺乏happens-before关系，那么JVM可以对他们任意地重排序。</p>
<p>Java内存模型具备以下天然的先行发生关系：</p>
<ul>
<li>程序次序规则：在一个线程内，按照<strong>控制流</strong>顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的任何操作</li>
<li>线程终止规则：线程中的所有操作都先行发生于此线程的终止检测</li>
<li>线程中断规则：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
<li>传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行</li>
</ul>
<h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 即 Compare and Swap ，它体现的一种<strong>乐观锁</strong>的思想，乐观并发需要硬件保证某些语义上看需要多次操作的行为可以通过一条处理器指令就能完成。它的功能是判断内存某个位置的值是否为预期值，如果是则更新，这个过程是原子的。Java中调用Unsafe类中的CAS方法，JVM会实现出原子操作，达到数据一致。</p>
<p>比如多个线程要对一个共享的整型变量执行 +1 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">int</span> 旧值 = 共享变量 ; <span class="comment">// 比如拿到了当前值 0</span></span><br><span class="line">	<span class="type">int</span> 结果 = 旧值 + <span class="number">1</span>; <span class="comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候</span></span><br><span class="line"><span class="comment">    compareAndSwap 返回 false，重新尝试，直到：</span></span><br><span class="line"><span class="comment">    compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123;</span><br><span class="line">	<span class="comment">// 成功，退出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p>
<ul>
<li>synchronized 是基于<strong>悲观锁</strong>的思想</li>
<li>CAS 是基于<strong>乐观锁</strong>的思想，体现的是无锁并发、无阻塞并发，缺点：<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，重试必然频繁发生，可能给cpu带来很大的开销</li>
<li>只能保证一个共享变量的原子操作</li>
<li>引出ABA问题</li>
</ul>
</li>
</ul>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><ol>
<li>unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地方法来访问，基于该类可以直接操作特定内存的数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//this指的是对象本身</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>变量valueOffset表示该变量值在内存中的偏移地址，因为unsafe就是根据内存偏移地址获取数据的。</li>
<li>变量value用volatile修饰，保证了多线程间的内存可见性。</li>
</ol>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS会导致ABA问题。CAS算法实现的一个前提是需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差会发生数据的变化。</p>
<blockquote>
<p>如线程1从内存位置V取出数据A，此时线程2也从内存取出数据A，由于线程2运行速度快，它将A变成B又变成A，这时候线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功。虽然线程1CAS操作成功，但是这个过程是存在问题的。</p>
</blockquote>
<p>ABA解决：<code>AtomicStampedReference</code>（原子引用+时间戳）</p>
<blockquote>
<p>目前来说这个类处于相当鸡肋的位置，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能比原子类更加高效<br>– 深入理解Java虚拟机</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">user</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通原子引用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">user</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">user</span>(<span class="string">&quot;小米&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="type">user</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">user</span>(<span class="string">&quot;华为&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        AtomicReference&lt;user&gt; userAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        userAtomicReference.set(user1);</span><br><span class="line">        System.out.println(userAtomicReference.compareAndSet(user1, user2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicStampedReference</code>使用详解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;===============ABA问题产生============&quot;);</span></span><br><span class="line"><span class="comment">//        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            atomicReference.compareAndSet(&quot;A&quot;, &quot;B&quot;);</span></span><br><span class="line"><span class="comment">//            atomicReference.compareAndSet(&quot;B&quot;, &quot;A&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;, &quot;线程1&quot;).start();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(atomicReference.compareAndSet(&quot;A&quot;, &quot;B&quot;) + &quot;\t&quot; + atomicReference.get());</span></span><br><span class="line"><span class="comment">//        &#125;, &quot;线程2&quot;).start();</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============ABA问题解决============&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第1次版本号&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第2次版本号&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第3次版本号&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第1次版本号&quot;</span>+stamp);</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t第2次版本号&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;线程4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ </span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i </span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i </span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span></span><br><span class="line"><span class="keyword">final</span> System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>synchronized 代码块是由一对儿 monitorenter&#x2F;monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。</p>
<p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>现代的（Oracle）JDK 中，JVM 提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<p>构造方法不能使用 synchronized 关键字修饰，因为<strong>构造方法就是线程安全的</strong></p>
<p>锁可以升级, 但不能降级. 即: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<img src="/2021/12/10/JVM/%E9%94%81%E5%8D%87%E7%BA%A7.png" class="" title="锁升级">

<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用自旋（默认 10 次）来进行优化，让后面请求锁的那个线程执行一个忙循环，不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁，这就是自旋锁。自旋锁不能代替阻塞，自旋需要占用处理器时间，因此自旋等待的时间必须有由一定限度。</p>
<p>优点：不会进入阻塞状态，减少线程上下文切换的消耗</p>
<p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p>
<p>在 Java 6 之后自旋锁是自适应的，比如在同一个对象上，刚刚的一次自旋操作成功过并且持有锁的线程正在运行中，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;myLock&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;myUnLock&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(thread, <span class="literal">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p>
<ol>
<li>当锁对象第一次被线程获取时，虚拟机把对象头中的标志位设置为”01”、把偏向模式设置为”1”，表示进入偏向模式，同时使用 CAS 把获取到这个锁的线程ID记录在对象的 MarkWord 中，如果成功，则获取偏向锁成功；如果失败，则进行锁升级。</li>
<li>偏向锁标志是已偏向状态，MarkWord 中的线程 ID 是自己的线程 ID，则成功获取锁；MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级</li>
</ol>
<blockquote>
<p>大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。如果在重入到一定阈值之后仍然没有任何线程抢占行为发生，JVM就会省略CAS这个操作，以后只要不发生竞争，这个对象就归该线程所有。</p>
</blockquote>
<p>当对象进入偏向状态时，MarkWord大部分的空间都用于存储持有锁的线程ID，占用了原有存储对象哈希码的位置。因此，当一个对象已经计算过一致性哈希码后，他就再也无法进入偏向锁状态了；而当一个对象正处于偏向锁状态，又收到一条计算哈希的指令，它的偏向状态就会立即撤销，并且膨胀为重量级锁。</p>
<p>以下几种情况会使对象的偏向锁失效:</p>
<ul>
<li>调用对象的hashCode方法</li>
<li>多个线程使用该对象</li>
<li><strong>调用了wait&#x2F;notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li>
</ul>
<p>如果程序中大多数的锁都是被多个不同的线程访问，那么偏向模式就是多余的，此时禁用偏向锁反而可能会提升性能</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁使用场景</strong>：一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）。轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。<br><strong>加锁</strong>：</p>
<ul>
<li>首先在当前线程的栈帧中建立一个<strong>锁记录</strong>（Lock Record）对象，用来存储锁定对象的Mark Word拷贝（不再一开始就使用Monitor）<img src="/2021/12/10/JVM/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811-374c1fcc15a54e76aea62433c10d3fda.png" class="" title="轻量级锁1"></li>
<li>然后虚拟机使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针<img src="/2021/12/10/JVM/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812-30e70af2014649a9b688f1b9e38610e9.png" class="" title="轻量级锁2"></li>
<li>如果cas替换成功，则将对象Mark Word的锁标志位转变为<strong>00（轻量级锁状态）</strong>，并由该线程给对象加锁<img src="/2021/12/10/JVM/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%813-6df823326fcb4416a759b0fe639423ce.png" class="" title="轻量级锁3"></li>
<li>如果更换失败，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁</li>
</ul>
<p>有线程A和线程B来竞争对象c的锁(如: synchronized(c){}), 这时线程A和线程B同时将对象c的MarkWord复制到自己的锁记录中, 两者竞争去获取锁, 假设线程A成功获取锁, 并将对象c的对象头中的线程ID(MarkWord中)修改为指向自己的锁记录的指针, 这时线程B仍旧通过CAS去获取对象c的锁, 因为对象c的MarkWord中的内容已经被线程A改了, 所以获取失败. 此时为了提高获取锁的效率, 线程B便尝试使用自旋来获取锁, 这个循环是有次数限制的, 如果在循环结束之前CAS操作成功, 那么线程B就获取到锁, 如果循环结束依然获取不到锁, 则获取锁失败, 对象c的MarkWord中的记录会被修改为重量级锁, 然后线程B就会被挂起, 之后有线程C来获取锁时, 看到对象c的MarkWord中的是重量级锁的指针, 说明竞争激烈, 直接挂起</p>
<p><strong>解锁</strong>：<br>它的解锁过程同样是通过CAS操作的，如果对象的Mark Word仍然指向线程的所记录，那就要CAS操作把对象当前的Mark Word和线程中复制的Mark Word替换回来。假如能够替换成功，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁是使用操作系统互斥量（mutex）来实现的传统锁。当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同，竞争的线程不再通过自旋来竞争线程，而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程，然后线程再次竞争锁。</p>
<p>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态下的MarkWord，其中自然可以存储原来的哈希码。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗, 和执行非同步代码方法的性能相差无几</td>
<td>如果线程间存在锁竞争, 会带来额外的锁撤销的消耗.</td>
<td>适用于只有一个线程访问的同步场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞, 提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程, 使用自旋会消耗CPU</td>
<td>追求响应时间, 同步快执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋, 不会消耗CPU</td>
<td>线程堵塞, 响应时间缓慢</td>
<td>追求吞吐量, 同步快执行时间速度较长</td>
</tr>
</tbody></table>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><ol>
<li><p>减少上锁时间<br>同步代码块中尽量短</p>
</li>
<li><p>减少锁的粒度<br>将一个锁拆分为多个锁提高并发度，例如：ConcurrentHashMap</p>
</li>
<li><p>锁粗化<br>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p>
</li>
</ol>
<p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>锁消除<br>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p>
</li>
<li><p>读写分离</p>
<ol>
<li>CopyOnWriteArrayList </li>
<li>ConyOnWriteSet</li>
</ol>
</li>
</ol>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>独占锁：指该锁一次只能被一个线程所持有。<code>synchronized</code>和<code>ReentrantLock</code>都是独占锁</p>
<p>共享锁：值该锁可被多个线程锁持有</p>
<p><code>ReentrantReadWriteLock</code>其读锁是共享锁，写锁是独占锁</p>
<p>读锁的共享锁保证并发读是高效的，读写、写读、写写的过程是互斥的</p>
<h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><ol>
<li><code>volatile</code>关键字是线程同步的轻量级实现，所以<code>volatile</code>性能肯定比<code>synchronized</code>关键字要好。但是<code>volatile</code>关键字只能用于变量而 <code>synchronized</code>关键字可以修饰方法以及代码块。</li>
<li><code>volatile</code>关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code>关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性。</li>
</ol>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2023/07/16/Kafka/</url>
    <content><![CDATA[<h2 id="kafka介绍"><a href="#kafka介绍" class="headerlink" title="kafka介绍"></a>kafka介绍</h2><p>Apache Kafka 是消息引擎系统，也是一个分布式事件流处理平台，企业利用它可以在A、B两个系统之间传递<strong>消息</strong>，实现松耦合的异步数据传输。总的来说，消息引擎具有两个重要能力：</p>
<ul>
<li>消息引擎传输的对象是<strong>消息</strong></li>
<li>定义了传输消息的<strong>规范</strong></li>
</ul>
<p>消息引擎不在乎A、B两个系统是否相同，它可以在不同系统间传递消息，因此消息的通用格式以及如何传输消息至关重要。kafka的消息格式化使用的是二进制字节序列，消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。kafka支持两种常用的消息引擎模型：</p>
<ul>
<li>点对点模型：也叫消息队列模型，消息只能由A系统发出，由B系统接收，其他模型无权生产与消费消息，简单来说是一对一的模型。</li>
<li>发布 &#x2F; 订阅模型：有一个topic的概念，可以有多个生产者向topic中生产消息，同时允许多个消费者订阅topic进行消费，简单来说就是一种<strong>多对多</strong>的模型。</li>
</ul>
<p>向目标topic发送消息的客户端被称为生产者，生产者源源不断的向<strong>一个或多个</strong>主题发送消息，而订阅这些topic的客户端被称为消费者，消费者同样订阅<strong>一个或多个</strong>topic。生产者和消费者统称为<strong>客户端</strong>，客户端可以运行多个实例，这些实例不停地进行生产和消费行为。</p>
<p>Kafka 的服务器端由被称为 Broker 的服务进程构成，即<strong>一个 Kafka 集群由多个 Broker 组成</strong>，Broker 负责接收和处理客户端发送过来的请求，以及对<strong>消息进行持久化</strong>。虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果<strong>集群</strong>中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。这就是 Kafka 提供高可用的手段之一。</p>
<p>总的来说，Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因为只能追加写入，故避免了缓慢的随机 I&#x2F;O 操作，改为性能较好的<strong>顺序 I&#x2F;O 写</strong>操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。因此kafka通过日志段（Log Segment）机制来定期地删除消息以回收磁盘。在 Kafka 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p>
<p>每个消费者在消费消息的过程使用消费者位移（Consumer Offset）字段记录它当前消费到了分区的哪个位置，消费者位移可能是随时变化的，每个消费者有着自己的消费者位移。</p>
<ul>
<li>消息：Record。Kafka 是消息引擎，这里的消息就是指 Kafka 处理的主要对象。</li>
<li>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li>
<li>分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区，一个分区通常只有一个消费者消费。Kafka 中的分区遍布所有 broker 中，因此<strong>每个 broker 都有可能是某个分区的 leader</strong>，也就是说所有 broker 都有可能对外提供服务，这点和 MySQL 的主从架构有所区别。</li>
<li>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li>
<li>副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。<strong>副本是在分区层级下</strong>的，即<strong>每个分区可配置多个副本</strong>实现高可用。</li>
<li>生产者：Producer。向主题发布新消息的应用程序。</li>
<li>消费者：Consumer。从主题订阅新消息的应用程序。</li>
<li>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。</li>
<li>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li>
<li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li>
</ul>
<img src="/2023/07/16/Kafka/image-20230712110937524.png" class="" title="image-20230712110937524">

<h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><p>为了实现高可用目标，kafka还会对消息进行备份，这些备份的数据在kafka中叫做<strong>副本</strong>。副本的数量可以配置，这些副本保存着相同的数据，但却有不同的角色和作用。Kafka 定义了两类副本：</p>
<ul>
<li>领导者副本（Leader Replica）：领导者副本对客户端<strong>提供服务</strong>。</li>
<li>追随者副本（Follower Replica）：<strong>不对外提供服务</strong>，只是被动的追随领导者副本。</li>
</ul>
<p>Kafka所有的读写请求都必须发送到领导者副本所在的broker进行处理，追随者副本不处理请求，它仅仅是从领导者副本中<strong>异步</strong>拉取消息并写入到自己的提交日志中。与此同时如果领导者副本挂掉，基于zookeeper的监听功能，Kafka将立即开启新一轮的领导者副本选举，从追随者副本中选取一个作为新的领导者，老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。<strong>副本机制保证了消息的持久化</strong>。为了<strong>保证领导者副本保存的内容不会爆满</strong>，kafka对每个topic划分为多个分区，每个分区是一组有序地消息日志。生产者生产的消息只会被发送到同一topic下的某一个分区中，kafka的分区编号从0开始。</p>
<p><strong>副本是在分区这个级别下定义</strong>的，副本的本质就是一个只可以追加写的提交日志。每个分区可以配置n个副本，其中领导者副本只能有1个，其余都是追随者副本。副本分散部署在不同的broker上，每台broker上都可能存在各个主题下不同分区的副本，从而保证某些broker挂掉后Kafka仍然可以对外提供服务。生产者向分区写入消息，每条消息在分区内由一个偏移量（offset）来表示其位置，其中偏移量编号从0开始，一旦消息被成功写入到一个分区上，它的位移值就是固定的了。</p>
<img src="/2023/07/16/Kafka/image-20231009204444418.png" class="" title="image-20231009204444418">

<p>对于客户端来说，追随者副本没有任何作用，这样设计有两个好处：</p>
<ol>
<li>不同副本没有主从延迟的概念，<strong>写完就立马可读</strong>。如果允许追随者副本对外提供服务，由于副本同步是异步的，因此有可能出现追随者副本还没有从领导者副本那里拉取到最新的消息，从而使得客户端看不到最新写入的消息。</li>
<li>消费者读时的密等性。消费者同时从不同追随者副本读取消息时，由于异步读取的滞后性，可能会出现读的结果不一致。但是如果所有请求都是由leader副本负责，那么很容易实现单调读一致性。</li>
</ol>
<p>Kafka引入了In-sync Replicas（ISR）来指出哪些副本是与 Leader 副本同步的，Leader 副本天然就在 ISR 中。也就是说，ISR 不只是追随者副本集合，它必然包括 Leader 副本，它是<strong>动态变化</strong>的。甚至在某些情况下，ISR 只有 Leader 这一个副本。评判 ISR 的标准就是 Broker 端参数<code>replica.lag.time.max.ms</code>的参数值控制的。这个参数的含义是 Follower 副本能够落后 Leader 副本的最长时间间隔。这就是说，只要一个 Follower 副本落后 Leader 副本的时间不连续超过这个参数值，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p>
<h4 id="副本选举"><a href="#副本选举" class="headerlink" title="副本选举"></a>副本选举</h4><p>如果 ISR 为空了，说明 Leader 副本也“挂掉”了，此时 Kafka 需要重新选举一个新的 Leader。可是那些不在ISR的副本又和原来的leader副本差距过大，选举这些副本又称为unclean 领导者选举。此时可以通过broker端参数<code>unclean.leader.election.enable</code>控制是否开启unclean 领导者选举，通常<strong>不建议开启</strong>，这个参数是否开启应该由业务来决定：</p>
<ul>
<li>开启这个参数可能会造成消息丢失，但是不至于停止对外提供服务。</li>
<li>关闭参数保证了消息不会丢失，但牺牲了高可用性。</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="消息分区机制"><a href="#消息分区机制" class="headerlink" title="消息分区机制"></a>消息分区机制</h3><p>kafka的主题是承载消息的逻辑容器，在每个主题下还有很多个分区，消息最终保存在不同的分区下，主题下的消息只会保存在一个分区中，而不会在多个分区中保存多份。分区的目的就是为了负载均衡、实现系统的高伸缩性，不同的分区可以放在不同的机器上，数据的读写操作针对分区进行，即使某一分区挂掉也不影响其他分区继续提供服务。</p>
<p><strong>分区策略可以决定消费者将消息发送到哪个分区。</strong>kafka提供多种分区策略，同时支持自定义分区策略，只需配置生产端的参数<code>partitioner.class</code>以及实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口。</p>
<h4 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h4><p>也就是顺序分配，即消息按照分区挨个发送。</p>
<img src="/2023/07/16/Kafka/image-20230712113230478.png" class="" title="image-20230712113230478">

<p>轮询策略是 Kafka Java 生产者 API 默认提供的分区策略。轮询策略有非常<strong>优秀的负载均衡表现</strong>，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是最常用的分区策略之一。</p>
<h4 id="随机策略"><a href="#随机策略" class="headerlink" title="随机策略"></a>随机策略</h4><p>随机的将消息发送到某一分区。本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要<strong>逊于轮询策略</strong>，所以如果追求数据的均匀分布，还是使用轮询策略比较好。</p>
<h4 id="按消息键保存策略"><a href="#按消息键保存策略" class="headerlink" title="按消息键保存策略"></a>按消息键保存策略</h4><p>Kafka 允许为每条消息定义消息键，简称为 Key。Key可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略。</p>
<p>如果指定了 Key，那么kafka默认实现按消息键保序策略；如果没有指定 Key，则使用轮询策略。</p>
<h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3><p>压缩秉承了时间换空间的经典思想，指的是用少量的cpu时间去换磁盘或网络传输量。因此启用压缩的条件就是：</p>
<ul>
<li>Producer 程序运行机器上的 CPU 资源要很充足。</li>
<li>网络带宽资源实在有限。</li>
</ul>
<p>kafka的消息包含两层：消息集合以及消息。一个消息集合包含若干条日志项，<strong>日志项是真正封存消息的地方</strong>，kafka底层的消息日志由若干消息集合组成，它通常不会操作具体的某条消息，总是在消息集合层面进行写入操作。</p>
<p>在kafka中，消息压缩可能发生在两个地方：生产者端和broker端。</p>
<p>生产者端设置了消息压缩格式后，任何消息集合都会经过压缩后发送给broker，可以很好的节省网络贷款。通常情况下，broker只会原封不动的接收消息，除了以下条件：</p>
<ul>
<li>broker端<strong>指定了和生产者端不同的压缩算法</strong>：此时只能解压缩后再次压缩。</li>
<li>broker发生了<strong>消息格式转换</strong>。为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。</li>
</ul>
<p>多数情况下压缩发生在生产端，压缩后的消息发送到broker之后保存下来，当消费者请求这些消息时，broker会把消息发送出去，当消息到达消费端时自行解压缩还原成原来的消息。Kafka 会将启用了哪种压缩算法<strong>封装</strong>进消息集合中，这样当 Consumer 读取到消息集合时，它自然就知道了这些消息使用的是哪种压缩算法。</p>
<h3 id="Kafka消息交付可靠性保证"><a href="#Kafka消息交付可靠性保证" class="headerlink" title="Kafka消息交付可靠性保证"></a>Kafka消息交付可靠性保证</h3><h4 id="消息无丢失的保证"><a href="#消息无丢失的保证" class="headerlink" title="消息无丢失的保证"></a>消息无丢失的保证</h4><p>Kafka只对<strong>已提交</strong>的消息做<strong>有限度</strong>的持久化保存。</p>
<ul>
<li>已提交的消息：当Kafka的<strong>若干个broker</strong>接收到消息并写入日志文件中，会返回一个成功消息给生产者，此时Kafka认为消息已经成功提交。若干个取决于客户端的配置，可以是一个也可以是多个。</li>
<li>有限度：Kafka不丢失消息的前提是保存消息的多个broker<strong>最少要有一个</strong>存活，只有这样，Kafka才能保证消息不会丢失。</li>
</ul>
<p>容易丢失消息的场景：</p>
<ol>
<li>客户端发送消息是异步的，在没有成功接收到返回值时，Kafka不认为这个消息是成功提交的，因此通常用<code>producer.send(msg, callback)</code>来进行调用，回调函数可以告诉客户端消息是否成功发送到broker。</li>
<li>消费者要维持先消费消息，再移动offset的顺序进行操作，防止offset偏离，这样做可以最大程度保证消息不丢失，但是可能出现消费端重复消费的问题。</li>
<li>如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移。</li>
</ol>
<h4 id="消息交付可靠性"><a href="#消息交付可靠性" class="headerlink" title="消息交付可靠性"></a>消息交付可靠性</h4><p>Kafka对生产者和消费者要消费的消息具有三种承诺能力：</p>
<ul>
<li>最多一次：broker最多发送一次消息，消息可能会丢失，但绝不会重复；</li>
<li>最少一次：broker可以发送多次消息，消息可能会重复，但绝不会丢失；</li>
<li>精确一次：消息精准发布，不会丢失也不会重复。</li>
</ul>
<p>Kafka默认使用第二种策略，若客户端没有收到broker的成功消息，便会进行重试操作。此时如果禁用掉重试，就变成了第一种策略，这个时候消息可能会重复，但性能是最高的。Kafka的精确一次策略通过幂等性和事务实现。</p>
<h5 id="幂等性生产者"><a href="#幂等性生产者" class="headerlink" title="幂等性生产者"></a>幂等性生产者</h5><blockquote>
<p>“幂等”这个词原是数学领域中的概念，指的是某些操作或函数能够被执行多次，但每次得到的结果都是不变的。</p>
<p>幂等性的好处在于可以安全的重复这些操作，不会对系统造成任何改变。</p>
</blockquote>
<p>Kafka的默认生产者不是幂等性的，要启用幂等性功能，只需设置一个参数即可: <code>props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG， true)</code>。开启幂等性服务后，broker使用空间换时间思路，对每条消息额外保存一些字段，通过这些字段进行去重操作。</p>
<p>幂等性生产者<strong>只能保障单一分区</strong>上的要求，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。其次，它只能实现<strong>单会话上</strong>的幂等性，不能实现跨会话的幂等性。当重启了 Producer 进程之后，这种幂等性保证就丧失了。</p>
<p>具体实现原理是 broker 为每个生产者分配一个PID来标识不同的生产者，topic 的<strong>每个分区</strong>会维护一个单调递增的消息 id ，生产者重试的时候拼接 PID 判断消息 id是否重复。这意味着幂等性只能在同一生产者且同一分区内。除此之外幂等性生产者只能够识别并忽略由于重试机制导致的消息重复，并不处理由于<strong>独立调用导致的消息重复</strong>。</p>
<h5 id="事务型生产者"><a href="#事务型生产者" class="headerlink" title="事务型生产者"></a>事务型生产者</h5><p>事务型 Producer 能够保障原子地将消息发送到不同分区中，这批消息要么全部成功，要么全部失败，同时不惧 Producer 进程的重启。</p>
<p>开启事务型生产者需要两个步骤：</p>
<ol>
<li>开启 enable.idempotence &#x3D; true</li>
<li>设置 Producer 端参数 transactional. id</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            producer.beginTransaction();</span><br><span class="line">            producer.send(record1);</span><br><span class="line">            producer.send(record2);</span><br><span class="line">            producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">            producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务型 Producer 的显著特点是调用了一些事务 API，如 initTransaction、beginTransaction、commitTransaction 和 abortTransaction，它们分别对应事务的初始化、事务开始、事务提交以及事务终止。</p>
<p>事务执行一半中止，执行失败的消息也会被Kafka写入到底层的日志中，也就是说消费者仍然可以看得到这些消息，不过可以通过 isolation.level 参数控制这个行为，共有两个取值：</p>
<ol>
<li>read_uncommitted：这是默认值，表明 Consumer 能够读取到 Kafka 写入的任何消息，不论事务型 Producer 提交事务还是终止事务，其写入的消息都可以读取。</li>
<li>read_committed：表明 Consumer 只会读取 Producer 成功提交事务写入的消息（包括非事务的 Producer 的所有提交消息）。</li>
</ol>
<p><strong>事务型生产者的性能更差，要根据实际生产环境特点去选择使用。</strong></p>
<h3 id="Kafka拦截器"><a href="#Kafka拦截器" class="headerlink" title="Kafka拦截器"></a>Kafka拦截器</h3><p>拦截器的基本思想就是在应用程序不修改逻辑的情况下，动态的实现一组<strong>可插拔的事件处理逻辑链</strong>，它可以在主业务操作的前后多个时间点插入处理对应的拦截逻辑。</p>
<img src="/2023/07/16/Kafka/image-20230730220615172.png" class="" title="Kafka-Interceptor">

<p><strong>Kafka拦截器分为生产者拦截器和消费者拦截器</strong>。生产者拦截器允许你在消息发送前以及提交消息后进行拦截处理；消费者拦截器允许你在消息消费前以及提交位移后编写拦截逻辑。这些拦截器允许组成链式形式，按照添加链的先后顺序依次执行。</p>
<p>生产者拦截器需要实现<code>org.apache.kafka.clients.producer.ProducerInterceptor</code> 接口。该接口是 Kafka 提供的，里面有两个核心的方法。</p>
<ul>
<li>onSend：该方法会在消息发送之前被调用。</li>
<li>onAcknowledgement：该方法会在消息成功提交或发送失败之后被调用。onAcknowledgement 的调用要早于 callback 的调用。值得注意的是，这个方法和 onSend <strong>不是在同一个线程中</strong>被调用的。这个方法处在 Producer 发送的主路径中，因此避免放一些太重的逻辑，否则会导致 Producer TPS 直线下降。</li>
</ul>
<p>消费者拦截器要实现<code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>接口，这里面也有两个核心方法。</p>
<ul>
<li>onConsume：该方法在消息返回给 Consumer 程序之前调用。也就是说在开始正式处理消息之前，拦截器会先拦一道，搞一些事情，之后再返回给消费者。</li>
<li>onCommit：Consumer 在提交位移之后调用该方法。通常可以在该方法中做一些记账类的动作，比如打日志等。</li>
</ul>
<h3 id="Kafka的TCP连接"><a href="#Kafka的TCP连接" class="headerlink" title="Kafka的TCP连接"></a>Kafka的TCP连接</h3><p>Kafka的生产者、消费者、broker所有通信都是基于TCP协议的。</p>
<blockquote>
<p>TCP具有多路复用请求能力，即 multiplexing request，是指将两个或多个数据流合并到底层单一物理连接中的过程。TCP 的多路复用请求会在一条物理连接上创建若干个虚拟连接，每个虚拟连接负责流转各自对应的数据流。其实严格来说，<em><strong>TCP 并不能多路复用，它只是提供可靠的消息交付语义保证</strong></em>，比如自动重传丢失的报文。</p>
</blockquote>
<h4 id="连接创建时机"><a href="#连接创建时机" class="headerlink" title="连接创建时机"></a>连接创建时机</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构建参数对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建生产者</span></span><br><span class="line">    KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(config);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      	<span class="comment">// 3. 发送数据</span></span><br><span class="line">        producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;yph&quot;</span>, <span class="string">&quot;test&quot;</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 4. 关闭连接</span></span><br><span class="line">    producer.close();</span><br></pre></td></tr></table></figure>

<h5 id="生产者创建时机"><a href="#生产者创建时机" class="headerlink" title="生产者创建时机"></a>生产者创建时机</h5><ul>
<li><p>在创建KafkaProducer实例时，生产者会在后台创建一个名为sender的线程，该线程会负责初始化生产者和broker的连接，它会连接 bootstrap.servers 参数指定的所有 Broker，因此生产环境通常指定三四个就可以了，生产者连接到集群中的一台broker，会自动拿到集群的元数据即所有的集群数据。生产者拉取元数据信息有两种方式：</p>
<ul>
<li>Producer 通过 metadata.max.age.ms 参数定期地去更新元数据信息。</li>
<li>Producer 给一个不存在的 topic 发送消息时，Broker会告诉他不存在，此时生产者会去请求最新的集群元数据信息。</li>
</ul>
</li>
<li><p>当生产者拿到所有的集群数据后，会依次与没有建立连接的broker进行TCP连接。</p>
</li>
<li><p>同时当生产者向目标发送消息时，倘若发现没有与之建立连接，这时也会进行TCP连接操作。</p>
</li>
</ul>
<h5 id="消费者创建时机"><a href="#消费者创建时机" class="headerlink" title="消费者创建时机"></a>消费者创建时机</h5><p>创建KafkaConsumer实例时不会创建任何 TCP 连接，TCP 连接是在调用 KafkaConsumer.poll 方法时被创建的，内部有三个时机：</p>
<ul>
<li><p>发起 FindCoordinator 请求时。</p>
<p>当消费者程序首次启动调用poll方法时，消费者会建立一个连接去请求Broker哪个是协调者。</p>
</li>
<li><p>连接协调者时。</p>
<p>当Broker告诉消费者真正的协调者后，消费者会与该协调者建立连接。只有成功连入协调者，协调者才能开启正常的组协调操作，比如加入组、等待组分配方案、心跳请求处理、位移获取、位移提交等。</p>
</li>
<li><p>消费数据时。</p>
<p>消费者会为每个要消费的分区创建与该分区领导者副本所在 Broker 连接的 TCP。</p>
</li>
</ul>
<h4 id="连接关闭时机"><a href="#连接关闭时机" class="headerlink" title="连接关闭时机"></a>连接关闭时机</h4><h5 id="生产者关闭时机"><a href="#生产者关闭时机" class="headerlink" title="生产者关闭时机"></a>生产者关闭时机</h5><ul>
<li><p>用户主动关闭</p>
<p>可以使用close方法，也可以直接杀掉进程。</p>
</li>
<li><p>Kafka自动关闭</p>
<p>Producer 端参数 connections.max.idle.ms 的值决定了无通信时连接的最大存活时间，当超过最大存活时间后仍然没有新的通信，broker会主动关闭TCP连接。</p>
</li>
</ul>
<h5 id="消费者关闭时机"><a href="#消费者关闭时机" class="headerlink" title="消费者关闭时机"></a>消费者关闭时机</h5><p>当第三类 TCP 连接成功创建后，消费者程序就会废弃第一类 TCP 连接，之后在定期请求元数据时，它会改为使用第三类 TCP 连接。也就是说，第一类 TCP 连接会在后台被默默地关闭掉。对一个运行了一段时间的消费者程序来说，只会有后面两类 TCP 连接存在。</p>
<ul>
<li><p>用户主动关闭</p>
<p>手动调用 KafkaConsumer.close() 方法，或者是执行 Kill 命令</p>
</li>
<li><p>Kafka自动关闭</p>
<p>消费者端参数 connection.max.idle.ms 控制，不过消费者程序一般都是使用循环消费消息，一般不会超时关闭。</p>
</li>
</ul>
<h3 id="Kafka请求的处理"><a href="#Kafka请求的处理" class="headerlink" title="Kafka请求的处理"></a>Kafka请求的处理</h3><p>Kafka的客户端和broker端都是通过 ”请求&#x2F;响应“ 的形式进行交互，Kafka自定义了许多请求格式来进行交互，比如PRODUCE请求用于生产消息、FETCH请求用于消费消息、METADATA请求用于获取集群数据元信息。<strong>所有的请求都是通过TCP网络以Socket的形式进行通信</strong>。</p>
<p>当消息到达broker后，Kafka使用Reactor模式处理请求，其处理架构如下图所示。</p>
<blockquote>
<p>Reactor是一种基于事件驱动的架构模式，擅长处理多个客户端并发向服务端发送请求的场景。</p>
</blockquote>
<img src="/2023/07/16/Kafka/image-20231025200256037.png" class="" title="image-20231025200256037">

<p>由上图可以看出，Kafka的Broker有个SocketServer组件，它有对应的Acceptor线程和网络线程池。其中Acceptor线程采用轮询的方式分发客户端发送过来的请求给网络线程池，网络线程池则负责处理接收到的请求。Kafka 提供了 Broker 端参数<code>num.network.threads</code>，用于调整该网络线程池的线程数。其默认值是 3，表示每台 Broker 启动时会创建 3 个网络线程，专门处理客户端发送的请求。</p>
<p>网络线程池中工作线程的处理速度可能跟不上分发线程的派送速度，因此网络线程在这里再次执行了一次异步处理操作。</p>
<img src="/2023/07/16/Kafka/image-20231025201512500.png" class="" title="image-20231025201512500">

<p>所有的网络线程拿到请求后都会把请求放到一个<strong>共享请求队列中</strong>，Broker端的<strong>IO线程池从共享请求队列取出请求执行真正的处理逻辑</strong>，处理完毕后放到相应队列中。Broker 端参数<code>num.io.threads</code>控制了IO线程池中的线程数。目前该参数默认值是 8，表示每台 Broker 启动后自动创建 8 个 IO 线程处理请求。网络线程池的请求响应队列不是共享的，每个网络线程有自己专属的响应队列。这样设计的原因就是Acceptor线程只负责分发请求，不负责向客户端返回响应，每个请求由不同的网络线程自己发送 Response 给客户端，所以这些 Response 也就没必要放在一个公共的地方。</p>
<p>Purgatory 的组件是用来缓存延时请求（Delayed Request）的。所谓延时请求，就是那些一时未满足条件不能立刻处理的请求。比如设置了 acks&#x3D;all 的 PRODUCE 请求，一旦设置了 acks&#x3D;all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中。</p>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制。组内有多个消费者实例，它们具有共同的Group ID，一个组结合起来消费订阅主题下的所有分区，<strong>其中一个分区最多只能被同组内的一个消费者消费，但是可以被其他组的实例消费。</strong>因此一个消费者组的实例数在理想情况下应该等于它所订阅主题的分区总数。</p>
<p>当 Consumer Group 订阅了多个主题后，组内的每个实例<strong>不要求一定要订阅主题的所有分区</strong>，它只会消费部分分区中的消息。Consumer Group <strong>之间彼此独立</strong>，互不影响，它们能够订阅相同的一组主题而互不干涉。如果所有实例都属于同一个 Group，那么它实现的就是消息队列模型；如果所有实例分别属于不同的 Group，那么它实现的就是发布 &#x2F; 订阅模型。</p>
<h4 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h4><p>消费者在消费的过程中需要记录自己的消费位置信息，对于消费者组来说，这些数据以键值对的方式保存，其中键是分区、值是该分区的最新消费位移。这些位置数据存放的具体位置因客户端版本的不同而不同，老版本存放在zookeeper中，当 Consumer 重启后，它能自动从 ZooKeeper 中读取位移数据，从而在上次消费截止的地方继续消费。这种设计使得 Kafka Broker 不需要保存位移数据，减少了 Broker 端需要持有的状态空间，因而有利于实现高伸缩性。但是位移数据需要频繁更新，<strong>大吞吐量的写操作会极大地拖慢 ZooKeeper 集群的性能</strong>，因此新版本的客户端修改了存放地址，把位移信息放在了Kafka 内部主题—__consumer_offsets中。</p>
<p>新版本将consumer的位移数据看作是一条普通的Kafka消息，然后提交到__consumer_offsets主题中，也就是说 _consumer_offsets的主要作用就是用来保存位移信息的。虽说位移主题是一个普通的 Kafka 主题，但它的消息格式却是 Kafka 自定义的，用户不能修改，也就是说不能随意地向这个主题写消息，因为一旦写入的消息不满足 Kafka 规定的格式，那么 Kafka 内部无法成功解析，就会造成 Broker 的崩溃。事实上，Kafka Consumer 有 API 向位移主题写消息。</p>
<p>位移主题的消息格式有三种：</p>
<ol>
<li><strong>普通消息</strong>。由键值对构成，其中位移主题的 Key 中保存 3 部分内容：**&lt;Group ID，主题名，分区号 &gt;**，Value保存具体的消息信息；</li>
<li>用于保存 Consumer Group 信息的消息。它是用来<strong>注册 Consumer Group</strong> 的；</li>
<li>用于删除 Group 过期位移甚至是<strong>删除 Group</strong> 的消息。tombstone 消息，即墓碑消息，也称 delete mark，它的主要特点是它的消息体是 null，即空消息体。一旦某个 Consumer Group 下的所有 Consumer 实例都停止了，而且它们的位移数据都已被删除时，Kafka 会向位移主题的对应分区写入 tombstone 消息，表明要彻底删除这个 Group 的信息。</li>
</ol>
<p>通常来说，当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会<strong>自动</strong>创建位移主题。位移主题就是普通的Kafka主题，它的分区数由Broker端参数<code>offsets.topic.num.partitions</code>控制，副本数由<code>offsets.topic.replication.factor</code>控制。不过也可以在Kafka集群所有消费者实例未启动前使用 Kafka API 创建它，自己创建时可以指定分区数、副本数。</p>
<p>目前Kafka提交位移信息的方式有两种：</p>
<ul>
<li><strong>手动提交位移</strong>。由开发者调用相关API，Kafka 就会向位移主题写入相应的消息；</li>
<li><strong>自动提交位移</strong>。设置<code>enable.auto.commit</code>为true，就能保证消息消费不会丢失，但是丧失了很大的灵活性和可控性，无法把控 Consumer 端的位移管理。只要 Consumer 一直启动着，它就会<strong>无限期</strong>（可能撑爆内存）地向位移主题写入消息。</li>
</ul>
<p>Kafka 使用 <strong>Compact 策略</strong>来删除位移主题中的过期消息，避免该主题无限期膨胀。对于同一个 Key 的两条消息 M1 和 M2，如果 M1 的发送时间早于 M2，那么 M1 就是过期消息。Compact 的过程就是扫描日志的所有消息，剔除那些过期的消息，然后把剩下的消息整理在一起，整理后的结果如下所示。</p>
<img src="/2023/07/16/Kafka/image-20230806230532868.png" class="" title="image-20230806230532868">

<p>Kafka 提供了专门的<strong>后台线程</strong>称为 Log Cleaner定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据。</p>
<h4 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h4><p>消费者需要向Kafka提交自己的位移数据，由于消费者可以消费多个分区的数据，因此位移提交是在分区维度上进行的，即消费者向每个订阅的分区汇报自己的下一个消费位移。有了位移数据，消费者在故障重启后便可以从Kafka得到这些数据，并按照这些数据继续消费，避免从头开始重复消费消息。</p>
<p><strong>一旦向Kafka提交了位移数据，Kafka会认为提交位移前的所有数据都已经消费完毕</strong>，Kafka提供了多种位移提交的方法，从用户的角度来说，位移提交分为自动提交和手动提交；从 Consumer 端的角度来说，位移提交分为同步提交和异步提交。</p>
<ul>
<li>自动提交（默认）：<code>enable.auto.commit = true；auto.commit.interval.ms = 10</code>，每10s自动提交一次位移。Kafka在指定时间调用poll方法时，提交上次poll方法处理过的所有消息，它能保证不出现消息丢失的情况，但是如果发生了rebalance操作，消费者将从上次提交的位移处开始消费，此时会出现<strong>重复消费</strong>。</li>
<li>同步提交：<code>KafkaConsumer#commitSync()</code>，Broker返回结果前，消费者一直被阻塞，会自动重试。</li>
<li>异步提交：<code>KafkaConsumer#commitAsync(callback)</code>：无法代替同步提交，如果提交失败不会重试，通常将同步异步结合使用，保证最终提交成功。</li>
<li>精细化提交：<code>commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt;) 和 commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt;)</code>：可以准确提交多少条数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">                        process(records); <span class="comment">// 处理消息</span></span><br><span class="line">                        commitAysnc(); <span class="comment">// 使用异步提交规避阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            handle(e); <span class="comment">// 处理异常</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                        consumer.commitSync(); <span class="comment">// 最后一次提交使用同步阻塞式提交</span></span><br><span class="line">  	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       consumer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于常规性、阶段性的手动提交，调用 commitAsync() 避免程序阻塞，而在 Consumer 要关闭前，调用 commitSync() 方法执行同步阻塞式的位移提交，以确保 Consumer 关闭前能够保存正确的位移数据。</p>
<h4 id="CommitFailedException异常"><a href="#CommitFailedException异常" class="headerlink" title="CommitFailedException异常"></a>CommitFailedException异常</h4><p>Consumer在提交位移的时候发生了异常，并且该异常Kafka无法通过自动重试解禁，只能中断程序。CommitFailedException 异常通常发生在手动提交位移时，即用户显式调用 KafkaConsumer.commitSync() 方法时，常见的两种场景可能触发此异常：</p>
<ul>
<li>消息处理时间超过了设置的 max.poll.interval.ms 值。解决办法：<ul>
<li>减少单个消息的处理时间</li>
<li>增大消费者最大消费时间，即 max.poll.interval.ms 值</li>
<li>减少每次获取的消息数量，Consumer 端参数 max.poll.records 的值，默认每次消费500条消息</li>
<li>consumer使用多线程来处理消息</li>
</ul>
</li>
<li>Kafka还有一种独立消费者，每个消费者实例之间没有关系，但是也要指定group.id才能提交位移，如果group.id和消费者组相同，那么就会抛出此异常</li>
</ul>
<h4 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h4><p>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。Rebalance 发生时，Group 下<strong>所有</strong>的 Consumer 实例都会在协调者组件的帮助下共同参与，因此在这个过程中所有的实例都不能消费消息（stop the world）。<strong>协调者</strong>在 Kafka 中对应的术语是 Coordinator，它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p>
<p>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，<strong>所有 Broker 都有各自的 Coordinator 组件</strong>，消费者组通过以下算法定位为自己负责的 Coordinator 组件：</p>
<ol>
<li>确定由位移主题的哪个分区来保存该 Group 数据：partitionId&#x3D;Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)；</li>
<li>找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</li>
</ol>
<p>Rebalance的触发条件有三个：</p>
<ol>
<li><strong>组成员数发生变更</strong>。比如有新的 Consumer 实例<strong>加入组或者离开组</strong>，抑或是有 Consumer 实例崩溃被“踢出”组。</li>
<li><strong>订阅主题数发生变更</strong>。若Consumer Group 订阅所有以字母 t 开头、字母 c 结尾的主题，在 Consumer Group 的运行过程中，新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li>
<li><strong>订阅主题的分区数发生变更</strong>。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。</li>
</ol>
<h5 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h5><p>在 Rebalance 过程中，所有 Consumer 实例都会<strong>停止消费</strong>，等待 Rebalance 完成，其次目前 Rebalance 的设计是所有 Consumer 实例共同参与，<strong>不考虑局部性原理</strong>，全部重新分配所有分区。</p>
<p>消费端有三个参数可能影响到Rebalance触发，实际上多数Rebalance发生都是这些原因，也是实际生产环境应该经历避免的。：</p>
<ol>
<li>消费端有<code>session.timeout.ms</code>参数来控制心跳时间，超出时间没有进行心跳连接，Coordinator 就会认为该实例下线，进而进行Rebalance，推荐设置为6s</li>
<li>Consumer 还提供了一个允许控制发送心跳请求频率的参数，就是<code>heartbeat.interval.ms</code>。这个值设置得越小，Consumer 实例发送心跳请求的频率就越高。频繁地发送心跳请求会额外消耗带宽资源，但<strong>好处是能够更加快速地知晓当前是否开启 Rebalance</strong>，因为，目前 Coordinator 通知各个 Consumer 实例开启 Rebalance 的方法，就是将 REBALANCE_NEEDED 标志封装进心跳请求的响应体中，推荐设置为2s，也就是判断下线应该至少经历三次心跳无反应。</li>
<li>Consumer 端<code>max.poll.interval.ms</code>参数用于控制 Consumer 实际消费能力对 Rebalance 的影响。它限定了 Consumer 端应用程序两次调用 poll 方法的最大时间间隔，表示 Consumer 程序如果在指定时间内无法消费完 poll 方法返回的消息，那么 Consumer 会主动发起“离开组”的请求，Coordinator 也会开启新一轮 Rebalance。推荐根据下游消费逻辑消耗时间设置此值。</li>
</ol>
<p>Kafka通过心跳机制通知Consumer进行Rebalance操作，每个Consumer除了工作主线程外还会有一个心跳线程，当协调者决定要开启Rebalance操作时，它会在心跳响应中带上<strong>REBALANCE_IN_PROGRESS</strong>参数，Consumer发现心跳响应中有REBALANCE_IN_PROGRESS就知道要开始Rebalance操作了。</p>
<h5 id="消费者组状态机"><a href="#消费者组状态机" class="headerlink" title="消费者组状态机"></a>消费者组状态机</h5><p>Rebalance操作开始的时候，协调者使用状态机来完成消费者状态的扭转，Kafka给消费者组定义了五种状态：</p>
<ul>
<li>Empty：组内没有任何成员，但是消费者组可能存在已提交的位移数据，并且位移还未过期。</li>
<li>Dead：组内没有任何成员，但是组的元数据信息在协调者端已经被删除。</li>
<li>PreparingRebalance：准备开启重平衡，此时组内所有消费者都有重新请求加入消费者组。</li>
<li>CompletingRebalance：组内消费者都已经加入，成员在等待分配消费方案。</li>
<li>Stable：消费者组的稳定状态，重平衡已经完成，可以正常消费数据。</li>
</ul>
<img src="/2023/07/16/Kafka/image-20231026103854842.png" class="" title="image-20231026103854842">

<p>消费者组最开始处于Empty状态，当准备开始重平衡后它会进入PreparingRebalance等待所有消费者实例加入，之后变更到CompletingRebalance状态等待分配方案，最后流转到Stable状态完成重平衡。</p>
<p>当有新成员加入或已有成员退出时，消费者组的状态从Stable直接跳到PreparingRebalance状态，此时，所有现存成员就必须重新申请加入组。当所有成员都退出组后，消费者组状态变更为Empty。Kafka定期自动删除过期位移的条件就是，组要处于Empty状态。</p>
<h5 id="消费者端重平衡流程"><a href="#消费者端重平衡流程" class="headerlink" title="消费者端重平衡流程"></a>消费者端重平衡流程</h5><p>从消费者视角来看，重平衡操作有两个流程分别是加入组和等待领导消费者分配消费方案，对应的两种请求分别是：<strong>JoinGroup请求和SyncGroup请求</strong>。</p>
<p>当消费者加入组内时会首先向协调者发送JoinGroup请求，在该请求中每个消费者都要汇报自己订阅的主题，因此协调者可以拿到组内所有的订阅主题信息。通常情况下第一个发送JoinGroup请求的消费者会被协调者定位Leader Consumer，<strong>领导者消费者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案</strong>。</p>
<img src="/2023/07/16/Kafka/image-20231026120119093.png" class="" title="image-20231026120119093">

<p>选出领导者后，协调者会把组内消费者的订阅信息以JoinGroup请求响应体的方式发送给领导者，领导者根据这些信息制定出消费计划，接着所有消费者都会给协调者发送SyncGroup请求。不过领导者的请求包含了所有消费者的消费计划，而<strong>其他成员的请求中为空</strong>，最后协调者把领导者上报的消费信息以SyncGroup响应的方式发送给每个消费者。<strong>SyncGroup请求的目的就是让所有成员知道自己的消费信息。</strong></p>
<img src="/2023/07/16/Kafka/image-20231026120133318.png" class="" title="image-20231026120133318">

<h5 id="Broker端重平衡流程"><a href="#Broker端重平衡流程" class="headerlink" title="Broker端重平衡流程"></a>Broker端重平衡流程</h5><p>从服务端来看，消费者的变化有四种情况：</p>
<ol>
<li><p>稳定的组中有新消费者加入，协调者收到新的加入请求后，会在心跳反应中通知其余消费者开始rebalance</p>
<img src="/2023/07/16/Kafka/image-20231030205933546.png" class="" title="image-20231030205933546">
</li>
<li><p>稳定的组中有消费者主动离开，协调者收到LeaveGroup请求后，依然会以心跳响应的方式通知其他成员。</p>
<img src="/2023/07/16/Kafka/image-20231030210135366.png" class="" title="image-20231030210135366">
</li>
<li><p>稳定的组中有消费者崩溃离开，崩溃离开是被动行为，在指定心跳时间内没有回应就会通知其余成员。</p>
<img src="/2023/07/16/Kafka/image-20231030210303706.png" class="" title="image-20231030210303706">
</li>
<li><p>重平衡时协调者会对组内成员提交位移指定一个时间段，每个成员都要在指定时间提交自己的位移情况，然后再开始正常的JoinGroup&#x2F;SyncGroup请求发送。</p>
<img src="/2023/07/16/Kafka/image-20231030211111244.png" class="" title="image-20231030211111244"></li>
</ol>
<h3 id="消费进度监控"><a href="#消费进度监控" class="headerlink" title="消费进度监控"></a>消费进度监控</h3><p>消费者组滞后程度称为Consumer Lag，即消费消息与生产消息的差值。对消费者而言，Lag 应该算是最重要的监控指标了。它直接反映了一个消费者的运行情况。一个正常工作的消费者，它的 Lag 值应该很小，甚至是接近于 0 的，这表示该消费者能够及时地消费生产者生产出来的消息，滞后程度很小。反之，如果一个消费者 Lag 值很大，通常就表明它无法跟上生产者的速度，最终 Lag 会越来越大，从而拖慢下游消息的处理速度。</p>
<p>Kafka监控Lag是在分区层面上的，如果需要topic层面的Lag，需要手动把所有分区进行汇总，得到总的Lag值。监控这些重要指标有三种方法：</p>
<ol>
<li>使用 Kafka 自带的命令行工具 kafka-consumer-groups 脚本。</li>
<li>使用 Kafka Java Consumer API 编程。</li>
<li>使用 Kafka 自带的 JMX 监控指标。</li>
</ol>
<h4 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h4><p>脚本位于bin目录下，使用方式如下</p>
<p><code>bin/kafka-consumer-groups.sh --bootstrap-server &lt;Kafka broker连接信息&gt; --describe --group &lt;group名称&gt;</code></p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;TopicPartition, Long&gt; <span class="title function_">lagOf</span><span class="params">(String groupID, String bootstrapServers)</span> <span class="keyword">throws</span> TimeoutException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">AdminClient</span> <span class="variable">client</span> <span class="operator">=</span> AdminClient.create(props)) &#123;</span><br><span class="line">            <span class="comment">// 获取给定groupID的最新消费位移</span></span><br><span class="line">            <span class="type">ListConsumerGroupOffsetsResult</span> <span class="variable">result</span> <span class="operator">=</span> client.listConsumerGroupOffsets(groupID);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Map&lt;TopicPartition, OffsetAndMetadata&gt; consumedOffsets = result.partitionsToOffsetAndMetadata().get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>); <span class="comment">// 禁止自动提交位移</span></span><br><span class="line">                props.put(ConsumerConfig.GROUP_ID_CONFIG, groupID);</span><br><span class="line">                props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">                props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">                <span class="keyword">try</span> (<span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props)) &#123;</span><br><span class="line">                    <span class="comment">// 获取订阅分区的最新消息位移</span></span><br><span class="line">                    Map&lt;TopicPartition, Long&gt; endOffsets = consumer.endOffsets(consumedOffsets.keySet());</span><br><span class="line">                    <span class="comment">// 减法计算Lag值</span></span><br><span class="line">                    <span class="keyword">return</span> endOffsets.entrySet().stream().collect(Collectors.toMap(entry -&gt; entry.getKey(),</span><br><span class="line">                            entry -&gt; entry.getValue() - consumedOffsets.get(entry.getKey()).offset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// 处理中断异常</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 处理ExecutionException</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>(<span class="string">&quot;Timed out when getting lag for consumer group &quot;</span> + groupID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="JMX-监控指标"><a href="#JMX-监控指标" class="headerlink" title="JMX 监控指标"></a>JMX 监控指标</h4><p>Kafka 消费者提供了一个名为 kafka.consumer:type&#x3D;consumer-fetch-manager-metrics,client-id&#x3D;“{client-id}”的 JMX 指标，它可以方便的集成到其他监控框架中，里面有两组属性比较重要：</p>
<ol>
<li>records-lag-max：消费延迟的最大值。</li>
<li>records-lead-min：Lead 值是指消费者最新消费消息的位移与分区当前第一条消息位移的差值。Kafka的消息默认保存一周，如果接近0就表示消费者消费的数据即将被Kafka删除，消费端<strong>即将要丢失消息</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth</title>
    <url>/2023/09/02/OAuth/</url>
    <content><![CDATA[<p>简单来说，OAuth2.0是一种<strong>授权协议</strong>，它通过颁发访问令牌的机制而不是使用用户名和密码来请求交互，保证第三方应用只有在<strong>成功获取授权之后</strong>才可以访问授权者的数据。通过这套协议，用户仅仅通过授权操作就可以免去重复注册的流程，是目前web上重要的安全手段。</p>
<p>OAuth2.0提供了四种许可类型：</p>
<ul>
<li><strong>授权码许可（Authorization Code）</strong></li>
<li>隐式许可（Implicit）</li>
<li>客户端凭据许可（Client Credentials）</li>
<li>资源拥有者凭据许可（Resource Owner Password Credentials）</li>
</ul>
<h1 id="OAuth2-0的基本流程"><a href="#OAuth2-0的基本流程" class="headerlink" title="OAuth2.0的基本流程"></a>OAuth2.0的基本流程</h1><p>OAuth2.0里有4种角色，分别是资源所有者、三方软件、授权服务和受保护资源，授权码许可的流程如下。</p>
<img src="/2023/09/02/OAuth/Oauth2.0.png" class="" title="Oauth">

<h2 id="重定向的必要性"><a href="#重定向的必要性" class="headerlink" title="重定向的必要性"></a>重定向的必要性</h2><p>如果没有重定向，只有纯粹后端逻辑的交互，那么用户在第三方平台跳转到授权服务后，用户与三方平台的连接关系就中断了，相当于用户一直停留在授权服务的页面。</p>
<h2 id="授权码的必要性"><a href="#授权码的必要性" class="headerlink" title="授权码的必要性"></a>授权码的必要性</h2><p>用户在不同平台千万另一个平台时，由于域名的不同，需要使用重定向功能讲用户引导过去。与此同时由于域名的不同，cookie这些保存登陆态的信息无法携带跳转，即使用户在一个平台授权登录后其他平台仍然无法感知，因此需要携带一些信息告诉其他平台，用户已经授权过了。为了保证信息的安全性，携带的信息不能是用户密钥，于是使用了授权码机制（一种临时的、间接的凭证）。</p>
<p>第三方软件最终是需要拿到安全保密性要求极高的访问令牌才能操作用户数据，而两次重定向操作是暴露在浏览器上的，有了授权码的参与，保证了访问令牌只在后端服务之间传输。 使用授权码的目的之一，就是把浏览器和第三方软件的信息做一个隔离，确保浏览器看不到第三方软件最重要的访问令牌 access_token 的值</p>
<h2 id="三方软件的流程"><a href="#三方软件的流程" class="headerlink" title="三方软件的流程"></a>三方软件的流程</h2><ol>
<li><p>注册信息。三方软件首先需要去授权平台申请app_id、app_serect、回调地址、申请权限等信息。</p>
</li>
<li><p>引导授权。最终目的是为了获取access_token.</p>
</li>
<li><p>使用访问令牌。拿到令牌就可以去操作用户授权的数据，官方规范列出了三种使用令牌的方式：</p>
<ul>
<li><p><strong>Form-Encoded Body Parameter</strong>（表单参数），安全性最高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /resource HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token=b1a64d5c-5e0c-4a70-<span class="number">9711</span>-7af6568a61fb</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>URI Query Parameter（URI 查询参数），路径参数需要编码、并且容易泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /resource?access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Authorization Request Header Field（授权请求头部字段），需要代码额外处理Authorization头部信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /resource HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer b1a64d5c-5e0c-4a70-<span class="number">9711</span>-7af6568a61fb</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用刷新令牌。<strong>刷新令牌是一次性的，使用之后就会失效</strong>。</p>
</li>
<li><p>三方软件请求不同的受保护资源服务，会由API GATEWAY 跳转到不同的受保护资源服务，省去每个资源服务都需要权限校验的操作。</p>
<img src="/2023/09/02/OAuth/image-20230903104511589.png" class="" title="image-20230903104511589"></li>
</ol>
<h2 id="授权服务的流程"><a href="#授权服务的流程" class="headerlink" title="授权服务的流程"></a>授权服务的流程</h2><p>授权服务就是负责颁发令牌的服务，OAuth2.0的核心就是授权服务，而授权服务的核心是令牌。</p>
<h3 id="获取授权码的步骤"><a href="#获取授权码的步骤" class="headerlink" title="获取授权码的步骤"></a>获取授权码的步骤</h3><ol>
<li>三方软件首先要去授权服务进行注册，然后授权服务会给三方软件一个app_id和app_secret等信息，方便以后授权时的身份校验，同时注册时还会告诉授权服务以后请求受保护资源的访问范围，也就是scope。</li>
<li>三方软件以后请求授权时，授权服务会先去验证三方软件的基本信息，比如是否注册过、回调地址是否合法。因为这个过程由浏览器的web端重定向操作，每一步都有可被冒充的风险，因此需要对三方软件进行合法性校验。</li>
<li>当验证通过并且用户授权后，授权服务会对用户授权范围和三方软件注册时指定的scope进行比对，防止三方软件申请scope范围外的权限（最小权限法则）。</li>
<li>生成授权码code并将code和app_id、user、申请的scope关联，与此同时给code设置一个过期时间</li>
<li>重定向到三方软件，并把code返回给软件。注意code只是换取access_token的临时凭证，无法代替access_token。</li>
</ol>
<h3 id="获取access-token的步骤"><a href="#获取access-token的步骤" class="headerlink" title="获取access_token的步骤"></a>获取access_token的步骤</h3><ol>
<li>验证三方软件是否存在，app_id和app_secret是否正确。</li>
<li>验证code是否正确，<strong>code应该使用一次就失效，防止被冒用</strong>。</li>
<li>生成access_token，将access_token与app_id、user关联，设置access_token过期时间并将之与scope关联。</li>
</ol>
<h3 id="刷新access-token"><a href="#刷新access-token" class="headerlink" title="刷新access_token"></a>刷新access_token</h3><p>当access_token过期后，为了防止频繁需要用户授权，OAuth2.0引入了刷新令牌，规定用户在一定时间内无需手动授权就可以继续使用三方软件。</p>
<ol>
<li>授权服务在颁发access_token的时候会同步颁发一个refresh_token给三方软件，refresh_token的失效时间会比access_token更长。这样当access_token失效时，三方软件就会使用refresh_token请求授权服务。</li>
<li>授权服务收到refresh_token后，会验证token类型、app_id、app_secret是否合法。</li>
<li>重新生成新的access_token和refresh_token并发给三方服务。<strong>一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌</strong>，不过refresh_token过期时间不会重新刷新。</li>
</ol>
<h3 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h3><p>授权服务的核心就是访问令牌，访问令牌没有具体的格式，目前使用最多的就是JWT令牌了。</p>
<blockquote>
<p>JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。</p>
</blockquote>
<p>JWT 结构化体可以分为 HEADER（头部）、PAYLOAD（数据体）和 SIGNATURE（签名）三部分。经过签名之后的 JWT 的整体结构，是被句点符号分割的三段内容，结构为 header.payload.signature 。</p>
<ul>
<li>header：表示装载令牌类型和算法等信息。其中，typ 表示第二部分 PAYLOAD 是 JWT 类型，alg 表示使用 HS256 对称签名的算法。</li>
<li>payload：表示JWT的数据体，可以是一切合法json格式的数据。</li>
<li>signature：表示对 JWT 信息的签名。</li>
</ul>
<img src="/2023/09/02/OAuth/image-20230902214920832.png" class="" title="image-20230902214920832">

<p>优点：</p>
<ol>
<li>用计算代替存储。通过对JWT进行解密就可以拿到json格式的数据，其中可以存放用户授权的范围，省去了调用rpc服务的时间。</li>
<li>签名保障了传输过程的安全性。</li>
</ol>
<p>注意：由于服务器不存储JWT，当用户取消授权时需要同步取消JWT的有效性。这时可以把加密算法缩小到用户级别，保证每个用户的加密密钥都不一样，这样当用户取消授权时只要同步修改加密密钥，即可使JWT失效。</p>
<h1 id="可能存在的安全漏洞"><a href="#可能存在的安全漏洞" class="headerlink" title="可能存在的安全漏洞"></a>可能存在的安全漏洞</h1><p>OAuth2.0作为安全协议，如果使用不当或不遵守规范，很容易产生一些安全漏洞。</p>
<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>恶意软件让浏览器向已完成用户身份认证的网站发起请求，并执行有害的操作，就是跨站请求伪造攻击，攻击过程的本质上就是，软件 A（攻击者）用自己的授权码 codeA 的值，通过 CSRF 攻击，“替换”了软件 B 的授权码的值。</p>
<img src="/2023/09/02/OAuth/image-20230903175033067.png" class="" title="image-20230903175033067">

<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie。</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act&#x3D;xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ul>
<p>解决办法：OAuth 2.0 中建议使用一个随机值 state 参数，当某三方服务请求授权码的时候附带一个自己生成 state 参数值，同时授权服务也要按照规则将这个随机的 state 值跟授权码 code 一起返回给三方服务，当三方服务接收授权码的时候，就要在服务端做一个 state 参数值的比对校验，如果相同就继续流程，否则直接拒绝后续流程。这样就可以避免获取到一个假的 code 进行后续流程。</p>
<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>XSS 攻击的主要手段是将恶意脚本注入到请求的输入中，攻击者可以通过注入的恶意脚本来进行攻击行为，比如搜集数据等。</p>
<p>解决办法：对非法信息做转义过滤，如包含<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>等标签</p>
<h2 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h2><p>水平越权指的是请求到达受保护资源服务时，服务端只做了token校验，没有检查这个请求获取的数据是否归属于当前授权的用户，导致不法者用自己获得的授权来访问受保护资源服务的时候，就有可能获取其他用户的数据。</p>
<p>解决办法：不但检查access_token的合法性，更要检查请求的范围、数据的归属。</p>
<h2 id="授权码失窃"><a href="#授权码失窃" class="headerlink" title="授权码失窃"></a>授权码失窃</h2><img src="/2023/09/02/OAuth/image-20230903220637576.png" class="" title="image-20230903220637576">

<p>问题关键点：</p>
<ul>
<li>授权服务校验code的时候没有对code的归属app做校验。</li>
<li>code使用以后没有及时实效。</li>
<li>回调地址没有做校验。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2022/11/20/Netty/</url>
    <content><![CDATA[<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><h4 id="1-Channel-amp-Buffer"><a href="#1-Channel-amp-Buffer" class="headerlink" title="1. Channel &amp; Buffer"></a>1. Channel &amp; Buffer</h4><p>channel是读写数据的<strong>双向通道</strong>，连接要读取的文件和内存，可以从channel把数据读入buffer，也可以将buffer的数据写入channel，而stream是单向的，channel比stream更加底层。</p>
<p>简而言之，通道负责传输，缓冲区负责存储</p>
<p>常见的channel有：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>常见的buffer有：</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer(Long&#x2F;Float&#x2F;Double&#x2F;Char)</li>
</ul>
<h4 id="2-Selector"><a href="#2-Selector" class="headerlink" title="2. Selector"></a>2. Selector</h4><p>selector的作用就是配合一个线程来管理多个channel，获取这些channel上发生的事件。这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接数多，但流量低的场景。</p>
<img src="/2022/11/20/Netty/selector.png" class="" title="selector">

<p>调用selector的select()会阻塞直到channel发生了读写就绪事件</p>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol>
<li>向buffer写入数据</li>
<li>调用flip()切换读模式<ul>
<li>flip会使得buffer中的limit变为position，position变为0</li>
</ul>
</li>
<li>从buffer读取数据<ul>
<li>调用clear()方法时position&#x3D;0，limit变为capacity</li>
<li>调用compact()方法时，会将缓冲区中的未读数据压缩到缓冲区前面</li>
</ul>
</li>
<li>调用clear()或compact()切换至写模式</li>
</ol>
<h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><ul>
<li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>
<li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量</li>
<li>position：下一个读写位置的索引（类似PC）。缓冲区的位置不能为负，并且不能大于limit</li>
<li>mark：记录当前position的值。position被改变后，可以通过调用reset() 方法恢复到mark的位置</li>
</ul>
<h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔，但由于某种原因这些数据在接收时被进行了重新组合。</p>
<p>发送方在发送数据时，并不是一条一条地发送数据，而是将数据整合在一起，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去，出现粘包现象。</p>
<p>接收方的<strong>缓冲区的大小是有限</strong>的，当接收方的缓冲区满了以后，就需要将信息截断，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象，也就是半包现象。</p>
<p><strong>根本原因</strong>：TCP是流式协议，消息无边界</p>
<p><strong>解决方法</strong>：通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在通道中没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题：<ul>
<li>一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下，相关方法都不会让线程暂停<ul>
<li>在ServerSocketChannel.accept没有连接建立时，会返回null，继续运行</li>
<li>SocketChannel.read在没有数据可读时，会返回0，但线程不阻塞，可以去执行其他方法</li>
<li>写数据时，线程只是等待数据写入Channel即可，无需等待Channel把数据发送出去</li>
</ul>
</li>
<li>但是，即使没有连接建立，线程仍然不断轮询，造成cpu空转</li>
<li>数据复制过程中，线程实际还是阻塞的</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO，普通文件 IO 无法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入，限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
<h3 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h3><p>常见的网络IO主要分为同步阻塞IO（BIO）、同步非阻塞IO（NIO）、IO多路复用、异步非阻塞IO（AIO），其中<strong>BIO和IO多路复用</strong>最常用。</p>
<ol>
<li>阻塞IO：用户线程发起IO操作，待操作系统执行实际的内核操作，此期间用户线程是被阻塞的，无法执行其他操作。</li>
<li>非阻塞IO：用户线程在一个循环中（浪费cpu资源）一直调用read方法，若内核空间中还没有数据可读，立即返回</li>
<li>多路复用：当没有事件时，调用select方法会被阻塞住，一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li>
<li>异步IO：线程1调用方法后立即返回，不会被阻塞也不需要立即获取结果，当方法的运行结果出来以后，由线程2将结果返回给线程1</li>
</ol>
<h4 id="Stream与Channel"><a href="#Stream与Channel" class="headerlink" title="Stream与Channel"></a>Stream与Channel</h4><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行，虽然Stream是单向流动的，但是它也是全双工的</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>事件循环对象，EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系：</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p>事件循环组，EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>channel 的主要作用：</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h4><p>在异步处理时，经常用到这两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能&#x2F;名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h4 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h4><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>
</ul>
<h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><p>是对字节数据的封装，可以创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>也可以创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，这部分内存不受 JVM 垃圾回收的管理，注意主动释放</li>
</ul>
<p>ByteBuf 由四部分组成</p>
<img src="/2022/11/20/Netty/0010.png" class="" title="ByteBuf">

<p>方法列表：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<p>容量不够（初始容量是 10）时会引发扩容：</p>
<ul>
<li>如果写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分，可以使用标记重复读取。</p>
<p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口，基本规则是，<strong>最后使用者负责 release</strong></p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<h3 id="粘包与半包-1"><a href="#粘包与半包-1" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><p>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p>解决方案</p>
<ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/12/01/Mysql/</url>
    <content><![CDATA[<blockquote>
<p>参考mysql实战45讲</p>
</blockquote>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">类型举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数类型</td>
<td align="center">TINYINT(1Byte)、SMALLINT(2Byte)、MEDIUMINT(3Byte)、<strong>INT</strong>(4Byte)、BIGINT(8Byte)</td>
</tr>
<tr>
<td align="center">浮点数类型</td>
<td align="center">FLOAT(4Byte)、DOUBLE(8Byte)</td>
</tr>
<tr>
<td align="center">定点数类型</td>
<td align="center"><strong>DECIMAL(9Byte)</strong></td>
</tr>
<tr>
<td align="center">位类型</td>
<td align="center">BIT</td>
</tr>
<tr>
<td align="center">日期时间类型</td>
<td align="center">YEAR、TIME、DATE、<strong>DATETIME</strong>、<strong>TIMESTAMP</strong></td>
</tr>
<tr>
<td align="center">文本字符串类型</td>
<td align="center">CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td align="center">枚举类型</td>
<td align="center">ENUM</td>
</tr>
<tr>
<td align="center">集合类型</td>
<td align="center">SET</td>
</tr>
<tr>
<td align="center">二进制字符串类型</td>
<td align="center">BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td align="center">json类型</td>
<td align="center">JSON对象、JSON数组</td>
</tr>
<tr>
<td align="center">空间数据类型</td>
<td align="center">单值类型:GEOMETRY、POINT、LINESTRING、POLYGON; 集合类型:MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>float、double都是近似值，存储的时候都存在精度丢失的问题，一般使用decimal类型。如果数据范围超过decimal，建议把数据拆分为整数部分和小数部分，分别存储。</li>
<li>Int(1)和int(11)不同于varchar，在计算和存储空间上无区别，其中1和11代表的是展示的长度，当打开zerofill配置时，不足的位置会补0，如010。</li>
<li>varchar是不定长，需要额外空间记录长度，容易产生碎片，不预先分配存储空间，存储长度不要超过5000，否则建议用text类型并新建表，避免影响其他索引 。对于短得列，char效率更高</li>
</ol>
</blockquote>
<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
<h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。</p>
<p>不符合 2NF 的设计容易产生冗余数据。 </p>
<img src="/2021/12/01/Mysql/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-c99c961a76cd4ecaa4fe7c2c74ccc936.png" class="" title="第二范式">

<h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>
<p><strong>总结</strong></p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
<h2 id="explain使用"><a href="#explain使用" class="headerlink" title="explain使用"></a>explain使用</h2><p>explain是mysql生成的查询指令树，用它可以看到sql的执行计划，是优化sql的利器。</p>
<img src="/2021/12/01/Mysql/explain.png" class="" title="explain">

<p>执行计划各字段详解：</p>
<ul>
<li>type：连接的类型（<strong>越往下性能越低定要在range内，避免index和all</strong>）<ol>
<li>const,system： 最多一个匹配行，使用主键或者unique索</li>
<li>eq_ref ：一行数据，通常在联接时出现，使用主键或者unique索</li>
<li>ref：使用key的最左前缀，且key不是主键或者unique键</li>
<li>range： 索引范围扫描，对索引的扫描开始于某一点，返回匹配的行</li>
<li>index：以索引的顺序进行全表扫描，优点是不用排序，缺点是还要全表扫描</li>
<li>all:：全表扫描，必须避免</li>
</ol>
</li>
<li>extra（**不允许出行using temporaryusing filesort !**）<ol>
<li>using index：索引覆盖，查询只需要用索引即可，不需要读取数据块</li>
<li>using where：存储引擎返回数据后再做过滤</li>
<li>using temporary：使用临时表,通常在使用group by, order by的时候出现</li>
<li>using flesort：用到非索引顺序的额外排序，当order by未用到索引时发生</li>
</ol>
</li>
<li>possible_keys：显示本次查询可能用到的索引</li>
<li>key：优化器决定采用哪个索引来优化对该表的访问，可通过use index 给出建议（<strong>为空表示没用索引，应该避免</strong>）</li>
<li>rows：mysql估算的为了找到所需记录而需要检索的行数，作为优化器选择key的参考</li>
<li>key_len : 使用的索引左前缀的长度(Bytes)，亦可理解为使用了索引中哪些字段</li>
</ul>
<h1 id="01基础架构：一条SQL查询语句是如何执行的"><a href="#01基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="01基础架构：一条SQL查询语句是如何执行的"></a>01基础架构：一条SQL查询语句是如何执行的</h1><p>SQL语句在MySQL的各个功能模块中的执行过程：</p>
<img src="/2021/12/01/Mysql/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84-360a403c11d549a1ae2e4887cfcdef19.jpg" class="" title="MySQL的基本架构.jpg">
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分</p>
<ul>
<li>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li>存储引擎负责数据的存储和提取，常用的存储引擎InnoDB、MyISAM<br>不同的存储引擎<strong>共用一个Server层</strong></li>
</ul>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步会先连接到这个数据库上，连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接完成后，如果没有后续的动作，这个连接就处于空闲状态。客户端如果太长时间没动静，连接器就会自动将它断开。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<ul>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<br>因此一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。<br>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。如果查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。但是只要有对一个表的更新，这个表上所有的查询缓存都会被清空，因此<strong>查询缓存往往弊大于利</strong>。</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先会做<code>“词法分析”</code>，词法分析完后就要做<code>“语法分析”</code>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果语句不对，就会收到“You have an error in your SQL syntax”的错误提醒</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><ul>
<li>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</li>
<li>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。</li>
<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
</ul>
<h1 id="02日志系统：一条SQL更新语句是如何执行的"><a href="#02日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="02日志系统：一条SQL更新语句是如何执行的"></a>02日志系统：一条SQL更新语句是如何执行的</h1><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块 <code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志</code>，<code>再写磁盘</code></p>
<p>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。</p>
<p>同时，<code>InnoDB</code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。但是<code>InnoDB</code>的<code>redo log</code>是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB,总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，<strong>不持久保存</strong></p>
<p>在进行<code>redo log</code>写入时，有两个重要参数的write pos(当前记录的位置),<code>checkpoint</code>是当前要擦除的位置</p>
<p>一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，可以用来记录新的操作。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于<strong>归档</strong>。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p>
<p>两种日志的不同：</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>执行器和InnoDB引擎在执行update语句时的内部流程：</p>
<ol>
<li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<img src="/2021/12/01/Mysql/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE-f8075ab7263c40948fcc41d012d0a8ed.jpg" class="" title="两阶段提交示意图.jpg">
<p>redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”，简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。<strong>两阶段提交是经典的分布式系统问题</strong>，两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p>
<p>在两阶段提交的不同时刻，MySQL异常重启会出现的现象：</p>
<ol>
<li>在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。</li>
<li>在时刻B，也就是binlog写完，redo log还没commit前发生崩溃，崩溃恢复时的判断规则如下<ul>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<ul>
<li>如果是，则提交事务；</li>
<li>否则，回滚事务。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页：<ul>
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li>
<li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li>
</ul>
</li>
<li>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</li>
</ul>
<h1 id="03事务隔离：为什么你改了我还看不见"><a href="#03事务隔离：为什么你改了我还看不见" class="headerlink" title="03事务隔离：为什么你改了我还看不见"></a>03事务隔离：为什么你改了我还看不见</h1><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。</p>
<h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>事务是由一组SQL语句组成的逻辑处理单元。关系型数据库的事务有 ACID 特性：</p>
<ol>
<li>原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<table>
<thead>
<tr>
<th>问题</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>丢失更新（Lost Update）</td>
<td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td>
</tr>
<tr>
<td>脏读（Dirty Reads）</td>
<td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td>
</tr>
<tr>
<td>不可重复读（Non-Repeatable Reads）</td>
<td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td>
</tr>
<tr>
<td>幻读（Phantom Reads）</td>
<td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td>
</tr>
</tbody></table>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了<strong>前一次查询没有看到的行</strong></p>
<ol>
<li>读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>读取已提交： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>可重复读： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生，InnoDB 存储引擎默认支持的隔离级别</li>
<li>可串行化： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失更新</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read（默认）</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>“幻读”的相关说明：</p>
<ol>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
<li>查询都加了for update，就是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。</li>
</ol>
<blockquote>
<p>MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。<a href="..MySQL%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E8%83%BD%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E5%90%97">MySQL的可重复读与幻读</a></p>
</blockquote>
<p>在可重复读隔离级别下，每个select语句会把所有查询到的行<strong>都加上写锁</strong>来阻止其他事务对本事务的影响，但是此时仅仅阻止了其他事务修改本事务的值，<strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么“幻读”会被单独拿出来解决的原因。</p>
<h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（<code>MVCC</code>）</p>
<img src="/2021/12/01/Mysql/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-03be27107b234ddda0a0ef59a8c45e59.png" class="" title="多版本并发控制.png">
<p>回滚日志在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>为什么尽量不要使用长事务?长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</p>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(在可重复读隔离级别下才会生效)。<strong>间隙锁，锁的就是两个值之间的空隙</strong>。<br>这样，当执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>
<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。间隙锁之间都不存在冲突关系，事务A的间隙锁与事务B的间隙锁可能会互相阻塞。间隙锁的引入，可能会导致<strong>同样的语句锁住更大的范围</strong>，影响了并发度</p>
<h3 id="间隙锁的加锁规则"><a href="#间隙锁的加锁规则" class="headerlink" title="间隙锁的加锁规则"></a>间隙锁的加锁规则</h3><p><strong>间隙锁在可重复读隔离级别下才有效</strong></p>
<ol>
<li>加锁的基本单位是next-key lock，next-key lock是前开后闭区间。</li>
<li>查找过程中访问到的对象才会加锁。</li>
<li>索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<h1 id="04深入浅出索引"><a href="#04深入浅出索引" class="headerlink" title="04深入浅出索引"></a>04深入浅出索引</h1><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序），减少磁盘IO。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<img src="/2021/12/01/Mysql/1555902055367-afb55abfcb0d4ed8a74cc56820dd19ac.png" class="" title="索引">

<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。计算机中局部性原理也 是mysql设计<strong>页</strong>概念的重要来源。</p>
<p>优势:</p>
<ol>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>
</ol>
<p>劣势:</p>
<ol>
<li>实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也要占用空间。</li>
<li>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li>
</ol>
<h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><ul>
<li>索引的出现是为了提高查询效率，常见的三种索引模型分别是<code>哈希表</code>、<code>有序数组</code>和<code>搜索树</code></li>
<li><code>哈希表</code>：一种以<code>key-value</code> 存储数据的结构，哈希的思路是把值放在数组里，用一个哈希函数把<code>key</code>换算成一个确定的位置，然后把<code>value</code>放在数组的这个位置。哈希冲突的处理办法是使用<code>链表</code>。哈希表适用只有<code>等值查询</code>的场景</li>
<li><code>有序数组</code>：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))。查询效率高，更新效率低（涉及到移位）。在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎。</li>
<li>二叉搜索树：每个节点的左儿子小于父节点，右儿子大于父节点。查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</li>
</ul>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p>
<img src="/2021/12/01/Mysql/00001-8638a2e9cd3542a4a758f6b34e860f0f.JPG" class="" title="B+树">
<p>由于B+Tree只有叶子节点保存key信息，并且叶子结点是<strong>双向链表</strong>，支持范围查询，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p>
<p>两者区别：</p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>索引类型分为<code>主键索引</code>和<code>非主键索引</code>。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为<code>聚簇索引</code>，如果主键不是自增的，那么插入记录时很可能造成叶分裂，影响插入性能。如果表中没有定义主键，那么第一个非空的unique列就是聚簇索引，否则innodb会创建一个隐藏的row-id作为聚簇索引。 </p>
<p>在InnoDB里，非主键索引也被称为<code>二级索引</code>，二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以<strong>定位主键</strong>的位置。</p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ol>
<li>唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li>普通索引(Index) ：普通索引的唯一作用就是为了<strong>快速查询</strong>数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li>
<li>前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li>全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p><strong>主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是<code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是<code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<code>回表</code>。</li>
<li>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询</li>
</ul>
<p><strong>索引维护</strong></p>
<ul>
<li><code>B+树</code>为了维护索引有序性，在插入新值的时候需要做必要的维护。涉及到数据的移动和数据页的增加和删减</li>
<li>一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做<code>页分裂</code>，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做<code>数据页合并</code>，合并的过程是分裂过程的<code>逆过程</code>。</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p><strong>最左前缀原则</strong></p>
<img src="/2021/12/01/Mysql/%EF%BC%88name%EF%BC%8Cage%EF%BC%89%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE-cba612fc14154629b2af735ab10c7b64.jpg" class="" title="（name，age）索引示意图.jpg">
<p>索引项是按照索引定义里面出现的字段顺序排序的。SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。<strong>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索</strong>。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><ul>
<li>索引字段的选择，最佳候选列应当从where、join、group by、order by子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</li>
<li>使用唯一索引，不要让索引列的值为null。</li>
<li>update、delete操作的where子句必须命中索引，否则相当于锁表。 </li>
<li>字符串列最好创建前缀索引，而非整列索引。 </li>
<li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</li>
<li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I&#x2F;O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。</li>
<li>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果通过调整索引顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>尽量扩展索引，而不是新建索引。索引数量建议不超过5个，单个索引字段建议不超过3个。 </li>
<li>区分度高的列优先:区分度的公式是count(distinct col)&#x2F;count(*)，一般建议区分度至少大于0.1</li>
<li>宽度小的列优先:列宽度 &#x3D; 列的数据类型;宽度越小，单节点的key值越多，索引树的高度越低，查询复杂度越低</li>
</ul>
<img src="/2021/12/01/Mysql/%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%9B.png" class="" title="主键设计原则">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建复合索引:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">CREATE</span> INDEX idx_name_email_status <span class="keyword">ON</span> tb_seller(NAME,email,STATUS);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">	对name 创建索引 ;</span><br><span class="line">	对name , email 创建了索引 ;</span><br><span class="line">	对name , email, status 创建了索引 ;</span><br></pre></td></tr></table></figure>
<h2 id="索引失效与优化"><a href="#索引失效与优化" class="headerlink" title="索引失效与优化"></a>索引失效与优化</h2><ol>
<li>最佳左前缀法则（带头索引不能死，中间索引不能断）</li>
<li>在索引上做任何操作（<strong>计算、函数、自动&#x2F;手动类型转换</strong>），会导致索引失效而转向全表扫描</li>
<li>范围查询右边列失效</li>
<li>尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *</li>
<li>索引字段上使用（！&#x3D; 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</li>
<li>索引字段上使用 is null &#x2F; is not null 判断时，会导致索引失效而转向全表扫描</li>
<li>索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描(<strong>覆盖索引可以解决</strong>)</li>
<li>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</li>
<li>索引字段使用 or 时，会导致索引失效而转向全表扫描</li>
</ol>
<h1 id="05全局锁和表锁"><a href="#05全局锁和表锁" class="headerlink" title="05全局锁和表锁"></a>05全局锁和表锁</h1><p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li>对整个数据库实例加锁。MySQL提供加全局读锁的方法：<code>Flush tables with read lock(FTWRL)</code>。这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。使用场景：<code>全库逻辑备份</code>。</li>
<li>风险是如果在主库备份，在备份期间不能更新，业务停摆。如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟。官方自带的逻辑备份工具<code>mysqldump</code>，当mysqldump使用参数<code>--single-transaction</code>的时候，会启动一个事务，确保拿到一致性视图。而由于<code>MVCC</code>的支持，这个过程中数据是可以正常更新的。</li>
<li>一致性读是好，但是前提是引擎要支持这个隔离级别。如果要全库只读，为什么不使用<code>set global readonly=true</code>的方式？在有些系统中，<code>readonly</code>的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。</li>
<li>在异常处理机制上有差异。如果执行<code>FTWRL</code>命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为<code>readonly</code>之后，如果客户端发生异常，则数据库就会一直保持<code>readonly</code>状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ul>
<li>MySQL里面表级锁有两种，一种是表锁，一种是元数据所(meta data lock,MDL)。表锁的语法是:<code>lock tables ... read/write</code></li>
<li>可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
<li>对于<code>InnoDB</code>这种支持<code>行锁</code>的引擎，一般不使用<code>lock tables</code>命令来控制并发，毕竟锁住整个表的影响面还是太大。</li>
<li>另一类表级的锁是<code>MDL</code>（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。<code>读锁之间不互斥</code>，因此你可以有多个线程同时对一张表增删改查。<code>读写锁之间、写锁之间是互斥的</code>，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
<li><code>MDL</code> 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</li>
</ul>
<p> <strong>如何安全地给表加字段</strong></p>
<ul>
<li>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的<code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做<code>DDL</code>变更的表刚好有<code>长事务</code>在执行，要考虑先暂停DDL，或者<code>kill</code>掉这个长事务。</li>
<li>如果你要变更的表是一个<code>热点表</code>，虽然数据量不大，但是上面的请求很频繁，这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在<code>alter table</code>语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到<code>MDL写锁</code>最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</li>
</ul>
<p>执行“查一行”，可能会出现的被锁住和执行慢的情况。这其中涉及到了表锁、行锁和一致性读的概念。</p>
<h1 id="06行锁功过：怎么减少行锁对性能的影响"><a href="#06行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="06行锁功过：怎么减少行锁对性能的影响"></a>06行锁功过：怎么减少行锁对性能的影响</h1><p>MySQL的行锁是在<strong>引擎层</strong>由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</p>
<p>两阶段锁协议：<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放</strong>。++如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放++。</p>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<img src="/2021/12/01/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81-f038066c15b84e208968920dc2562c39.jpg" class="" title="数据库死锁.jpg">
<p>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p><strong>出现死锁以后，有两种策略：</strong></p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑(默认开启)。</li>
</ul>
<p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要<strong>消耗大量的CPU资源</strong>。因此，就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p>
<p><strong>如何解决由这种热点行更新导致的性能问题?</strong></p>
<ul>
<li><del>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</del></li>
<li>控制并发度，对应相同行的更新，在进入引擎之前排队(利用中间件)。这样在InnoDB内部就不会有大量的死锁检测工作了。</li>
<li>将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</li>
</ul>
<h1 id="07事务到底是隔离的还是不隔离的"><a href="#07事务到底是隔离的还是不隔离的" class="headerlink" title="07事务到底是隔离的还是不隔离的"></a>07事务到底是隔离的还是不隔离的</h1><p>在MySQL里，有两个“视图”的概念：</p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li>
<li>另一个是InnoDB在实现MVCC时用到的<strong>一致性读视图</strong>，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</li>
</ul>
<h2 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h2><ul>
<li>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</li>
<li>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</li>
<li>事务在启动时,找到已提交的最大事务ID记为up_limit_id。</li>
<li>InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</li>
<li>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。<img src="/2021/12/01/Mysql/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99-724cb2cf97344461837d2a96f348ff4d.png" class="" title="数据版本可见性规则.png"></li>
</ul>
<p><strong>更新逻辑</strong><br>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。当事务要去更新数据的时候，就不能再在历史版本上更新了，否则其他事务的更新就丢失了。</p>
<p>InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。</p>
<p>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；<br>对于读提交，查询只承认在语句启动前就已经提交完成的数据；<br>而当前读，总是读取已经提交完成的最新版本。</p>
<p>表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.innodb支持RC和RR隔离级别实现是用的一致性视图(consistent read view)</p>
<p>2.事务在启动时会拍一个快照,这个快照是基于整个库的.<br>基于整个库的意思就是说一个事务内,整个库的修改对于该事务都是不可见的(对于快照读的情况)<br>如果在事务内select t表,另外的事务执行了DDL t表,根据发生时间,要嘛锁住要嘛报错(参考第六章)</p>
<p>3.事务是如何实现的MVCC呢?<br>(1)每个事务都有一个事务ID,叫做transaction id(严格递增)<br>(2)事务在启动时,找到已提交的最大事务ID记为up_limit_id。<br>(3)事务在更新一条语句时,比如id&#x3D;1改为了id&#x3D;2.会把id&#x3D;1和该行之前的row trx_id写到undo log里,<br>并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头<br>(4)再定一个规矩,一个事务要查看一条数据时,必须先用该事务的up_limit_id与该行的transaction id做比对,<br>如果up_limit_id&gt;&#x3D;transaction id,那么可以看.如果up_limit_id&lt;transaction id,则只能去undo log里去取。去undo log查找数据的时候,也需要做比对,必须up_limit_id&gt;transaction id,才返回数据</p>
<p>4.什么是当前读,由于当前读都是先读后写,只能读当前的值,所以为当前读.会更新事务内的up_limit_id为该事务的transaction id</p>
<p>5.为什么rr能实现可重复读而rc不能,分两种情况<br>(1)快照读的情况下,rr不能更新事务内的up_limit_id,<br>而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id,则rc不能可重复读<br>(2)当前读的情况下,rr是利用record lock+gap lock来实现的,而rc没有gap,所以rc不能可重复读</p>
<h1 id="08普通索引和唯一索引，应该怎么选择"><a href="#08普通索引和唯一索引，应该怎么选择" class="headerlink" title="08普通索引和唯一索引，应该怎么选择"></a>08普通索引和唯一索引，应该怎么选择</h1><h2 id="唯一索引和普通索引的区别："><a href="#唯一索引和普通索引的区别：" class="headerlink" title="唯一索引和普通索引的区别："></a>唯一索引和普通索引的区别：</h2><p><strong>查询过程</strong></p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>
</ul>
<p>上面的查询区别对于性能而言是微乎其微的，引擎是按页读写的，也是说当找到k&#x3D;5的记录的时候，它所在的数据⻚就都在内存里了，那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算，可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<p><strong>更新过程</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作<strong>缓存在change buffer中</strong>，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。需要说明的是，change buffer实际上是可以持久化的数据。也就是说，change buffer<strong>在内存中有拷贝，也会被写入到磁盘上</strong>。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p>
<p>对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就<strong>没必要使用change buffer</strong>了。，实际上也<strong>只有普通索引可以使用</strong>。</p>
<ul>
<li>这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：<ul>
<li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li>
</ul>
</li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p>
<ul>
<li><p>记录要更新的目标页不在内存中。这时，InnoDB的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li>
</ul>
</li>
</ul>
<p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好；反之读多写少，反而增加了change buffer的维护代价。</p>
<p><strong>++普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。++</strong></p>
<p><strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p>
<h1 id="09MySQL为什么有时候会选错索引"><a href="#09MySQL为什么有时候会选错索引" class="headerlink" title="09MySQL为什么有时候会选错索引"></a>09MySQL为什么有时候会选错索引</h1><p>MySQL中一张表其实是可以支持多个索引的。但是，写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</p>
<h2 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h2><p>选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。</p>
<p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“<code>区分度</code>”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为<code>“基数”</code>（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p>如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p>
<h2 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h2><ul>
<li>采用force index强行选择一个索引</li>
<li>考虑修改语句，引导MySQL使用期望的索引</li>
<li>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</li>
</ul>
<h1 id="10怎么给字符串字段加索引"><a href="#10怎么给字符串字段加索引" class="headerlink" title="10怎么给字符串字段加索引"></a>10怎么给字符串字段加索引</h1><p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<ol>
<li>直接创建完整索引，这样可能比较<strong>占用空间</strong></li>
<li>创建前缀索引，节省空间，但会<strong>增加查询扫描次数，并且不能使用覆盖索引</strong></li>
<li><strong>倒序存储</strong>，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题</li>
<li><strong>创建hash字段索引</strong>，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li>
</ol>
<h1 id="11为什么有时MySQL会“抖”一下"><a href="#11为什么有时MySQL会“抖”一下" class="headerlink" title="11为什么有时MySQL会“抖”一下"></a>11为什么有时MySQL会“抖”一下</h1><ul>
<li>一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下</li>
<li>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者使用了<code>WAL技术</code>，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志，再写磁盘</code>。</li>
<li>利用WAL技术(redo log)，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些</li>
<li>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</li>
<li>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（<code>flush</code>）。</li>
</ul>
<h2 id="如何触发数据库的flush过程"><a href="#如何触发数据库的flush过程" class="headerlink" title="如何触发数据库的flush过程"></a>如何触发数据库的flush过程</h2><ol>
<li><code>InnoDB</code>的<code>redo log</code>(重做日志)写满了。这时候系统会停止所有更新操作，把<code>checkpoint(检查点)</code>往前推进，<code>redo log</code>留出空间可以继续写<img src="/2021/12/01/Mysql/redo%20log%E7%8A%B6%E6%80%81%E5%9B%BE-102e3e8100cc4e52acee251ea996d96e.jpg" class="" title="redo log状态图.jpg"></li>
<li>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。从性能考虑的如果刷脏页一定会写盘，就保证了每个数据页有两种状态：<ul>
<li>一种是内存里存在，内存里就肯定是正确的结果，直接返回</li>
<li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br> 这样的效率最高。</li>
</ul>
</li>
<li>MySQL认为系统“空闲”的时候。也要见缝插针地找时间，只要有机会就刷一点<code>“脏页”</code></li>
<li>MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ol>
<h2 id="四种场景对性能的影响"><a href="#四种场景对性能的影响" class="headerlink" title="四种场景对性能的影响"></a>四种场景对性能的影响</h2><ul>
<li>“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。从监控上看，这时候更新数会跌为0。</li>
<li>“内存不够用了，要先将脏页写到磁盘”&#96;，这种情况其实是常态。InnoDB用<strong>缓冲池</strong>（buffer pool）管理内存，缓冲池中的内存页有三种状态：第一种是，还没有使用的；第二种是，使用了并且是干净页；第三种是，使用了并且是脏页。</li>
</ul>
<p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li>
</ol>
<p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p>
<h2 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h2><p>首先，<strong>要正确地告诉InnoDB所在主机的IO能力</strong>，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值建议设置成磁盘的IOPS。</p>
<p>InnoDB的<strong>刷盘速度</strong>就是要参考两个因素：一个是脏页比例，一个是redo log写盘速度。</p>
<ul>
<li>参数<code>innodb_max_dirty_pages_pct</code>是<code>脏页比例上限</code>，默认值是<code>75%</code>。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字。<code>InnoDB</code>每次写入的日志<code>都有一个序号</code>，当前写入的序号跟<code>checkpoint</code>对应的序号之间的差值。我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，其中N越大，算出来的值越大</li>
<li>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照<code>innodb_io_capacity</code>定义的能力乘以<code>R%</code>来控制刷脏页的速度</strong><img src="/2021/12/01/Mysql/InnoDB%E5%88%B7%E8%84%8F%E9%A1%B5%E9%80%9F%E5%BA%A6%E7%AD%96%E7%95%A5-f78aff14bca94d40be03291ef9e68cc5.png" class="" title="InnoDB刷脏页速度策略.png"></li>
</ul>
<p>InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了更新语句，都可能是造成在业务端感知到MySQL“抖”了一下的原因。如果要尽量避免这种情况，就要合理地设置innodb_io_capacity的值，并且平时要多关注脏页比例，不要让它经常接近75%。</p>
<p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p>
<p>在InnoDB中，<code>innodb_flush_neighbors</code>就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。机械硬盘时代是很有意义的，可以大幅度提升系统性能。</p>
<h1 id="12为什么表数据删掉一半，表文件大小不变"><a href="#12为什么表数据删掉一半，表文件大小不变" class="headerlink" title="12为什么表数据删掉一半，表文件大小不变"></a>12为什么表数据删掉一半，表文件大小不变</h1><p>一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中，表结构定义占用的空间很小，主要是表数据所占用的内存：</p>
<ul>
<li>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的，设置为<code>OFF</code>表示的是，表的数据放在<code>系统共享表空间</code>，也就是跟数据字典放在一起；设置为<code>ON</code>表示的是，每个InnoDB表数据存储在一个以 <code>.ibd</code>为后缀的文件中。从<code>MySQL 5.6.6</code>版本开始，它的<code>默认值就是ON</code>了</li>
<li>建议不论使用MySQL的哪个版本，都<strong>将这个值设置为ON</strong>。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</li>
<li>在删除整个表的时候，可以使用drop table命令回收表空间。但是遇到的更多的删除数据的场景是删除某些行，表中的数据被删除了，但是表空间却没有被回收。</li>
</ul>
<h2 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h2><img src="/2021/12/01/Mysql/B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE-56c23f50aa5b4fc2a2a35b20fa7fd362.png" class="" title="B树索引示意图.png">
<ul>
<li>假设要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</li>
<li>InnoDB的数据是按页存储的，如果<strong>删掉了一个数据页上的所有记录，整个数据页就可以被复用了</strong>。</li>
<li>数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，比如R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</li>
<li>而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</li>
<li>所以如果<strong>用delete命令把整个表的数据删除，结果就是所有的数据页都会被标记为可复用</strong>。但是磁盘上，文件不会变小。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是<code>“空洞”</code>。</li>
<li>实际上，不止是删除数据会造成空洞，<strong>插入数据也会造成空洞</strong>。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值，这也是会造成空洞的。</li>
</ul>
<p><strong>重建表</strong></p>
<ul>
<li>重建表就是新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。</li>
<li>可以使用<code>alter table A engine=InnoDB</code>命令来重建表。MySQL 5.5之后会自动完成转存数据、交换表名、删除旧表的操作。</li>
<li>重建表的过程中，如果中途有新的数据要写入，就会造成数据丢失。所以在整个<code>DDL</code>过程中，表A中不能有更新。也就是说，这个DDL不是<code>Online</code>的。在<strong>MySQL 5.6版本开始引入的<code>Online DDL</code>，对这个操作流程做了优化</strong>。</li>
<li>重建方法都会扫描原表数据和构建临时文件，对于很大的表来说，这个操作是很消耗IO和CPU资源的。想要比较安全的操作的话，推荐使用<code>GitHub</code>开源的<a href="..https://github.com/github/gh-ost">gh-ost</a>来做。</li>
</ul>
<h1 id="13count-这么慢，我该怎么办"><a href="#13count-这么慢，我该怎么办" class="headerlink" title="13count(*)这么慢，我该怎么办"></a>13count(*)这么慢，我该怎么办</h1><h2 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h2><p>在不同的MySQL引擎中，count(*)有不同的实现方式：</p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li>
<li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p><strong>由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”是不确定的。</strong></p>
<p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>
<p><code>InnoDB是索引组织表</code>，<code>主键索引树的叶子节点是数据</code>，而<code>普通索引树的叶子节点是主键值</code>。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p>
<p>MyISAM表虽然count(<em>)很快，但是不支持事务；show table status命令虽然返回很快，但是不准确；InnoDB表直接count(</em>)会遍历全表，虽然结果准确，但会导致性能问题。</p>
<hr>
<p><strong>解决办法</strong><br>在数据库保存计数，把这个计数直接放到数据库里单独的一张计数表C中，利用“事务”的特性来解决count记录数的保存问题。</p>
<h2 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h2><p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p>
<p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p>
<ul>
<li><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</li>
<li><strong>对于count(字段)来说</strong>：如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
<li><strong>count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</li>
</ul>
<p><strong>++按照效率排序：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)，因此尽量使用count( * )++</strong></p>
<h1 id="14“orderby”是怎么工作的"><a href="#14“orderby”是怎么工作的" class="headerlink" title="14“orderby”是怎么工作的"></a>14“orderby”是怎么工作的</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>
<h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>MySQL会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code></p>
<p>通常情况下，全字段排序执行流程如下所示 ：</p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段；</li>
<li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name做快速排序(可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的<strong>内存和参数</strong><code>sort_buffer_size</code>，外部排序一般使用归并排序算法)</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h2><p>在全字段排序过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>放入sort_buffer的字段，只有要排序的列（即name字段）和主键id，但这时排序的结果因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示：</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name进行排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li>
</ol>
<p><strong>rowid排序多访问了一次表的主键索引</strong><br><strong>MySQL的设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问</strong>，对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
<h1 id="15如何正确地显示随机消息"><a href="#15如何正确地显示随机消息" class="headerlink" title="15如何正确地显示随机消息"></a>15如何正确地显示随机消息</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><p><strong>对于InnoDB表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。</strong><br><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>，所以MySQL这时就会选择rowid排序。</p>
<p><code>select word from words order by rand() limit 3;</code><br>随机排序取前3个，执行流程如下：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li>
<li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li>
<li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li>
<li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li>
<li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li>
</ol>
<p><strong>++order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。++</strong></p>
<h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</p>
<p>总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。所以，在设计的时候要量避开这种写法。</p>
<h1 id="16为什么只查一行的语句，也执行这么慢"><a href="#16为什么只查一行的语句，也执行这么慢" class="headerlink" title="16为什么只查一行的语句，也执行这么慢"></a>16为什么只查一行的语句，也执行这么慢</h1><h2 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p>
<p>然后再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。</p>
<h3 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h3><p>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</p>
<p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p>
<img src="/2021/12/01/Mysql/Waiting%20for%20table%20metadata%20lock%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" class="" title="Waiting for table metadata lock状态示意图">
<p>但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p>
<p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p>
<h3 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h3><p>MySQL里面对表做flush操作的用法，一般有以下两个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>
<p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p>
<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>
<p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了的select语句。</p>
<h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br></pre></td></tr></table></figure>
<p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，select语句就会被堵住。</p>
<h2 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">50000</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>；<span class="operator">/</span><span class="operator">/</span>慢</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode；<span class="operator">/</span><span class="operator">/</span>快</span><br></pre></td></tr></table></figure>
<p>查询的同时有其余事务在修改当前行，带lock in share mode的SQL语句，是当前读，因此会直接读到最新这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从最新开始，依次执行undo log，执行了多次以后，才将1这个结果返回。</p>
<h1 id="17暂时提高性能的方法"><a href="#17暂时提高性能的方法" class="headerlink" title="17暂时提高性能的方法"></a>17暂时提高性能的方法</h1><h2 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h2><p>MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。max_connections参数，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求。调高max_connections的值，但这样做是有风险的。因为设计max_connections这个参数的目的是想保护MySQL，如果把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。<br>解决方法：</p>
<ol>
<li>先处理掉那些占着连接但是不工作的线程</li>
<li>减少连接过程的消耗</li>
</ol>
<h2 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h2><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li>索引没有设计好；</li>
<li>SQL语句没写好；</li>
<li>MySQL选错了索引。应急方案就是给这个语句加上force index。</li>
</ol>
<h2 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h2><ol>
<li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li>
</ol>
<h1 id="18MySQL是怎么保证数据不丢的"><a href="#18MySQL是怎么保证数据不丢的" class="headerlink" title="18MySQL是怎么保证数据不丢的"></a>18MySQL是怎么保证数据不丢的</h1><h2 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h2><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。</p>
<img src="/2021/12/01/Mysql/binlog%E5%86%99%E7%9B%98%E7%8A%B6%E6%80%81-988ee9cab2e84ebfba4e71cd2da36716.png" class="" title="binlog写盘状态.png">
<p>每个线程有自己binlog cache，但是共用同一份binlog文件。</p>
<ul>
<li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下认为fsync才占磁盘的IOPS。</li>
</ul>
<p>write 和fsync的时机，是由参数sync_binlog控制的：</p>
<ul>
<li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li>
<li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li>
<li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li>
</ul>
<p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p>
<p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p>
<h2 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h2><p>事务在执行过程中，生成的redo log是要先写到redo log buffer中，redo log buffer里面的内容，不需要每次生成后都持久化到磁盘，如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p>
<h1 id="19MySQL是怎么保证主备一致的"><a href="#19MySQL是怎么保证主备一致的" class="headerlink" title="19MySQL是怎么保证主备一致的"></a>19MySQL是怎么保证主备一致的</h1><p>binlog可以用来归档，也可以用来做主备同步，MySQL几乎所有的高可用架构，都直接依赖于binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p>
<h2 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h2><img src="/2021/12/01/Mysql/MySQL%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B-14944ae918554054b4673f6b229dd6f8.png" class="" title="MySQL主备切换流程.png">
<p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p>
<p>当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。</p>
<p>备库设置成只读，readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p>
<img src="/2021/12/01/Mysql/%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B%E5%9B%BE-e4606d8e10894461862c5cc62b0b88a7.png" class="" title="主备流程图.png">

<ul>
<li>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</li>
<li>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：<ul>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ul>
</li>
</ul>
<h2 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>此时binlog里面记录的就是SQL语句的原文，但是这个命令可能是unsafe的</p>
<ol>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a&#x3D;4这一行；</li>
<li>但如果使用的是索引t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是a&#x3D;5这一行。</li>
</ol>
<p>由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。</p>
<h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><p>当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p>
<p><strong>缺点</strong>：很占空间。如果用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</p>
<h3 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h3><p>mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p>
<p><strong>因此，如果MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个不合理的设置。至少应该把binlog的格式设置为mixed。</strong></p>
<p>现在越来越多的场景要求把MySQL的binlog格式设置成row。这么做最大的好处：<strong>恢复数据</strong></p>
<ul>
<li>执行的是delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。</li>
<li>如果执行错了insert语句。row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。</li>
<li>执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</li>
</ul>
<h1 id="20MySQL是怎么保证高可用的"><a href="#20MySQL是怎么保证高可用的" class="headerlink" title="20MySQL是怎么保证高可用的"></a>20MySQL是怎么保证高可用的</h1><p>正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。但是，MySQL要提供高可用能力，只有最终一致性是不够的。</p>
<img src="/2021/12/01/Mysql/MySQL%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B--%E5%8F%8CM%E7%BB%93%E6%9E%84-312534f4824549f1b2163d680d987e65.png" class="" title="MySQL主备切换流程双M结构.png">

<h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li>
<li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li>
<li>备库B执行完成这个事务，我们把这个时刻记为T3。</li>
</ol>
<p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p>
<p>所以说，主备延迟最直接的表现是，<strong>备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢</strong>。<br>产生延迟的原因：</p>
<ul>
<li>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</li>
<li>备库的压力大。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</li>
<li>大事务。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。</li>
</ul>
<p>客户端写入主库的并行度明显大于备库上sql_thread执行中转日志的并行度，这就造成了备库的延迟。在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p>
<h2 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h2><p>在上图的双M结构下，从状态1到状态2切换的详细过程是这样的：</p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步</li>
<li>把主库A改成只读状态，即把readonly设置为true</li>
<li>判断备库B的seconds_behind_master的值，直到这个值变成0为止（<strong>比较耗费时间</strong>）</li>
<li>把备库B改成可读写状态，也就是把readonly 设置为false</li>
<li>把业务请求切到备库B</li>
</ol>
<p><strong>在切换流程中系统是有不可用时间的</strong>。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p>
<h2 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h2><p>如果不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写即把步骤4、5调整到最开始执行，那么系统几乎就没有不可用时间了，就是可能出现数据不一致的情况。</p>
<p>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</p>
<p>因此，大多数情况下，都建议使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p>
<h1 id="21备库并行复制能力"><a href="#21备库并行复制能力" class="headerlink" title="21备库并行复制能力"></a>21备库并行复制能力</h1><img src="/2021/12/01/Mysql/%E4%B8%BB%E5%A4%87%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E8%83%BD%E5%8A%9B.jpg" class="" title="主备的并行复制能力">
<p>谈到主备的并行复制能力，要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log)。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p>
<p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p>
<p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p>
<p>在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。</p>
<img src="/2021/12/01/Mysql/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" class="" title="多线程模型">
<p>coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li>
<li>同一个事务不能被拆开，必须放到同一个worker中。</li>
</ol>
<h2 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h2><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。<br>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</li>
<li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；</li>
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。</p>
<h2 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h2><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+索引a的名字+a的值”。<strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong></p>
<p>这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li>
</ol>
<p><a href="..https://funnylog.gitee.io/mysql45/26%E8%AE%B2%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6.html">备库并行复制能力</a></p>
<h1 id="22一主多从"><a href="#22一主多从" class="headerlink" title="22一主多从"></a>22一主多从</h1><p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<img src="/2021/12/01/Mysql/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84--%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2-880956af29ba467481d40652b1a99959.png" class="" title="一主多从基本结构主备切换.png">
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<h2 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h2><p>当把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name </span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port </span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password </span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span>$master_log_name </span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>$master_log_pos </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>从主库的master_log_name文件的master_log_pos这个位置的日志继续同步</span><br></pre></td></tr></table></figure>

<p>节点B原本是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的。因此，从库B要切换的时候，就需要先经过“找同步位点”这个逻辑，这个位点很难精确取到，只能取一个大概位置，然后跳过那些执行过的事务。</p>
<p>为了解决复杂的跳过事务方法，MySQL 5.6版本引入了<strong>GTID</strong>，彻底解决了这个困难。GTID的全称是Global Transaction Identifier，也就是<strong>全局事务ID</strong>，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：<br><code>GTID=server_uuid:gno</code><br>其中：</p>
<ul>
<li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li>
</ul>
<p>在GTID模式下，每个事务都会跟一个GTID一一对应，这样每个MySQL实例都拥有自己执行过的事务集合。</p>
<h2 id="主从延迟解决策略"><a href="#主从延迟解决策略" class="headerlink" title="主从延迟解决策略"></a>主从延迟解决策略</h2><p>读写分离的主要目标就是分摊主库的压力，但是会存在主从延迟问题。</p>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，将查询请求分为两类：</p>
<ul>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。</li>
</ul>
<h3 id="Sleep方案"><a href="#Sleep方案" class="headerlink" title="Sleep方案"></a>Sleep方案</h3><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。<br>这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：</p>
<ol>
<li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</li>
<li>如果延迟超过1秒，还是会出现过期读。</li>
</ol>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>要确保备库无延迟，通常有三种做法。</p>
<ol>
<li>每次从库执行查询请求前，先判断seconds_behind_master（可以用来衡量主备延迟时间的长短）是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</li>
<li>对比位点确保主备无延迟：对比主库与从库的最新位点是否相同。如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</li>
<li>对比GTID集合确保主备无延迟：如果这两个集合相同，也表示备库接收到的日志都已经同步完成</li>
</ol>
<p>对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。但还是没有达到“精确”的程度。一个事务的binlog在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入binlog，并反馈给客户端；</li>
<li>binlog被从主库发送给备库，备库收到；</li>
<li>在备库执行binlog完成。</li>
</ol>
<p>上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<h3 id="配合semi-sync方案"><a href="#配合semi-sync方案" class="headerlink" title="配合semi-sync方案"></a>配合semi-sync方案</h3><p>要解决这个问题，就要引入半同步复制，semi-sync做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库；</li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。<br>semi-sync配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p><code>select master_pos_wait(file, pos[, timeout]);</code><br>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p>
<img src="/2021/12/01/Mysql/master_pos_wait%E6%96%B9%E6%A1%88-de5d246427d84dd892362e76299a44c3.png" class="" title="master_pos_wait方案.png">

<h3 id="等GTID方案"><a href="#等GTID方案" class="headerlink" title="等GTID方案"></a>等GTID方案</h3><img src="/2021/12/01/Mysql/%E7%AD%89GTID%E6%96%B9%E6%A1%88-4d323bec9d234687950f6a36dfe1ce80.png" class="" title="等GTID方案.png">

<h1 id="23如何判断一个数据库是不是出问题了"><a href="#23如何判断一个数据库是不是出问题了" class="headerlink" title="23如何判断一个数据库是不是出问题了"></a>23如何判断一个数据库是不是出问题了</h1><p>在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p>
<p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p>
<h2 id="select-1判断"><a href="#select-1判断" class="headerlink" title="select 1判断"></a>select 1判断</h2><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p>
<img src="/2021/12/01/Mysql/%E6%9F%A5%E8%AF%A2blocked.png" class="" title="查询blocked">
<p>在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高。session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是说，<strong>如果这时候用select 1来检测实例是否正常的话，是检测不出问题的。</strong><br>所以，通常情况下建议把innodb_thread_concurrency设置为64~128之间的值。在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙锁)的线程是不算在128里面的。只有“当前正在执行”的语句才计算为并发线程</p>
<h2 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h2><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期查询。</p>
<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。<br>但是，马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。<br>我们知道，更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>
<h2 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h2><p>常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。<br>更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让DBA头疼的问题。</p>
<p>IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。</p>
<p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p>
<h2 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h2><p>MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p>
<p>如果打开所有的performance_schema项，性能大概会下降10%左右。所以，建议只打开自己需要的项进行统计。</p>
<h1 id="24-误删数据的恢复"><a href="#24-误删数据的恢复" class="headerlink" title="24 误删数据的恢复"></a>24 误删数据的恢复</h1><h2 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h2><p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</p>
<p><strong>误删数据事前预防</strong>：</p>
<ol>
<li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过SQL审计。</li>
</ol>
<p>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑应该优先考虑使用truncate table或者drop table命令。但是使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。</p>
<h2 id="误删库-x2F-表"><a href="#误删库-x2F-表" class="headerlink" title="误删库&#x2F;表"></a>误删库&#x2F;表</h2><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p>
<p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li>
<li>用备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨0点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<h2 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h2><p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。</p>
<p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p>
<p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p>
<p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 应用</title>
    <url>/2024/03/16/Redis-%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><p>在互联网的高流量、高并发场景下，MySQL 集群能够扛住的 QPS 通常在 1W 量级，数据库在达到压力瓶颈时会明显出现慢尾效应，即原有执行速度很快的 sql 耗时也会显著增加，拖累使用了此集群的所有服务，最终导致整个数据库集群的崩溃。</p>
<p>相比于 redis 缓存来说，MySQL 集群的资源更加珍贵，为了保护数据库集群且让服务能够承受更高的流量，我们通常使用缓存来减少数据库的压力，对那些热点数据进行缓存来分担 MySQL 的压力。对于 redis 集群来说，可以轻松承担 10 W+的 QPS，并且可以很方便的进行扩容。</p>
<h2 id="缓存可能出现的问题"><a href="#缓存可能出现的问题" class="headerlink" title="缓存可能出现的问题"></a>缓存可能出现的问题</h2><h3 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h3><p>Redis 缓存通常放在 MySQL 集群的前置链路，下图是缓存的<strong>只读操作（缓存不接受RPC 的直接数据修改）</strong>。</p>
<img src="Redis-应用/image-20240316114950264.png" alt="image-20240316114950264" style="zoom:50%;" />

<p>在服务流量非常高的情况下缓存出现缺失，一瞬间所有请求都打到 MySQL 集群上，这时候需要评估数据库能否扛住，通常情况下是只让一个请求访问 db，其余全部阻塞来保护 MySQL 集群。缓存雪崩、缓存击穿、缓存穿透都有可能发生以上问题。</p>
<p>常用的避免手段有：</p>
<ol>
<li>cacheSetter</li>
<li>分布式锁</li>
</ol>
<img src="Redis-应用/image-20240316181318284.png" alt="image-20240316181318284" style="zoom:50%;" />

<h4 id="延迟双删-先删除缓存后修改-db（不建议）"><a href="#延迟双删-先删除缓存后修改-db（不建议）" class="headerlink" title="延迟双删-先删除缓存后修改 db（不建议）"></a>延迟双删-先删除缓存后修改 db（不建议）</h4><p>发生写操作时<strong>先删除缓存，然后去修改数据库</strong>，由下一个请求触发缓存缺失来更新缓存。这种有可能在写数据库时下次请求把旧数据刷新到缓存中，导致缓存中保存了脏数据。</p>
<p>这种解决办法也比较简单：更新操作的线程在更新完数据库后，让线程短暂 sleep 一段时间，然后再次删除缓存，这样就解决了更新操作时被其他线程写入缓存的脏数据，这种操作被称为<strong>延迟双删</strong>。需要评估线程 sleep 的时间，需要保证时间大于线程 2 的时间。</p>
<p>这种办法的缺点是：</p>
<ol>
<li>中间会有一些线程读取到了脏数据，但是保证了缓存最终一致性。</li>
<li>需要 sleep 且需要准确评估时间。</li>
</ol>
<img src="Redis-应用/image-20240317114224815.png" alt="image-20240317114224815" style="zoom:50%;" />

<h4 id="先修改-db-再删除缓存"><a href="#先修改-db-再删除缓存" class="headerlink" title="先修改 db 再删除缓存"></a>先修改 db 再删除缓存</h4><p>在线程 1 完成之前，线程 2 的都只能查询到缓存中的脏数据，在线程 1 修改结束后线程 3 可以查询到新数据。</p>
<p>缺点：中间线程读取到了脏数据。</p>
<p>优点：省去了线程 sleep 的时间，在对数据一致性要求不严的情况下通常也会选择先更新数据库再删除缓存的办法。</p>
<img src="Redis-应用/image-20240317114950596.png" alt="image-20240317114950596" style="zoom:50%;" />

<h4 id="删除操作可能失效"><a href="#删除操作可能失效" class="headerlink" title="删除操作可能失效"></a>删除操作可能失效</h4><p>无论是先修改数据库还是先删除缓存，都有可能碰到操作失效的情况。如果发生这种情况，缓存的数据有可能永远都不会被更新，导致以后的线程读取到的都是脏数据。</p>
<p>这种情况的解决办法是：把删除缓存的操作和数据库更新<strong>操作放在消息中间件中</strong>，利用中间件的失败重试策略，保证最终一定消费成功。</p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>当 RPC 服务发生数据更新操作时，这时需要保持缓存和 db 的一致性，通常采取的办法是删除缓存并写入数据库，等待下次查询操作来临时发现缓存缺失，重新从 MySQL 中读取数据并放入缓存中，此时可能由于<strong>缓存缺失</strong>导致上述问题。这种缓存即接收读请求、也有写请求的方式被称为读写缓存。</p>
<p>读写缓存保证数据库和缓存一致性有以下方式：</p>
<ul>
<li>写操作发生在缓存，同时事务性的修改数据库。可以保证数据一致性，但是请求需要阻塞等待两部操作都完成。</li>
<li>缓存写操作结束后立即返回，在缓存失效时或者定期用缓存中的数据去更新数据库。这种有可能由于缓存断电导致数据丢失。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的数据请求无法在缓存中处理，所有请求全部打到数据库上，这种情况发生主要是因为缓存都会设置对应的过期时间，如果某一大批数据被同时设置了相同的过期时间，那么在缓存过期的瞬间，大量的请求会落到数据库上，可能造成数据库宕机。</p>
<img src="/2024/03/16/Redis-%E5%BA%94%E7%94%A8/image-20240317180337137.png" class="" title="image-20240317180337137">

<p>对应的有两种解决办法：</p>
<ol>
<li>缓存的过期时间随机增加一个随机数，避免在同一时刻这些数据一同过期。</li>
<li>进行服务降级：同时过期的这些数据，只允许核心数据回源数据库查询，其余不重要的数据准备一个默认值。这样就能减少一部分请求打到数据库上，进而保护数据库资源。</li>
</ol>
<p>除此之外，Redis 集群直接挂掉也会导致所有请求落到数据库上。也有两种办法：</p>
<ol>
<li>缓存系统宕机后，进行服务熔断和服务限流，当一段时间间隔内，多次发生访问redis失败，就进入熔断状态。一段时间之后允许少量请求通过，如果请求都执行成功，则退出熔断状态，如果请求仍旧失败，在下一个时间段，再次允许少量请求通过，试探服务是否恢复。</li>
<li>缓存系统避免使用单点系统，使用主从节点构造高可用集群，防止主节点宕机导致整个服务不可用。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿指的是非常热门的数据忽然失效了，导致热点请求落到数据库上，这种行为让数据库压力激增，进而影响到数据库其他请求，拖累整个服务。</p>
<p>为了避免缓存击穿给数据库带来的激增压力，对于访问特别频繁的热点数据，不设置过期时间。这样一来，对热点数据的访问请求，都可以在缓存中进行处理，而 Redis 的高吞吐量可以很好地应对大量的并发请求访问。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存击穿和缓存雪崩发生时，数据库都保存了对应的值，因此可以通过重新加载缓存来保护数据库。而缓存穿透则是数据库和缓存都不存在这个值，无效的请求频繁打穿缓存到数据库上，数据库执行查询后返回了空数据，如果持续有这种<strong>恶意请求</strong>，就会对缓存服务和数据库服务造成大量浪费。有几种解决办法：</p>
<ol>
<li>对于空值也进行缓存</li>
<li>使用布隆过滤器进行过滤</li>
<li>前端拦截掉非法请求</li>
</ol>
<h2 id="数据一致性保证"><a href="#数据一致性保证" class="headerlink" title="数据一致性保证"></a>数据一致性保证</h2><h3 id="旁路缓存的问题"><a href="#旁路缓存的问题" class="headerlink" title="旁路缓存的问题"></a>旁路缓存的问题</h3><p>多个线程更新缓存操作的<strong>时序行</strong>不同导致缓存出现脏数据。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">线程  1</th>
<th align="center">线程 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td align="center">读缓存 k 缺失</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t2</td>
<td align="center">查询 db，k &#x3D; v1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t3</td>
<td align="center"></td>
<td align="center">写 db，k &#x3D; v2</td>
</tr>
<tr>
<td align="center">t4</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t5</td>
<td align="center"></td>
<td align="center">删除缓存 k</td>
</tr>
<tr>
<td align="center">t6</td>
<td align="center">写缓存，k &#x3D; v1（脏数据）</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>缓存删除操作失败，导致缓存中出现脏数据。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">线程  1</th>
<th align="center">线程 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td align="center">写 db，k &#x3D; v2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t2</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t3</td>
<td align="center">删除缓存（删除失败）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t4</td>
<td align="center"></td>
<td align="center">读缓存，k &#x3D; v1（脏数据）</td>
</tr>
</tbody></table>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>为了解决缓存缓存不一致 &amp;&amp; 把缓存和业务系统解构，采用以下方案：</p>
<ol>
<li>引入 binlog 模块，监听 MySQL 的数据日志进行缓存更新，此举带来两个新问题<ol>
<li>可能存在很多业务逻辑只更新无关字段（比如数据更新时间），这样会带来大量的 binlog ，导致数据中线消费不过来，最终导致缓存和 db 的数据不一致。<strong>这种延迟通过时间可以被修复</strong>。</li>
<li>binlog 数据总线模块宕机，数据完全无法同步。<strong>这种情况缓存没有修复可能性</strong>。</li>
</ol>
</li>
<li>binlog 消费不过来可以不监听无关字段（由业务决定），写MySQL 时同步 cas 的写入缓存。</li>
<li>宕机可以通过增量定时任务 &amp;&amp; 全量定时任务来进行兜底保证缓存的最终一致性。</li>
</ol>
<img src="/2024/03/16/Redis-%E5%BA%94%E7%94%A8/image-20240322173429484.png" class="" title="image-20240322173429484">
]]></content>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2022/02/22/RocketMQ/</url>
    <content><![CDATA[<h1 id="RocketMQ概述"><a href="#RocketMQ概述" class="headerlink" title="RocketMQ概述"></a>RocketMQ概述</h1><p>MQ，Message Queue，是一种提供消息队列服务的中间件，也称为消息中间件。消息即数据，一般消息的体量不会很大。简单来说，消息队列就是一种实现“先进先出”的一种数据结构。</p>
<p><strong>用途</strong>：</p>
<ol>
<li>应用解藕：上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。 而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两 层间添加一个MQ层。</li>
<li>流量消峰：MQ可以将系统的 超量 请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。</li>
<li>消息分发：数据的生产方只需要把各自的数据写入一个消息队列即可，数据使用方根据各自需求订阅感兴趣的数据，不同团队所订阅的数据互不干扰，也不必和数据产生方关联。</li>
</ol>
<h2 id="RocketMQ的架构"><a href="#RocketMQ的架构" class="headerlink" title="RocketMQ的架构"></a>RocketMQ的架构</h2><p>RocketMQ 技术架构中有四大角色 NameServer 、Broker 、Producer 、Consumer：</p>
<ul>
<li>Broker： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器，生产者生产消息到 Broker ，消费者从 Broker 拉取消息并消费。一个 Topic 分布在多个 Broker上，一个 Broker 可以配置多个 Topic ，它们是多对多的关系。 如果某个 Topic 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力 。</li>
<li>NameServer：Broker会将自己的信息注册到 NameServer 中，此时 NameServer 就存放了很多 Broker 的信息(Broker的路由表)，消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息和对应的 Broker 进行通信(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息)。</li>
<li>Producer： 消息发布的角色，支持分布式集群方式部署。</li>
<li>Consumer： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h3><p>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>
<h3 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题(Topic)"></a>主题(Topic)</h3><p>Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<p>一个生产者可以同时发送多种Topic的消息;而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种Topic的消息。</p>
<p>每个主题中都有多个队列(分布在不同的Broker中，如果是集群的话，Broker又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 topic 的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>
<h3 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签(Tag)"></a>标签(Tag)</h3><p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业 务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提 供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。</p>
<p>一个Topic的Queue也被称为一个Topic中消息的分区(Partition)。 一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>
<h3 id="消息标识-MessageId-x2F-Key"><a href="#消息标识-MessageId-x2F-Key" class="headerlink" title="消息标识(MessageId&#x2F;Key)"></a>消息标识(MessageId&#x2F;Key)</h3><p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。 不过需要注意的是，MessageId有两个:在生产者send()消息时会自动生成一个MessageId(msgId)， 当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>
<h3 id="消费位移-offset"><a href="#消费位移-offset" class="headerlink" title="消费位移(offset)"></a>消费位移(offset)</h3><p>在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 消费位移(offset) ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><h3 id="消息发送分类"><a href="#消息发送分类" class="headerlink" title="消息发送分类"></a>消息发送分类</h3><ol>
<li>同步发送消息：Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</li>
<li>异步发送消息：Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</li>
<li>单向发送消息：roducer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</li>
</ol>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息(FIFO)。</p>
<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列;而消费消息时会从 多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个 Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>
<hr>
<p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性:分区有序与全局有序。</p>
<ul>
<li>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序，称为全局有序。</li>
<li>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为分区有序。</li>
</ul>
<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。 </p>
<p>采用RocketMQ的延时消息可以实现 定时任务 的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景，12306平台订票超时未支付取消订票的场景。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><h2 id="消费问题"><a href="#消费问题" class="headerlink" title="消费问题"></a>消费问题</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>RocketMQ 在主题上是无序的、它只有在队列层面才是保证有序的。将同一语义下的消息放入同一个队列，使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中。</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>幂等，在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。<br>可以通过写入 Redis 来保证，因为 Redis 的 key 和 value 就是天然支持幂等的。当然还有使用 数据库插入法 ，基于数据库的唯一键来保证重复数据不会被插入多条。 不过最主要的还是需要 根据特定场景使用特定的解决方案。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/12/01/Redis/</url>
    <content><![CDATA[<h1 id="01数据结构"><a href="#01数据结构" class="headerlink" title="01数据结构"></a>01数据结构</h1><p>简单来说，底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：</p>
<img src="/2021/12/01/Redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="" title="redis数据结构">
<p>可以看到，string类型的底层实现只有一种数据结构。而List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下把这四种类型称为集合类型，它们的特点是一个键对应了一个集合的数据。</p>
<h2 id="不同value的底层实现"><a href="#不同value的底层实现" class="headerlink" title="不同value的底层实现"></a>不同value的底层实现</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>除了记录实际数据，String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了。<br>String 类型具体保存数据有两种方式：</p>
<ol>
<li>保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式</li>
<li>保存的数据中包含字符时，String 类型就会用简单动态字符串（SDS）结构体来保存，其中包含：<ol>
<li>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销</li>
<li>len：占 4 个字节，表示 buf 的已用长度。</li>
<li>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len</li>
</ol>
</li>
</ol>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。</p>
<img src="/2021/12/01/Redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE.png" class="" title="压缩列表的查找">

<p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。每个 entry 的元数据包括下面几部分：</p>
<ol>
<li>prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。</li>
<li>len：表示自身长度，4 字节；</li>
<li>encoding：表示编码方式，1 字节；</li>
<li>content：保存实际数据。</li>
</ol>
<p>Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型。Hash类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。<br>这两个阈值分别对应以下两个配置项：</p>
<ol>
<li>hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。</li>
<li>hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度</li>
</ol>
<h2 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h2><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。</p>
<p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。如下所示：</p>
<img src="/2021/12/01/Redis/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.png" class="" title="全局哈希表">
<p>只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以通过指针地址访问相应的 entry 元素。<strong>但是，写入大量数据后哈希表会出现冲突问题和 rehash 可能带来的操作阻塞。</strong></p>
<h2 id="哈希表操作为什么会变慢"><a href="#哈希表操作为什么会变慢" class="headerlink" title="哈希表操作为什么会变慢"></a>哈希表操作为什么会变慢</h2><p>哈希桶的数量通常要少于key的数量，也就是说难免会有一些key的哈希值对映射到了同一个桶中。Redis解决哈希冲突的方式是<strong>拉链法</strong>。当某条链过长，Redis 会对哈希表做 rehash 操作。</p>
<p>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间</li>
</ol>
<p>但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis <strong>采用了渐进式 rehash</strong>。</p>
<p>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的entries。如下图所示：</p>
<img src="/2021/12/01/Redis/%E6%B8%90%E8%BF%9B%E5%BC%8Frehash.png" class="" title="渐进式rehash">
<p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p>
<h2 id="集合数据操作效率"><a href="#集合数据操作效率" class="headerlink" title="集合数据操作效率"></a>集合数据操作效率</h2><p>集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。</p>
<p><strong>压缩列表</strong>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>
<img src="/2021/12/01/Redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE.png" class="" title="压缩列表的查找">
<p>在压缩列表中，如果要查找第一个元素和最后一个元素，可以通过表头字段直接定位，复杂度是O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<p><strong>跳表</strong>在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，如下所示：</p>
<img src="/2021/12/01/Redis/%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" class="" title="跳表的查找过程">
<p>当数据量很大时，跳表的查找复杂度就是 O(logN)</p>
<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><ol>
<li>单元素操作，指每一种集合类型对单个数据实现的增删改查操作。复杂度是O(1)</li>
<li>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数。这类操作的复杂度一般都是O(N)，应该尽量避免</li>
<li>统计操作，是指集合类型对集合中所有元素个数的记录。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计。</li>
<li>压缩列表和双向链表都会记录表头和表尾的偏移量。</li>
</ol>
<h1 id="02高性能IO模型：单线程的Redis"><a href="#02高性能IO模型：单线程的Redis" class="headerlink" title="02高性能IO模型：单线程的Redis"></a>02高性能IO模型：单线程的Redis</h1><p>Redis 是单线程，主要是指 Redis 的网络 IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<h2 id="为什么用单线程"><a href="#为什么用单线程" class="headerlink" title="为什么用单线程"></a>为什么用单线程</h2><p>系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也<br>在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程增加而增加。</p>
<p>而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</p>
<h2 id="单线程的快"><a href="#单线程的快" class="headerlink" title="单线程的快"></a>单线程的快</h2><p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了<strong>多路复用机制</strong>，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>
<p>从下图可以看出，Redis 的线程可能存在的阻塞点有两个：</p>
<ol>
<li>accept 建立连接请求和 recv 接收数据请求</li>
<li>进行耗时较高的数据读写时</li>
</ol>
<p>当 Redis监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。不过<strong>socket 网络模型本身支持非阻塞模式</strong>。<img src="/2021/12/01/Redis/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.png" class="" title="Redis基本IO模型"></p>
<p>不过在 socket 模型中存在非阻塞模式，即调用相关函数后返回一个监听套接字并注册一个回调函数，操作系统内核中允许存在多个监听套接字，当监听到的事件发生后操作系统内核会回调 redis 主线程。</p>
<p>非阻塞的监听套接字在 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。类似的Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。这样由操作系统的网络模型保证 Redis 线程既不会一直被阻塞在接收网络请求上，也不会导致Redis无法处理实际到达的连接请求或数据。</p>
<img src="/2021/12/01/Redis/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.png" class="" title="基于多路复用的Redis高性能IO模型">select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis 的响应性能。

<h1 id="03持久化"><a href="#03持久化" class="headerlink" title="03持久化"></a>03持久化</h1><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。主要是防止数据的意外丢失，确保数据安全性。</p>
<h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a>快照持久化（RDB）</h2><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，<strong>它执行的是全量快照</strong>。全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。</p>
<p>Redis 提供了两个命令来生成 RDB 文件：</p>
<ol>
<li>save：指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，但不是立即执行</li>
</ol>
<h3 id="快照时数据修改"><a href="#快照时数据修改" class="headerlink" title="快照时数据修改"></a>快照时数据修改</h3><p>为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>
<p>简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份<strong>，生成该数据的副本</strong>。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<img src="/2021/12/01/Redis/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E5%BF%AB%E7%85%A7%E6%9C%9F%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BF%AE%E6%94%B9.png" class="" title="写时复制机制保证快照期间数据可修改">

<p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行<strong>全量快照</strong>，也会带来两方面的开销：</p>
<ol>
<li>频繁将全量数据写入磁盘，会给磁盘带来很大压力</li>
<li>bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork <strong>这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越大，阻塞时间越长</li>
</ol>
<h3 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h3><ul>
<li><strong>优点</strong><ul>
<li>RDB是一个紧凑压缩的二进制文件，节省磁盘空间</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据速度快</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>RDB方式宕机时可能会丢失最后一次备份后的所有修改</li>
<li>每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF是写后日志，即Redis先执行命令，把数据写入内存然后才记录日志。日志中记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志<br>中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志有两个好处：</p>
<ol>
<li>可以避免出现记录错误命令的情况。</li>
<li>在命令执行后才记录日志，所以不会阻塞当前的写操作。</li>
</ol>
<p>同时这种方式也有两个潜在的风险：</p>
<ol>
<li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</li>
<li>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>是否开启AOF持久化功能，默认为不开启状态</span><br><span class="line">appendonly yes<span class="operator">|</span><span class="keyword">no</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>AOF写数据策略</span><br><span class="line">appendfsync always<span class="operator">|</span>everysec<span class="operator">|</span><span class="keyword">no</span></span><br></pre></td></tr></table></figure>

<h3 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h3><ol>
<li>always：每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</li>
<li>everysec：每秒钟同步一次，数据准确性较高，性能较高</li>
<li>no：让操作系统决定何时进行同步</li>
</ol>
<p>AOF 是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越大。</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF文件重写是将redis进程内的数据转化为写命令同步到新AOF文件的过程。简单来说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。</p>
<p>作用：</p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<p>规则：</p>
<ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令<ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
<p>和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<p>每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的<strong>内存拷贝</strong>一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p>
<p>因为<strong>主线程未阻塞</strong>，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。</p>
<img src="/2021/12/01/Redis/AOF%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.png" class="" title="AOF非阻塞的重写过程">

<h3 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h3><ul>
<li><strong>优点</strong><ul>
<li>备份机制更稳健，丢失数据概率更低</li>
<li>可读的日志文本，通过操作AOF文件，可以处理误操作</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>需要占用更多的磁盘空间</li>
<li>恢复备份速度更慢</li>
<li>如果每次读写都同步，会造成一定的性能压力</li>
<li>会存在个别bug</li>
</ul>
</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><img src="/2021/12/01/Redis/RDB%20VS%20AOF-3126d234520f48c8a2e134ee0e571aaa.png" class="" title="RDB VS AOF.png">

<ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li>
</ul>
</li>
</ul>
<h1 id="04主从库实现数据一致"><a href="#04主从库实现数据一致" class="headerlink" title="04主从库实现数据一致"></a>04主从库实现数据一致</h1><p>Redis 具有高可靠性，又是什么意思呢？其实，这里有两层含义：一是数据尽量少丢失，二是服务尽量少中断。AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是<strong>增加副本冗余量</strong>，将一份数据同时保存在多个实例上。Redis 提供了主从库模式，以保证数据副本的一致，<strong>主从库之间采用的是读写分离的方式</strong>。<br><strong>读操作</strong>：主库、从库都可以接收；<br><strong>写操作</strong>：首先到主库执行，然后，主库将写操作同步给从库。</p>
<h2 id="主从库间如何进行第一次同步"><a href="#主从库间如何进行第一次同步" class="headerlink" title="主从库间如何进行第一次同步"></a>主从库间如何进行第一次同步</h2><p>启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<img src="/2021/12/01/Redis/%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B.png" class="" title="主从库第一次同步的流程">
<p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。<strong>在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了</strong>。<br>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</p>
<p>主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。<strong>FULLRESYNC 响应表示第一次复制采用的全量复制</strong>，也就是说，主库会把当前所有的数据都复制给从库。</p>
<p>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录RDB 文件生成后收到的所有写操作。</p>
<p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。</p>
<h2 id="主从级联模式分担全量复制时的主库压力"><a href="#主从级联模式分担全量复制时的主库压力" class="headerlink" title="主从级联模式分担全量复制时的主库压力"></a>主从级联模式分担全量复制时的主库压力</h2><p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</p>
<p><strong>可以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。</p>
<img src="/2021/12/01/Redis/%E7%BA%A7%E8%81%94%E7%9A%84%E2%80%9C%E4%B8%BB-%E4%BB%8E-%E4%BB%8E%E2%80%9D%E6%A8%A1%E5%BC%8F.png" class="" title="级联的“主-从-从”模式">

<p>一旦主从库完成了全量复制，<strong>它们之间就会一直维护一个网络连接</strong>，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p>
<h2 id="主从库间网络断了怎么办"><a href="#主从库间网络断了怎么办" class="headerlink" title="主从库间网络断了怎么办"></a>主从库间网络断了怎么办</h2><p>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。当主从库断连后，主库会把断连期间收到的写操作命令，写入repl_backlog_buffer 这个缓冲区。repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p>
<img src="/2021/12/01/Redis/Redis%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.png" class="" title="Redis增量复制流程">
<p>因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。<strong>如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致</strong>。针对这种情况，可以调整缓冲区大小来解决。</p>
<h1 id="05哨兵机制"><a href="#05哨兵机制" class="headerlink" title="05哨兵机制"></a>05哨兵机制</h1><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p>
<p><strong>作用</strong>：</p>
<ol>
<li>监控：不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li>
<li>通知：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知</li>
<li>选主：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ol>
<p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始<strong>自动切换主库</strong>的流程。</p>
<p>主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</p>
<p>然后，哨兵会执行最后一个任务：通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</p>
<h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</p>
<p>通常会采用多实例组成的集群模式进行部署，这也被称为<strong>哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误<br>判率也能降低（少数服从多数）。</p>
<p>哨兵也是一台redis服务器，只是不提供数据服务 <strong>通常哨兵配置数量为单数</strong></p>
<h2 id="选定新主库"><a href="#选定新主库" class="headerlink" title="选定新主库"></a>选定新主库</h2><p>在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库。</p>
<p><strong>在选主时，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态</strong>，如果断连次数多，那么它就不符合筛选条件。</p>
<p>初步筛选过后还要按照三个规则依次进行三轮打分，<strong>这三个规则分别是从库优先级、从库复制进度以及从库 ID 号</strong>。<br>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p>
<h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作。在配置哨兵的信息时，只需要设置主库的 IP 和端口，并没有配置其他哨兵的连接信息。配置时并没有单独维护哨兵集群的关联关系，它们之间通过特殊的机制来实现<strong>自动发现并组成集群</strong>。</p>
<h3 id="基于-pub-x2F-sub-机制的哨兵集群"><a href="#基于-pub-x2F-sub-机制的哨兵集群" class="headerlink" title="基于 pub&#x2F;sub 机制的哨兵集群"></a>基于 pub&#x2F;sub 机制的哨兵集群</h3><p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。<strong>当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口</strong>。</p>
<p><strong>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</strong></p>
<p>哨兵向主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。</p>
<p>从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub&#x2F;sub 机制，客户端可以从哨兵订阅消息。<strong>哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件</strong>。有了这些事件通知，客户端不仅可以在主从切换后得到新主库的连接信息，还可以监控到主从库切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p>
<h3 id="由哪个哨兵执行主从切换"><a href="#由哪个哨兵执行主从切换" class="headerlink" title="由哪个哨兵执行主从切换"></a>由哪个哨兵执行主从切换</h3><p>确定由哪个哨兵执行主从切换的过程，和主库“客观下线”的判断过程类似，也是一<br>个“投票仲裁”的过程。任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-downby-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应。</p>
<p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。</p>
<p>在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的Leader赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</p>
<h1 id="06切片集群"><a href="#06切片集群" class="headerlink" title="06切片集群"></a>06切片集群</h1><p>在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的<strong>数据量是正相关</strong>的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。因此大容量的单实例 redis 无法快速响应请求，需要把每台机器的内存切割变小，这样 fork 的数据也会变小，阻塞的时间也会变短。</p>
<p><strong>切片集群</strong>，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p>
<p>Redis 应对数据量增多有两种方案：<strong>纵向扩展和横向扩展</strong>。<br><strong>纵向扩展</strong>：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。但是这种升级总会<strong>受到硬件条件的制约</strong>，最终会碰到瓶颈，不过好处是简单。<br><strong>横向扩展</strong>：横向增加当前 Redis 实例的个数。</p>
<h2 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h2><img src="Redis/image-20240330105354150.png" alt="image-20240330105354150" style="zoom:50%;" />

<p>切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。从 Redis3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。</p>
<p>Redis Cluster 方案采用哈希槽来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。所有实例均分这些哈希槽，通过哈希槽，切片集群就实现了数据到哈希槽、哈希槽再到实例的分配。<u><strong>Redis 自动分配的方案是按照实例进行均分，如果不同实例配置不同，那么不同实例承受的数据压力就不一样，这种情况在可以手动执行命令进行自定义分配，手动分配时需要把16384个哈希槽全部分配</strong></u>。</p>
<p>每次操作一个数据时，客户端根据 key 计算出在哪个哈希槽，接下来需要知道哈希槽对应的实例是哪个。一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端，因此客户端拥有所有连接的实例的分配信息。但是在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，并不知道其他实例拥有的哈希槽信息。</p>
<p>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成<strong>哈希槽分配信息的扩散</strong>。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。此时客户端访问任何一个实例时，都能获得所有的哈希槽信息。</p>
<p>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p>
<ol>
<li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li>
<li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li>
</ol>
<p>实例之间可以通过相互传递消息，获得最新的哈希槽分配信息，但是客户端是无法主动感知这些变化的。因此Redis Cluster 方案提供了一种<strong>重定向</strong>机制，就是指客户端给一个实例发送数据读写操作时，如果这个实例上并没有相应的数据，实例会告诉客户端要再给正确的新实例发送操作命令。此时客户端会更新本地缓存，后续都会定位到正确的新实例。</p>
<p>哈希槽的转移过程需要耗费一定时间，如果哈希槽正在从实例 1 转移到实例 2 的过程中，实例 1 收到了客户端的查询 key1 请求，key 1 如果仍然在实例 1 则返回结果 value1 给客户端；</p>
<table>
<thead>
<tr>
<th>键值对</th>
<th>转移是否成功</th>
<th>查询实例 1</th>
<th>是否更新客户端本地缓存</th>
</tr>
</thead>
<tbody><tr>
<td>k1，v1</td>
<td>否</td>
<td>返回 v1</td>
<td>否</td>
</tr>
<tr>
<td>K2，v2</td>
<td>是</td>
<td>返回重定向地址</td>
<td>否</td>
</tr>
</tbody></table>
<h1 id="07消息队列"><a href="#07消息队列" class="headerlink" title="07消息队列"></a>07消息队列</h1><h2 id="消息队列的消息存取需求"><a href="#消息队列的消息存取需求" class="headerlink" title="消息队列的消息存取需求"></a>消息队列的消息存取需求</h2><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<ol>
<li>消息保序: 虽然消费者是异步处理消息，但是，消费者仍然需要<strong>按照生产者发送消息的顺序来处理消息</strong>，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。</li>
<li>重复消息处理: 消费者从消息队列读取消息时，有时会因为<strong>网络堵塞而出现消息重传</strong>的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</li>
<li>消息可靠性保证: 消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证</li>
</ol>
<h2 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h2><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>BRPOP 命令也称为<strong>阻塞式读取</strong>，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</p>
<p><strong>消费者程序本身能对重复消息进行判断</strong>。一方面，消息队列要能给每一个消提供全局唯一的 ID 号；另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。这种处理特性也称为幂等性，<strong>幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的</strong>。</p>
<p>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份(List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从<strong>备份 List</strong>中重新读取消息并进行处理了。</p>
<p>如果生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。但是，List 类型并不支持消费群组的实现</p>
<h2 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h2><p>Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令：</p>
<ul>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>
<li>XREADGROUP：按消费组形式读取消息；</li>
<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>
</ul>
<h1 id="08影响Redis性能的因素"><a href="#08影响Redis性能的因素" class="headerlink" title="08影响Redis性能的因素"></a>08影响Redis性能的因素</h1><h2 id="Redis-内部的阻塞式操作"><a href="#Redis-内部的阻塞式操作" class="headerlink" title="Redis 内部的阻塞式操作"></a>Redis 内部的阻塞式操作</h2><img src="/2021/12/01/Redis/redis%E9%98%BB%E5%A1%9E%E7%82%B9.png" class="" title="redis阻塞点">
<h3 id="和客户端交互时的阻塞点"><a href="#和客户端交互时的阻塞点" class="headerlink" title="和客户端交互时的阻塞点"></a>和客户端交互时的阻塞点</h3><p>网络 IO 有时候会比较慢，但是 Redis 使用了 IO 多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络 IO 不是导致 Redis 阻塞的因素。</p>
<p>键值对的增删改查操作是 Redis 和客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 Redis。</p>
<p>Redis 中涉及集合的操作复杂度通常为 O(N)，我们要在使用时重视起来。例如集合元素全量查询操作 HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的第一个阻塞点：<strong>集合全量查询和聚合操作</strong>。</p>
<p>除此之外，集合自身的删除操作同样也有潜在的阻塞风险。删除操作的本质是要释放键值对占用的内存空间。释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，<strong>如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞</strong>。</p>
<p>在 Redis 的数据库级别操作中，清空数据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。所以，这就是 Redis <strong>的第三个阻塞点：清空数据库</strong>。</p>
<h3 id="和磁盘交互时的阻塞点"><a href="#和磁盘交互时的阻塞点" class="headerlink" title="和磁盘交互时的阻塞点"></a>和磁盘交互时的阻塞点</h3><p>Redis 开发者早已认识到磁盘 IO 会带来阻塞，所以就把 Redis 进一步设计为采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。</p>
<p>如果有大量的写操作需要记录在 AOF 日志中，并同步写回的话，就会阻塞主线程了。这就得到了 Redis 的第四个阻塞点了：<strong>AOF 日志同步写</strong>。</p>
<h3 id="主从节点交互时的阻塞点"><a href="#主从节点交互时的阻塞点" class="headerlink" title="主从节点交互时的阻塞点"></a>主从节点交互时的阻塞点</h3><p>在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上了第三个阻塞点。</p>
<p>此外，从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢，所以，<strong>加载 RDB 文件就成为了 Redis 的第五个阻塞点</strong>。</p>
<h3 id="切片集群实例交互时的阻塞点"><a href="#切片集群实例交互时的阻塞点" class="headerlink" title="切片集群实例交互时的阻塞点"></a>切片集群实例交互时的阻塞点</h3><p>最后，当部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。</p>
<h3 id="异步执行阻塞点"><a href="#异步执行阻塞点" class="headerlink" title="异步执行阻塞点"></a>异步执行阻塞点</h3><p>Redis内部的五大阻塞点：</p>
<ol>
<li>集合全量查询和聚合操作；</li>
<li>bigkey 删除；</li>
<li>清空数据库；</li>
<li>AOF 日志同步写；</li>
<li>从库加载 RDB 文件。</li>
</ol>
<p>为了避免阻塞式操作，Redis 提供了异步线程机制。对于 Redis 来说，读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。而 Redis 的第一个阻塞点“集合全量查询和聚合操作”都涉及到了读操作，所以，它们是不能进行异步操作了。</p>
<p>删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。第二个阻塞点“bigkey 删除”，和第三个阻塞点“清空数据库”，都是对数据做删除，并不在关键路径上。因此可以使用后台子线程来异步执行删除操作。</p>
<p>对于第四个阻塞点“AOF 日志同步写”来说，为了保证数据可靠性，Redis 实例需要保证AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以，我们也可以启动一个子线程来执行 AOF 日志的同步写，而不用让主线程等待 AOF 日志的写完成。</p>
<p>第五个阻塞点“从库加载 RDB 文件”，从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作，必须让从库的主线程来执行。</p>
<p><strong>异步的子线程机制</strong></p>
<p>主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。</p>
<p>但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此把这种异步删除也称为惰性删除，此时删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。</p>
<h2 id="CPU-和-NUMA-架构的影响"><a href="#CPU-和-NUMA-架构的影响" class="headerlink" title="CPU 和 NUMA 架构的影响"></a>CPU 和 NUMA 架构的影响</h2><p>在多 CPU 架构上，应用程序可以在不同的处理器上运行。如果应用程序先在一个处理器上运行，并且把数据保存到了内存，然后被调度到另一个处理器上运行，此时应用程序再进行内存访问，就需要访问之前处理器上连接的内存，这种访问属于<strong>远端内存访问。和访问处理器直接连接的内存相比，远端内存访问会增加应用程序的延迟</strong>。</p>
<p>如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，那么，对Redis 实例的请求处理时间影响就更大了。<strong>每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求</strong>。为了避免 Redis 总是在不同 CPU 核上来回调度执行，可以尝试 Redis实例和 CPU 核绑定的方法。</p>
<p><strong>绑核的风险和解决方案</strong></p>
<p>Redis 除了主线程以外，还有用于 RDB 生成和 AOF 重写的子进程，把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致Redis 请求延迟增加。<br>解决方法：一个 Redis 实例对应绑一个物理核（两个逻辑核）</p>
<h2 id="Redis-关键系统配置"><a href="#Redis-关键系统配置" class="headerlink" title="Redis 关键系统配置"></a>Redis 关键系统配置</h2><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><p>慢查询命令，就是指在 Redis 中执行速度慢的命令，这会导致 Redis 延迟增加Redis 提供的命令操作很多，并不是所有命令都慢，这和命令操作的复杂度有关。</p>
<p>比如说，Value 类型为 String 时，GET&#x2F;SET 操作主要就是操作 Redis 的哈希表索引。这个操作复杂度基本是固定的，即 O(1)。但是，当 Value 类型为 Set 时，SORT、SUNION&#x2F;SMEMBERS 操作复杂度分别为 O(N+M*log(M)) 和 O(N)。其中，N 为 Set 中的元素个数，M 为 SORT 操作返回的元素个数。这个复杂度就增加了很多。</p>
<p>解决方法：</p>
<ol>
<li>用其他高效命令代替。</li>
<li>需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</li>
</ol>
<h3 id="过期key操作"><a href="#过期key操作" class="headerlink" title="过期key操作"></a>过期key操作</h3><p>过期 key 的自动删除机制是 Redis 用来回收内存空间的常用机制，应用广泛，本身就会引起 Redis 操作阻塞，导致性能变慢，Redis 键值对的 key 可以设置过期间。默认情况下，Redis 每 100 毫秒会删除一些过期key，具体的算法如下：</p>
<ol>
<li>采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的key 全部删除；</li>
<li>如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</li>
</ol>
<p>删除操作是阻塞的，如果触发第二条连坐机制，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。<strong>因此要避免key设置相同的过期时间</strong>，以免同时过期造成巨大压力。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Redis 会持久化保存数据到磁盘，这个过程要依赖文件系统来完成，所以，文件系统将数据写回磁盘的机制，会直接影响到 Redis 持久化的效率。而且，在持久化的过程中，Redis也还在接收其他请求，持久化的效率高低又会影响到 Redis 处理请求的性能。</p>
<p>AOF日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 <strong>fsync 需要把日志记录写回到磁盘后才能返回，时间较长</strong>。</p>
<p>在使用 everysec 时，Redis 允许丢失一秒的操作记录，所以，Redis 主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync 的执行时间很长，如果是在 Redis 主线程中执行 fsync，就容易阻塞主线程。所以，当写回策略配置为 everysec 时，Redis 会使用后台的<strong>子线程异步完成 fsync 的操作</strong>。</p>
<p>而对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略的要求了。<strong>所以，always 策略并不使用后台子线程来执行</strong>。</p>
<p>AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，<strong>主线程会监控 子线程 fsync 的执行进度</strong>。当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，<strong>如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞</strong>。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。</p>
<img src="/2021/12/01/Redis/fsync%E5%90%8E%E5%8F%B0%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%85%B3%E7%B3%BB.png" class="" title="fsync后台子线程和主线程关系">

<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Redis 是内存数据库，内存操作非常频繁，所以，操作系统的内存机制会直接影响到 Redis 的处理效率。比如说，如果 Redis 的内存不够用了，操作系统会启动 swap机制，正常情况下，Redis 的操作是直接通过访问内存就能完成，一旦 swap 被触发了，Redis 的请求操作需要等到磁盘数据读写完成才行。这就会直接拖慢 Redis。</p>
<p>通常，触发 swap 的原因主要是物理机器内存不足，对于 Redis 而言，有两种常见的情况：</p>
<ol>
<li>Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足；</li>
<li>和 Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。</li>
</ol>
<p>解决方法：<strong>增加机器的内存或者使用 Redis 集群</strong>。</p>
<hr>
<p>除了内存 swap，还有一个和内存相关的因素，即内存大页机制，也会影响 Redis 性能。虽然内存大页可以给 Redis 带来内存分配方面的收益，但是，Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以以此时，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。<strong>当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝</strong>，这就会影响Redis 正常的访存操作，最终导致性能变慢。</p>
<h2 id="Redis-内存碎片"><a href="#Redis-内存碎片" class="headerlink" title="Redis 内存碎片"></a>Redis 内存碎片</h2><p>当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存，但是这往往会伴随一个潜在的风险点：Redis 释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。这就会导致一个问题：<strong>虽然有空闲空间，Redis 却无法用来保存数据</strong>，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。</p>
<p>内存碎片的形成有内因和外因两个层面的原因。<strong>内因是操作系统的内存分配机制，外因是 Redis 的负载特征。</strong></p>
<p>内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p>
<p>Redis键值对会被修改和删除，这会导致空间的扩容和释放。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p>
<p>解决方法：Redis 自身提供了一种内存碎片自动清理的方法。自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对Redis 内存使用效率的影响，还考虑了清理机制本身的 CPU 时间占比、对 Redis 性能的影响。而且，清理机制还提供了 4 个参数，让我们可以根据实际应用中的数据量需求和性能要求灵活使用</p>
<h2 id="Redis-缓冲区"><a href="#Redis-缓冲区" class="headerlink" title="Redis 缓冲区"></a>Redis 缓冲区</h2><p>缓冲区的功能很简单，主要就是用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题。但因为缓冲区的内存空间有限，如果往里面写入数据的速度持续地大于从里面读取数据的速度，就会导致缓冲区需要越来越多的内存来暂存数据。当缓冲区占用的内存超出了设定的上限阈值时，就会出现缓冲区溢出。</p>
<h3 id="客户端输入和输出缓冲区"><a href="#客户端输入和输出缓冲区" class="headerlink" title="客户端输入和输出缓冲区"></a>客户端输入和输出缓冲区</h3><p>为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区。</p>
<img src="/2021/12/01/Redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.png" class="" title="客户端输入和输出缓冲区">

<p>可能导致发生溢出的原因：</p>
<ol>
<li>写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据；</li>
<li>服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。</li>
</ol>
<p>Redis 并没有提供参数调节客户端输入缓冲区的大小。<strong>如果要避免输入缓冲区溢出</strong>，那就只能从数据命令的发送和处理速度入手，也就是避免客户端写入 bigkey，以及避免 Redis 主线程阻塞。</p>
<p>应对输出缓冲区溢出：</p>
<ol>
<li>避免 bigkey 操作返回大量数据结果；</li>
<li>避免在线上环境中持续使用 MONITOR 命令；</li>
<li>设置合理的缓冲区大小上限，或是缓冲区连续写入时间和写入量上限。</li>
</ol>
<h3 id="主从集群中的缓冲区"><a href="#主从集群中的缓冲区" class="headerlink" title="主从集群中的缓冲区"></a>主从集群中的缓冲区</h3><h4 id="复制缓冲区的溢出问题"><a href="#复制缓冲区的溢出问题" class="headerlink" title="复制缓冲区的溢出问题"></a>复制缓冲区的溢出问题</h4><p>在<strong>全量复制</strong>过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。<strong>主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步</strong>。</p>
<p>如果在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。</p>
<p>为了避免复制缓冲区累积过多命令造成溢出，引发全量复制失败，可以控制主节点保存的数据量大小，并设置合理的复制缓冲区大小。同时需要控制从节点的数量，来避免主节点中复制缓冲区占用过多内存的问题。</p>
<h4 id="复制积压缓冲区的溢出问题"><a href="#复制积压缓冲区的溢出问题" class="headerlink" title="复制积压缓冲区的溢出问题"></a>复制积压缓冲区的溢出问题</h4><p><strong>增量复制</strong>时使用的缓冲区称为复制积压缓冲区。复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</p>
<h1 id="09内存淘汰机制"><a href="#09内存淘汰机制" class="headerlink" title="09内存淘汰机制"></a>09内存淘汰机制</h1><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>常用的过期数据的删除策略:</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除**</li>
<li><strong>定期删除</strong> ：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
<li><strong>定时删除</strong>：创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作(不会全部key都检查)。CPU压力很大，用处理器性能换取存储空间</li>
</ol>
<p>数据淘汰策略:</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<blockquote>
<p>使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置</p>
</blockquote>
<h2 id="处理淘汰的数据"><a href="#处理淘汰的数据" class="headerlink" title="处理淘汰的数据"></a>处理淘汰的数据</h2><p>一般来说，一旦被淘汰的数据选定后，如果这个数据是干净数据，那么就直接删除；如果这个数据是脏数据，则需要把它写回数据库。</p>
<p>干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p>
<h1 id="10缓存使用"><a href="#10缓存使用" class="headerlink" title="10缓存使用"></a>10缓存使用</h1><h2 id="缓存和数据库的数据不一致"><a href="#缓存和数据库的数据不一致" class="headerlink" title="缓存和数据库的数据不一致"></a>缓存和数据库的数据不一致</h2><p>根据是否接收写请求，可以把缓存分成读写缓存和只读缓存。对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的<strong>写回策略</strong>，决定是否同步写回到数据库中。</p>
<ul>
<li>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>
<li>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么此时，数据库就没有最新的数据了。</li>
</ul>
<p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作<strong>如果无法保证原子性，就会出现数据不一致问题</strong>。</p>
<p>更新数据库和删除缓存值的过程中，其中一个操作失败的解决办法：可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，就把这些值从消息队列中去除，以免重复操作。</p>
<p>即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据。按照不同的删除和更新顺序，分成两种情况：</p>
<h3 id="情况一：先删除缓存，再更新数据库"><a href="#情况一：先删除缓存，再更新数据库" class="headerlink" title="情况一：先删除缓存，再更新数据库"></a>情况一：先删除缓存，再更新数据库</h3><p>假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</p>
<ol>
<li>线程 B 读取到了旧值；</li>
<li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。</li>
</ol>
<p>等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。</p>
<p>解决：<strong>在线程 A 更新完数据库值以后，让它先 sleep 一小段时间，再进行一次缓存删除操作</strong>。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以也把它叫做“延迟双删”。</p>
<h3 id="情况二：先更新数据库值，再删除缓存值"><a href="#情况二：先更新数据库值，再删除缓存值" class="headerlink" title="情况二：先更新数据库值，再删除缓存值"></a>情况二：先更新数据库值，再删除缓存值</h3><p>如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。</p>
<p>优先使用先更新数据库再删除缓存的方法。</p>
<h1 id="11缓存异常"><a href="#11缓存异常" class="headerlink" title="11缓存异常"></a>11缓存异常</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>
<p><strong>原因一：缓存中有大量数据同时过期，导致大量请求无法得到处理</strong>。<br>解决办法：</p>
<ol>
<li>避免给大量的数据设置相同的过期时间。如果业务层的确要求有些数据同时失效，可以在用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数），这样一来，不同数据的过期时间有所差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。</li>
<li>除了微调过期时间，可以通过服务降级来应对缓存雪崩。所谓的服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式。非核心数据直接返回预定义信息、空值或是错误信息；核心数据继续通过数据库读取。</li>
</ol>
<p><strong>原因二：Redis缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。</strong><br>解决办法：</p>
<ol>
<li>在业务系统中实现服务熔断或请求限流机制。</li>
<li>通过主从节点的方式构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效</p>
<p>解决办法：对于访问特别频繁的热点数据，不设置过期时间</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。</p>
<p>发生原因：</p>
<ol>
<li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；</li>
<li>恶意攻击：专门访问数据库中没有的数据</li>
</ol>
<p>解决办法：</p>
<ol>
<li>缓存空值或缺省值。</li>
<li>使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力</li>
<li>在请求入口的前端进行请求检测，直接过滤掉非法请求</li>
</ol>
<h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。缓存污染一旦变得严重后，就会有大量不再访问的数据滞留在缓存中。如果这时数据占满了缓存空间，再往缓存中写入新数据时，就需要先把这些数据逐步淘汰出缓存，这就会引入额外的操作时间开销，进而会影响应用的性能。</p>
<p><strong>因为只看数据的访问时间，使用 LRU 策略在处理扫描式单次查询操作时，无法解决缓存污染</strong>。所谓的扫描式单次查询操作，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次。此时，因为这些被查询的数据刚刚被访问过，所以 lru 字段值都很大。对于采用了 LRU 策略的 Redis 缓存来说，扫描式单次查询会造成缓存污染。为了应对这类缓存污染问题，Redis 从 4.0 版本开始增加了 LFU 淘汰策略。</p>
<p>LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。<strong>在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。</strong></p>
<h1 id="12Redis如何应对并发访问"><a href="#12Redis如何应对并发访问" class="headerlink" title="12Redis如何应对并发访问"></a>12Redis如何应对并发访问</h1><p>为了保证并发访问的正确性，Redis 提供了两种方法，分别是<strong>加锁和原子操作</strong>。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是一种提供并发访问控制的方法。原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：</p>
<ol>
<li>把多个操作在 Redis 中实现成一个操作，也就是单命令操作；</li>
<li>把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。</li>
</ol>
<p>Redis 提供了 INCR&#x2F;DECR 命令，把这三个操作转变为一个原子操作了。INCR&#x2F;DECR 命令可以对数据进行增值 &#x2F; 减值操作，而且它们本身就是单个命令操作，Redis 在执行它们时，本身就具有互斥性。如果执行更加复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了。</p>
<p>Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。如果有多个操作要执行，但是又无法用INCR&#x2F;DECR 这种命令操作来实现，就可以把这些要执行的操作编写到一个 Lua 脚本中。然后就可以使用 Redis 的 EVAL 命令来执行脚本。这样一来，这些操作在执行时就具有了互斥性。</p>
<p><strong>在编写 Lua脚本时，要避免把不需要做并发控制的操作写入脚本中</strong>。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="单机上的锁和分布式锁的联系与区别"><a href="#单机上的锁和分布式锁的联系与区别" class="headerlink" title="单机上的锁和分布式锁的联系与区别"></a>单机上的锁和分布式锁的联系与区别</h3><p>对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。和单机上的锁类似，分布式锁同样可以用一个变量来实现。客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：<strong>加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为 0，表明客户端不再持有锁</strong>。</p>
<p>但是，和线程在单机上操作锁不同的是，在分布式场景下，<strong>锁变量需要由一个共享存储系统来维护</strong>，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值。因此，分布式锁具有两个要求：</p>
<ol>
<li>分布式锁的加锁和释放锁的过程，涉及多个操作。所以在实现分布式锁时，需要保证这些锁操作的原子性；</li>
<li>共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。</li>
</ol>
<h3 id="基于单个-Redis-节点实现分布式锁"><a href="#基于单个-Redis-节点实现分布式锁" class="headerlink" title="基于单个 Redis 节点实现分布式锁"></a>基于单个 Redis 节点实现分布式锁</h3><p>Redis 可以使用键值对来保存锁变量，再接收和处理不同客户端发送的加锁和释放锁的操作请求。</p>
<img src="/2021/12/01/Redis/redis_lock_alone.png" class="" title="redis_lock_alone">
<p>在图中，客户端 A 和 C 同时请求加锁。因为 Redis 使用单线程处理请求，所以，即使客户端 A 和 C 同时把加锁请求发给了 Redis，Redis 也会串行处理它们的请求。</p>
<p>在基于单个 Redis 实例实现分布式锁时，对于加锁操作需要满足三个条件：</p>
<ol>
<li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以使用 SET 命令带上 NX 选项来实现加锁；</li>
<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li>
<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</li>
</ol>
<p>单机的分布式锁会有宕机风险。</p>
<h3 id="基于多个-Redis-节点实现高可靠的分布式锁"><a href="#基于多个-Redis-节点实现高可靠的分布式锁" class="headerlink" title="基于多个 Redis 节点实现高可靠的分布式锁"></a>基于多个 Redis 节点实现高可靠的分布式锁</h3><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。<br>执行步骤：</p>
<ol>
<li>客户端获取当前时间</li>
<li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</li>
<li>一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</li>
</ol>
<p>客户端只有在满足下面的这两个条件时，才能认为是加锁成功：</p>
<ol>
<li>客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 实例上成功获取到了锁；</li>
<li>客户端获取锁的总耗时没有超过锁的有效时间。</li>
</ol>
<p>在满足了这两个条件后，需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有 Redis 节点发起释放锁的操作。</p>
<h1 id="13Redis事务"><a href="#13Redis事务" class="headerlink" title="13Redis事务"></a>13Redis事务</h1><p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span><br><span class="line">multi</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>终止当前事务的定义，发生在multi之后，<span class="keyword">exec</span>之前</span><br><span class="line">discard</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</span><br><span class="line"><span class="keyword">exec</span></span><br></pre></td></tr></table></figure>
<p>原子性：</p>
<ul>
<li>命令入队时就报错，会放弃事务执行，保证原子性；</li>
<li>命令入队时没报错，实际执行时报错，不保证原子性；</li>
<li>EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。</li>
</ul>
<p>一致性：在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性属性是有保证的</p>
<p>隔离性：</p>
<ul>
<li>并发操作在 EXEC 命令前执行，此时，<strong>隔离性的保证要使用 WATCH 机制来实现</strong>，否则隔离性无法保证；</li>
<li>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。<blockquote>
<p>WATCH 机制的作用：在事务执行前，监控一个或多个键的值变化情况，当事务调用EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。</p>
</blockquote>
</li>
</ul>
<p>持久性：数据是否持久化保存完全取决于 Redis 的持久化配置模式。不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。<strong>RDB不会在事务执行的时候执行</strong></p>
<h1 id="14主从同步与故障切换"><a href="#14主从同步与故障切换" class="headerlink" title="14主从同步与故障切换"></a>14主从同步与故障切换</h1><h2 id="主从数据不一致"><a href="#主从数据不一致" class="headerlink" title="主从数据不一致"></a>主从数据不一致</h2><p>出现原因是因为主从库间的命令复制是异步进行的。具体来说，在主从库命令传播阶段，库收到新的写命令后，会发送给从库。但是，主库并不会等到从库实际执行完命令后，再把结果返回给客户端，而是主库自己在本地执行完命令后，就会向客户端返回结果了。如果从库还没有执行主库同步过来的命令，主从库间的数据就不一致了。</p>
<ul>
<li>一方面，主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。</li>
<li>另一方面，即使从库及时收到了主库的命令，但是，也可能会因为正在处理其它复杂度高的命令（例如集合操作命令）而阻塞。此时，从库需要处理完当前的命令，才能执行主库发送的命令操作，这就会造成主从数据不一致。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>在硬件环境配置方面，尽量保证主从库间的网络连接状况良好。</li>
<li>监控主从库间的复制进度。如果某个从库的进度差值大于预设的阈值，就让客户端不再和这个从库连接进行数据读取，这样就可以减少读到不一致数据的情况。</li>
</ul>
<h2 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h2><p><strong>Redis 同时使用了两种策略来删除过期的数据，分别是惰性删除策略和定期删除策略</strong>。</p>
<p>惰性删除策略实现后，数据只有被再次访问时，才会被实际删除。如果客户端从主库上读取留存的过期数据，主库会触发删除操作，此时，客户端并不会读到过期数据。但是，从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。在 3.2 版本后，Redis做了改进，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值，这就避免了客户端读到过期数据。<strong>在应用主从集群时，尽量使用 Redis 3.2 及以上版本</strong>。</p>
<p>但是有些命令给数据设置的过期时间<strong>在从库上可能会被延后</strong>，导致应该过期的数据又在从库上被读取到了。存在以下设置时间过期命令：</p>
<ul>
<li>EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；</li>
<li>EXPIREAT 和 PEXPIREAT：它们会直接把数据的过期时间设置为具体的一个时间点。</li>
</ul>
<p><strong>在业务应用中使用 EXPIREAT&#x2F;PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据</strong>。</p>
<h2 id="不合理配置项导致的服务挂掉"><a href="#不合理配置项导致的服务挂掉" class="headerlink" title="不合理配置项导致的服务挂掉"></a>不合理配置项导致的服务挂掉</h2><ul>
<li>protected-mode 配置项<br>这个配置项的作用是限定哨兵实例能否被其他服务器访问。当这个配置项设置为 yes 时，哨兵实例只能在部署的服务器本地进行访问。当设置为 no 时，其他服务器也可以访问这个哨兵实例。如果 protected-mode 被设置为 yes，而其余哨兵实例部署在其它服务器，那么，这些哨兵实例间就无法通信。当主库故障时，哨兵无法判断主库下线，也无法进行主从切换，最终 Redis 服务不可用。所以将 protected-mode 配置项设置为 no，并且将bind 配置项设置为其它哨兵实例的 IP 地址。这样一来，只有在 bind 中设置了 IP 地址的哨兵，才可以访问当前实例，既保证了实例间能够通信进行主从切换，也保证了哨兵的安全性。</li>
<li>cluster-node-timeout 配置项<br>这个配置项设置了 Redis Cluster 中实例响应心跳消息的超时时间。</li>
</ul>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p>
<ul>
<li>master心跳：<ul>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳：<ul>
<li>作用：汇报slave自己的复制偏移量，获取最新的数据变更指令；判断master是否在线</li>
</ul>
</li>
</ul>
<p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p>
<img src="/2021/12/01/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B-ee39fa69e19848a28fc9d79d5bd446a7.png" class="" title="主从复制完整流程.png">

<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>监控：不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li>
<li>通知：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知</li>
<li>自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
<p>哨兵也是一台redis服务器，只是不提供数据服务 通常哨兵配置数量为单数</p>
<h1 id="15脑裂"><a href="#15脑裂" class="headerlink" title="15脑裂"></a>15脑裂</h1><p>脑裂发生的原因主要是原主库发生了假故障，所谓的脑裂，就是指在主从集群中，<strong>同时有两个主节点</strong>，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。</p>
<h2 id="脑裂发生原因"><a href="#脑裂发生原因" class="headerlink" title="脑裂发生原因"></a>脑裂发生原因</h2><img src="/2021/12/01/Redis/%E8%84%91%E8%A3%82%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0.png" class="" title="脑裂发生原因">

<p>主从切换后，从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步。而在全量同步执行的最后阶段，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，这样一来，原主库在主从切换期间保存的新写数据就丢失了。</p>
<h2 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h2><p>问题是出在<strong>原主库发生假故障后仍然能接收请求上</strong></p>
<ul>
<li>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</li>
<li>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送ACK 消息的最大延迟（以秒为单位）</li>
</ul>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slavesmax-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端请求，客户端也就不能在原主库中写入新数据了。</p>
<p>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SQL 语法</title>
    <url>/2021/09/09/SQL%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL注释：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 注释<span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释2</span></span><br><span class="line"><span class="comment">/* 注释3</span></span><br><span class="line"><span class="comment">   注释3 */</span></span><br></pre></td></tr></table></figure>

<p>数据库创建与使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h2 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  # <span class="type">int</span> 类型，不为空，自增</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  # <span class="type">int</span> 类型，不可为空，默认值为 <span class="number">1</span>，不为空</span><br><span class="line">  col1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  # 变长字符串类型，最长为 <span class="number">45</span> 个字符，可以为空</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  # 日期类型，可为空</span><br><span class="line">  col3 <span class="type">DATE</span> <span class="keyword">NULL</span>,</span><br><span class="line">  # 设置主键为 id</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`));</span><br></pre></td></tr></table></figure>

<h2 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h2><p>添加列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>删除列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h2><p>普通插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入多行,每行用()表示</span></span><br><span class="line"><span class="comment">INSERT INTO mytable(col1, col2)</span></span><br><span class="line"><span class="comment">VALUES(11, &quot;val2&quot;),(22,&quot;test&quot;); */</span></span><br></pre></td></tr></table></figure>

<p>插入检索出来的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure>

<p>将一个表的内容插入到一个新表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> col <span class="operator">=</span> val</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>TRUNCATE TABLE</strong>   可以清空表，也就是删除所有行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。</p>
<h2 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h2><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<p>这里有两点需要注意：</p>
<ol>
<li>DISTINCT 需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</li>
<li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>返回第 3 ~ 5 行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h2><ul>
<li><strong>ASC</strong>  ：升序（默认）</li>
<li><strong>DESC</strong>  ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<ul>
<li>可以使用不在SELECT列表中的列排序。</li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">## <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> col1 <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&gt; !&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D; !&gt;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D; !&lt;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center">为 NULL 值</td>
</tr>
</tbody></table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong>   用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong>   操作符用于匹配一组值，其后用括号()接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="number">111</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col1 <span class="keyword">FROM</span> mytable);</span><br></pre></td></tr></table></figure>

<p><strong>NOT</strong>   操作符用于否定一个条件。</p>
<h2 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h2><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li><p><strong>%</strong>   匹配 &gt;&#x3D;0 个任意字符；</p>
</li>
<li><p><strong>_</strong>   匹配 &#x3D;&#x3D;1 个任意字符；</p>
</li>
<li><p><strong>[ ]</strong>   可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p>
</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;[^AB]%&#x27;</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure>

<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h2 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h2><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用   <strong>AS</strong>   来取别名，否则输出的时候字段名为计算表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="operator">*</span> col2 <span class="keyword">AS</span> alias</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<p><strong>CONCAT()</strong>   用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h2><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG()</td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center">COUNT()</td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center">MAX()</td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center">MIN()</td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center">SUM()</td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LEFT()</td>
<td align="center">左边的字符</td>
</tr>
<tr>
<td align="center">RIGHT()</td>
<td align="center">右边的字符</td>
</tr>
<tr>
<td align="center">LOWER()</td>
<td align="center">转换为小写字符</td>
</tr>
<tr>
<td align="center">UPPER()</td>
<td align="center">转换为大写字符</td>
</tr>
<tr>
<td align="center">LTRIM()</td>
<td align="center">去除左边的空格</td>
</tr>
<tr>
<td align="center">RTRIM()</td>
<td align="center">去除右边的空格</td>
</tr>
<tr>
<td align="center">LENGTH()</td>
<td align="center">长度</td>
</tr>
<tr>
<td align="center">SOUNDEX()</td>
<td align="center">转换为语音值</td>
</tr>
</tbody></table>
<p>其中，  <strong>SOUNDEX()</strong>   可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:&lt;zero-width space&gt;MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDDATE()</td>
<td align="center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center">ADDTIME()</td>
<td align="center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DAYOFWEEK()</td>
<td align="center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">NOW()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">TIME()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> NOW();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure>

<h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="center">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="center">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="center">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="center">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">随机数</td>
</tr>
</tbody></table>
<h2 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h2><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num;</span><br></pre></td></tr></table></figure>

<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><blockquote>
<p>MySQL 8.0以后支持</p>
</blockquote>
<p>聚合函数将来自多行的数据汇总到单个结果行中。</p>
<p><code>GROUP BY</code>可以把聚合函数应用到每个分组中，使用聚合函数可以减少返回数据的行数，增大查询效率。</p>
<p>窗口函数也对行的子集进行操作，<strong>但它们不会减少查询返回的行数</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    fiscal_year, </span><br><span class="line">    sales_employee,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> fiscal_year) total_sales</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    sales; </span><br></pre></td></tr></table></figure>



<h2 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h2><p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jim&quot;);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>自然连接(Natural join)是一种特殊的等值连接，要求两个关系表中进行比较的属性组必须是名称相同的属性组，并且在结果中把重复的属性列去掉（即：留下名称相同的属性组中的其中一组）</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h2 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h2><p>使用   <strong>UNION</strong>   来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(col1, col2) <span class="keyword">AS</span> concat_col, col3<span class="operator">*</span>col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 <span class="operator">=</span> val;</span><br></pre></td></tr></table></figure>

<h2 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="type">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="type">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y<span class="operator">*</span>y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(<span class="variable">@ret</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ret</span>;</span><br></pre></td></tr></table></figure>

<h2 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h2><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="type">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> 这个条件出现时，会执行 <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">open</span> mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            <span class="keyword">fetch</span> mycursor <span class="keyword">into</span> ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">close</span> mycursor;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure>

<h2 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h2><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure>

<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h2 id="二十一、事务管理"><a href="#二十一、事务管理" class="headerlink" title="二十一、事务管理"></a>二十一、事务管理</h2><p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>

<h2 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h2><p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(col <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>可以在排序、分组时指定校对：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure>

<h2 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h2><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建账户</strong>  </p>
<p>新创建的账户没有任何权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改账户名</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除账户</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>授予权限</strong>  </p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除权限</strong>  </p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>更改密码</strong>  </p>
<p>必须使用 Password() 函数进行加密。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser <span class="operator">=</span> Password(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2021/08/20/Spring%20Cloud%20Gateway/</url>
    <content><![CDATA[<h1 id="Gateway-简介"><a href="#Gateway-简介" class="headerlink" title="Gateway 简介"></a>Gateway 简介</h1><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等。</p>
<p>Spring Cloud Gateway 具有如下特性：</p>
<ul>
<li>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；</li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定 Predicate（断言）和 Filter（过滤器）；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成 Spring Cloud 服务发现功能；</li>
<li>易于编写的 Predicate（断言）和 Filter（过滤器）；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li>Route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；</li>
<li>Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；</li>
<li>Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li><p>引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.yml中进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: path_route #路由的ID</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;/user/&#123;id&#125; #匹配后路由地址</span><br><span class="line">          predicates: # 断言，路径相匹配的进行路由</span><br><span class="line">            - Path=/user/&#123;id&#125;</span><br><span class="line">          filters:</span><br><span class="line">            - StripPrefix=<span class="number">1</span> #去掉部分URL路径</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Route-Predicate-的使用"><a href="#Route-Predicate-的使用" class="headerlink" title="Route Predicate 的使用"></a>Route Predicate 的使用</h1><p>多个Route Predicate工厂可以进行组合，下面我们来介绍下一些常用的Route Predicate。</p>
<h2 id="Before-Route-Predicate"><a href="#Before-Route-Predicate" class="headerlink" title="Before Route Predicate"></a>Before Route Predicate</h2><p>在指定时间之后的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: before_route</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Before=<span class="number">2019</span>-09-24T16:<span class="number">30</span>:<span class="number">00</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<h2 id="Between-Route-Predicate"><a href="#Between-Route-Predicate" class="headerlink" title="Between Route Predicate"></a>Between Route Predicate</h2><p>在指定时间区间内的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: before_route</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Between=<span class="number">2019</span>-09-24T16:<span class="number">30</span>:<span class="number">00</span>+08:<span class="number">00</span>[Asia/Shanghai], <span class="number">2019</span>-09-25T16:<span class="number">30</span>:<span class="number">00</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<h2 id="Cookie-Route-Predicate"><a href="#Cookie-Route-Predicate" class="headerlink" title="Cookie Route Predicate"></a>Cookie Route Predicate</h2><p>带有指定Cookie的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: cookie_route</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Cookie=username,macro </span><br></pre></td></tr></table></figure>
<h2 id="Header-Route-Predicate"><a href="#Header-Route-Predicate" class="headerlink" title="Header Route Predicate"></a>Header Route Predicate</h2><p>带有指定请求头的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: $&#123;service-url.user-service&#125;</span><br><span class="line">        predicates:</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>
<h2 id="Host-Route-Predicate"><a href="#Host-Route-Predicate" class="headerlink" title="Host Route Predicate"></a>Host Route Predicate</h2><p>带有指定Host的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: host_route</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Host=**.macrozheng.com</span><br></pre></td></tr></table></figure>
<h2 id="Method-Route-Predicate"><a href="#Method-Route-Predicate" class="headerlink" title="Method Route Predicate"></a>Method Route Predicate</h2><p>发送指定方法的请求会匹配该路由。</p>
<h2 id="Path-Route-Predicate-常用"><a href="#Path-Route-Predicate-常用" class="headerlink" title="Path Route Predicate 常用"></a>Path Route Predicate 常用</h2><p>发送指定路径的请求会匹配该路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: path_route</span><br><span class="line">          uri: $&#123;service-url.user-service&#125;/user/&#123;id&#125;</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/user/&#123;id&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Query-Route-Predicate"><a href="#Query-Route-Predicate" class="headerlink" title="Query Route Predicate"></a>Query Route Predicate</h2><p>带指定查询参数的请求可以匹配该路由。</p>
<h2 id="RemoteAddr-Route-Predicate"><a href="#RemoteAddr-Route-Predicate" class="headerlink" title="RemoteAddr Route Predicate"></a>RemoteAddr Route Predicate</h2><p>从指定远程地址发起的请求可以匹配该路由。</p>
<h2 id="Weight-Route-Predicate"><a href="#Weight-Route-Predicate" class="headerlink" title="Weight Route Predicate"></a>Weight Route Predicate</h2><p>使用权重来路由相应请求，以下表示有80%的请求会被路由到localhost:8201，20%会被路由到localhost:8202。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: weight_high</span><br><span class="line">        uri: http:<span class="comment">//localhost:8201</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, <span class="number">8</span></span><br><span class="line">      - id: weight_low</span><br><span class="line">        uri: http:<span class="comment">//localhost:8202</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="Route-Filter-的使用"><a href="#Route-Filter-的使用" class="headerlink" title="Route Filter 的使用"></a>Route Filter 的使用</h1><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应</p>
<h2 id="AddRequestParameter-GatewayFilter"><a href="#AddRequestParameter-GatewayFilter" class="headerlink" title="AddRequestParameter GatewayFilter"></a>AddRequestParameter GatewayFilter</h2><p>给请求添加参数的过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: add_request_parameter_route</span><br><span class="line">          uri: http:<span class="comment">//localhost:8201</span></span><br><span class="line">          filters:</span><br><span class="line">            - AddRequestParameter=username, macro</span><br><span class="line">          predicates:</span><br><span class="line">            - Method=GET</span><br></pre></td></tr></table></figure>
<h2 id="StripPrefix-GatewayFilter"><a href="#StripPrefix-GatewayFilter" class="headerlink" title="StripPrefix GatewayFilter"></a>StripPrefix GatewayFilter</h2><p>对指定数量的路径前缀进行去除的过滤器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">strip_prefix_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8201</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user-service/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">StripPrefix=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上配置会把以&#x2F;user-service&#x2F;开头的请求的路径去除两位，通过curl工具使用以下命令进行测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:9201/user-service/a/user/1</span><br></pre></td></tr></table></figure>
<p>相当于发起该请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8201/user/1</span><br></pre></td></tr></table></figure>
<h2 id="PrefixPath-GatewayFilter"><a href="#PrefixPath-GatewayFilter" class="headerlink" title="PrefixPath GatewayFilter"></a>PrefixPath GatewayFilter</h2><p>与StripPrefix过滤器恰好相反，会对原有路径进行增加操作的过滤器。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">prefix_path_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8201</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PrefixPath=/user</span></span><br></pre></td></tr></table></figure>
<p>以上配置会对所有GET请求添加&#x2F;user路径前缀</p>
<h2 id="Hystrix-GatewayFilter"><a href="#Hystrix-GatewayFilter" class="headerlink" title="Hystrix GatewayFilter"></a>Hystrix GatewayFilter</h2><p>Hystrix 过滤器允许你将断路器功能添加到网关路由中，使你的服务免受级联故障的影响，并提供服务降级处理。<br><em><strong>TODO</strong></em></p>
<h2 id="RequestRateLimiter-GatewayFilter"><a href="#RequestRateLimiter-GatewayFilter" class="headerlink" title="RequestRateLimiter GatewayFilter"></a>RequestRateLimiter GatewayFilter</h2><p>RequestRateLimiter 过滤器可以用于限流，使用RateLimiter实现来确定是否允许当前请求继续进行，如果请求太大默认会返回HTTP 429-太多请求状态。<br><em><strong>TODO</strong></em></p>
<h1 id="结合注册中心使用"><a href="#结合注册中心使用" class="headerlink" title="结合注册中心使用"></a>结合注册中心使用</h1><p>在结合注册中心使用过滤器的时候，我们需要注意的是uri的协议为lb，这样才能启用Gateway的负载均衡功能。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#配置路由路径</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">mall-auth</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://mall-auth</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/mall-auth/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment">#去掉部分URL路径</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础</title>
    <url>/2021/06/24/Spring%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><p><a href="https://www.cnblogs.com/RudeCrab/p/14365296.html">到底为什么要用 IoC 和 AOP</a><br>IoC 解决了以下问题：</p>
<ol>
<li>创建了许多重复对象，造成大量资源浪费；</li>
<li>更换实现类需要改动多个地方；</li>
<li>创建和配置组件工作繁杂，给组件调用方带来极大不便。</li>
</ol>
<p>AOP 解决了以下问题：</p>
<ol>
<li>切面逻辑编写繁琐，有多少个业务方法就需要编写多少次。</li>
</ol>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<ol>
<li>BeanFactory:  IOC容器基本实现，是spring内部的使用接口，不提供给开发人员使用<ul>
<li>加载配置文件时不会创建对象，获取对象时采取创建对象。</li>
</ul>
</li>
<li>ApplicationContext：  BeanFactory的子接口，提供更多的功能。<ul>
<li>加载配置文件时候就会把对象创建</li>
</ul>
</li>
</ol>
<h3 id="Spring两种类型Bean"><a href="#Spring两种类型Bean" class="headerlink" title="Spring两种类型Bean"></a>Spring两种类型Bean</h3><ol>
<li>普通Bean<br>配置文件中定义bean类型就是返回类型</li>
<li>工厂Bean<br>配置文件中定义bean类型可以和返回类型不一样<br>(1)创建类，让这个类作为工厂bean，实现接口FactoryBean<br>(2)实现接口里的方法，在实现的方法中定义返回的bean类型</li>
</ol>
<h3 id="ioc操作Bean管理-xml方式"><a href="#ioc操作Bean管理-xml方式" class="headerlink" title="ioc操作Bean管理(xml方式)"></a>ioc操作Bean管理(xml方式)</h3><ol>
<li><p>概念</p>
<ul>
<li>Spring创建对象</li>
<li>Spring注入属性</li>
</ul>
</li>
<li><p>管理方式</p>
<ul>
<li><p>基于xml配置文件方式实现<br>1. 无参构造方法实例化<br>        <bean id="userDao" class="com.it.dao.impl.UserDaoImp" init-method="init" destroy-method="destory"></bean><br><br>2. 工厂静态方法实例化<br>        <bean id="userDao" class="com.it.factory.StaticFactory" factory-method="getUserDao"></bean><br>3. 工厂实例方法实例化<br>        <bean id="factory" class="com.it.factory.DynamicFactory"></bean><br>        <bean id="userDao" factory-bean="factory" factory-method="getUserDao"></bean><br>#### Bean的依赖注入分析<br>将对象的依赖关系交给spring来实现，简单地说，就是坐等框架把持久层对象传入业务层，而不用自己去获取。<br>1. Bean的依赖注入方式<br>* 构造方法<br>        <bean id="userService" class="com.it.service.impl.UserServiceImpl"><br>        <constructor-arg name="userDao" ref="userDao"></constructor-arg><br>        </bean><br>* set方法<br>        <bean id="userDao" class="com.it.dao.impl.UserDaoImp" scope="prototype"></bean><br>        <bean id="userService" class="com.it.service.impl.UserServiceImpl"><br>        <property name="userDao" ref="userDao"></property><br>        </bean><br>2. Bean的依赖注入数据类型<br>   * 普通数据类型<br>   * 引用数据类型<br>   * 集合数据类型<br>   * CDATA:<br>      <![CDATA[   特殊的符号或字符    ]]></p>
</li>
<li><p>基于注解方式实现</p>
</li>
</ul>
</li>
<li><p>Bean作用域<br>单实例或者多实例<br>scope标签： single或prototype，request或session<br>         <!--    single时  加载xml文件即创建对象
                           只要容器在 对象就一直在
                           销毁容器时，对象销毁--><br>         <!--    prototype时   getbean创建对象
                               使用就一直在--></p>
</li>
<li><p>Bean生命周期</p>
<ol>
<li>通过构造器创建Bean实例(无参数构造)</li>
<li>为bean的属性设置值和其他bean引用</li>
<li>把bean实例传递给bean后置处理器(接口：BeanPostProcessor)的方法postProcessBeforeInitialization</li>
<li>调用bean的初始化方法(需要配置初始化的方法)</li>
<li>把bean实例传递给bean后置处理器的方法postProcessAfterInitialization</li>
<li>bean可以使用了</li>
<li>当容器关闭时，调用bean的销毁方法(需要进行配置销毁的方法)</li>
<li>自动装配:根据指定装配规则(属性名称和属性类型)，spring自动将匹配的属性值进行注入<!--autowire="byName"配置自动装配
  autowire常用两个取值
 byName根据属性名称注入，注入值bean的id值和类属性名称一样
 byType根据属性注入
--></li>
</ol>
</li>
<li><p>外部属性文件</p>
<ol>
<li>直接配置数据库信息<br>(1)配置德鲁伊连接池<br>(2)导入jar包</li>
<li>引用外部属性文件配置数据库连接<br>(1)引入context名称空间    xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“<br>(2)spring配置文件使用标签引入外部属性文件   &lt;context:property-placeholder location&#x3D;”classpath:path”&#x2F;&gt;<br>(3)bean标签中加入             <bean id="dataSourse" class="com.alibaba.druid.pool.DruidDataSource">
  <property name="username" value="${username}"></property>
  </bean></li>
</ol>
</li>
</ol>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ol>
<li><p>Spring中针对Bean管理创建对象提供注解</p>
<ul>
<li>@Component</li>
<li>@Service</li>
<li>@Controller</li>
<li>@Repository<br>注意： 上述四个注解功能一样，但是用于不同位置</li>
</ul>
</li>
<li><p>基于注解方式实现对象创建</p>
<ol>
<li>引入依赖</li>
<li>开启组件扫描<br>&lt;context:component-scan base-package&#x3D;”com.zhujie”&gt;</context:component-scan></li>
<li>创建类，在类上添加对象注解<br>&#x2F;&#x2F;注解里面value值可以省略不写，<br>&#x2F;&#x2F;默认值是类名称，首字母小写<br>@Component(value &#x3D; “UserService”)   &#x2F;&#x2F;<bean id="UserService" class=""/></li>
</ol>
<ul>
<li><!--   use-default-filters="false"表实不使用默认filter，自己配置filter
       context:include-filter，设置扫描哪些内容
   -->
&lt;context:component-scan base-package&#x3D;”com.zhujie”&gt;</context:component-scan><br>&lt;context:component-scan base-package&#x3D;”com.zhujie” use-default-filters&#x3D;”false”&gt;<br>    &lt;context:include-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller”&#x2F;&gt;<br></context:component-scan></li>
<li><!--设置哪些内容不进行扫描-->
&lt;context:component-scan base-package&#x3D;”com.zhujie”&gt;</context:component-scan><br>&lt;context:component-scan base-package&#x3D;”com.zhujie”&gt;<br>    &lt;context:exclude-filter type&#x3D;”annotation” expression&#x3D;”org.springframework.stereotype.Controller”&#x2F;&gt;<br></context:component-scan></li>
</ul>
</li>
<li><p>基于注解方式实现属性注入</p>
<ul>
<li>@Autowired：根据属性类型进行自动装配</li>
<li>@Qualifier：根据属性名称进行注入（与第一个联合使用）</li>
<li>@Resourse：根据类型或名称注入</li>
<li>@Value：注入普通类型</li>
</ul>
</li>
<li><p>属性注入步骤</p>
<ol>
<li>创建对象</li>
<li>在需要注入的属性上添加Autowired注解</li>
</ol>
</li>
<li><p>完全注解开发<br>创建配置类，替代xml文件<br>   @Configuration  &#x2F;&#x2F;作为配置类，替代xml文件<br>   @ComponentScan(basePackages &#x3D; {“com.zhujie”})<br>   public class SpringConfig {<br>   }</p>
</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>传统复用的都是核心业务逻辑，并不能复用一些辅助逻辑，比如：日志记录、性能统计、安全校验、事务管理，等等。这些边缘逻辑往往贯穿整个核心业务，传统 OOP 很难将其封装</p>
<p>AOP 不是 OOP 的对立面，它是对 OOP 的一种补充。OOP 是纵向的，AOP 是横向的。AOP 技术，能够不修改原有代码，便能让切面逻辑在所有业务逻辑中生效。</p>
<img src="/2021/06/24/Spring%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-c950bb7cfb934e40afd787386b3846d5.jpg" class="" title="面向切面编程.jpg">

<ol>
<li>概念<br>面向切面(方面)编程，对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间耦合度降低，提高程序的可重用性。</li>
<li>原理<br>aop底层使用动态代理<br>  1. 有接口情况，使用JDK动态代理<br>     创建接口实现类代理对象，增强类中的方法<br>  2. 无接口情况，使用CGLIB动态代理<br>     创建当前类子类的代理对象</li>
<li>AOP(术语)<ol>
<li>连接点:类中可以被增强的方法</li>
<li>切入点:实际增强的方法</li>
<li>通知(增强):<ul>
<li>前置通知  before</li>
<li>后置通知  afterreturning(有异常不执行)</li>
<li>环绕通知  around</li>
<li>异常通知  afterthrowing</li>
<li>最终通知  after(有异常也执行)</li>
</ul>
</li>
<li>切面:把通知应用到切入点过程</li>
</ol>
</li>
</ol>
<h3 id="JDK动态代理-java-lang-reflect-Proxy"><a href="#JDK动态代理-java-lang-reflect-Proxy" class="headerlink" title="JDK动态代理(java.lang.reflect.Proxy)"></a>JDK动态代理(java.lang.reflect.Proxy)</h3><p><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </code></p>
<ol>
<li>调用newProxyInstance方法<br>该方法有三个参数<ul>
<li>类加载器</li>
<li>增强方法所在的类，这个类实现的接口，支持多个接口</li>
<li>实现接口InvocationHandler，创建代理对象，写增强的方法</li>
</ul>
</li>
<li>创建接口实现类，实现方法</li>
<li>使用Proxy类创建接口代理对象</li>
</ol>
<h3 id="AOP操作-注解方式"><a href="#AOP操作-注解方式" class="headerlink" title="AOP操作(注解方式)"></a>AOP操作(注解方式)</h3><ol>
<li>Spring框架一般都是基于AspectJ实现AOP操作<ol>
<li>什么是AspectJ<br>AspectJ不是Spring组成部分，独立于AOP框架，一般把两者结合使用进行aop操作</li>
<li>基于AspectJ实现aop操作<ul>
<li>xml方式</li>
<li>注解方式</li>
</ul>
</li>
</ol>
</li>
<li>引入相关依赖</li>
<li>进行通知的配置<ol>
<li>在spring配置文件中，开启注释扫描</li>
<li>使用注解创建User和UserProxy对象</li>
<li>在增强类上添加注解@Aspect</li>
<li>在spring配置文件中开启生成代理对象</li>
</ol>
</li>
<li>配置不同类型的通知<ol>
<li>在增强类的里面，在作为通知方法上添加通知类型注解，使用切入点表达式配置<ol>
<li>切入点表达式:知道对哪个类里的哪个方法进行增强</li>
<li>语法结构<ul>
<li>execution([权限修饰符][返回类型(可省略)][类全路径][方法名称][参数列表])</li>
<li>execution(* com.it.dao.BookDao.add())</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><ol>
<li>概念<br>Spring框架对jdbc进行封装，使用JdbcTemplate可以方便的实现对数据库操作</li>
<li>步骤<ol>
<li>引入依赖</li>
<li>在spring配置文件中配置数据库连接池</li>
<li>配置JdbcTemplate对象，注入DataSourse</li>
<li>创建service类，dao类，在dao注入JdbcTemplate对象</li>
</ol>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li>概念<br>事务是数据库操作的最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败所有操作都失败</li>
<li>事务四个特性<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
</li>
<li>在spring中进行事务管理操作<ol>
<li>编程式事务管理和声明式事务管理</li>
<li>spring中声明式事务管理，底层使用aop原理</li>
</ol>
</li>
<li>spring事务管理相关api<ol>
<li>提供一个接口PlatformTransactionManager，代表事务管理器，这个接口对不同框架提供不同实现类</li>
</ol>
</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>在系统中，有一些对象其实只需要一个，比如：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong>Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。 </li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 </li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 </li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p>Spring 通过<code>ConcurrentHashMap</code>实现单例注册表的特殊方式实现单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象不存在，就注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2022/04/14/Spring/</url>
    <content><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<ul>
<li>控制 ：指的是对象创建（实例化、管理）的权力</li>
<li>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p>IOC 解决了以下问题：</p>
<ol>
<li>创建了许多重复对象，造成大量资源浪费；</li>
<li>更换实现类需要改动多个地方；</li>
<li>创建和配置组件工作繁杂，给组件调用方带来极大不便。</li>
</ol>
<p>IOC容器职责：</p>
<ol>
<li>依赖处理<ol>
<li>依赖查找</li>
<li>依赖注入</li>
</ol>
</li>
<li>生命周期管理<ol>
<li>容器</li>
<li>托管的资源(bean或其他)</li>
</ol>
</li>
<li>配置 <ol>
<li>容器</li>
<li>外部化资源</li>
<li>托管的资源(bean或其他)</li>
</ol>
</li>
</ol>
<h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><p>spring中有三种类型的bean，其中前两种都可以通过getbean方法获取到，第三种无法直接获取，是容器自己所使用的对象。</p>
<ol>
<li>用户自定义的bean</li>
<li>容器自己的bean（内建bean对象），也是通过正常的bean注册流程生产的</li>
<li>spring的内建依赖，无法通过自动注入方式设置对象</li>
</ol>
<h3 id="bean自动装配"><a href="#bean自动装配" class="headerlink" title="bean自动装配"></a>bean自动装配</h3><p>使用bean标签的<strong>autowire属性</strong>设置自动装配效果</p>
<p><strong>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</strong></p>
<p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null</p>
<p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException</p>
<p><strong>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</strong></p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><h4 id="bean的装载过程："><a href="#bean的装载过程：" class="headerlink" title="bean的装载过程："></a><strong>bean的装载过程：</strong></h4><p>xml（注解）-&gt;bean defination -&gt; bean factory -&gt; 实例化出bean。</p>
<ol>
<li><code>BeanDefinitionReader</code>：从不同格式的定义bean信息中读取，完成从xml文件到bean defination的转变</li>
<li><code>BeanDefinition</code>：其中保存了从配置文件中读取到的该bean的各种信息，包括bean的名字、类型、依赖关系、作用域等等，以后所有的操作都是对这个对象的操作。<strong>Bean Definition从加载、解析、处理、注册到BeanFactory的过程，也就是IOC容器的初始化过程</strong></li>
<li><code>BeanFactory</code>：是Spring bean容器的根接口.<strong>提供获取bean,是否包含bean,是否单例与原型,获取bean类型,bean 别名的方法</strong> 。BeanFactory是一个接口，Spring为BeanFactory提供了多种实现</li>
<li><code>ApplicationContext</code>：ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。ApplicationContext的主要实现类是<code>ClassPathXmlApplicationContext</code>和<code>FileSystemXmlApplicationContext</code>，前者默认从类路径加载配置文件，后者默认从文件系统中加载配置文件</li>
</ol>
<h4 id="Spring-管理bean的生命周期主要阶段（doGetBean）："><a href="#Spring-管理bean的生命周期主要阶段（doGetBean）：" class="headerlink" title="Spring 管理bean的生命周期主要阶段（doGetBean）："></a>Spring 管理bean的生命周期主要阶段（doGetBean）：</h4><ol>
<li><p>处理名称，检查缓存，若缓存中存在可以直接返回</p>
<ol>
<li>先把别名解析为实际名称，再进行后续操作</li>
<li>singletonObjects：一级缓存，存放单例成品对象</li>
<li>singletonFactories：三级缓存，放单例工厂</li>
<li>earlySingletonObjects：二级缓存，放单例工厂的产品，成为提前单例对象</li>
</ol>
</li>
<li><p>按照scope实例化Bean：Spring启动，查找并加载需要被Spring管理的bean，根据 bean 的<strong>构造方法或者工厂方法</strong>来创建 bean 实例对象</p>
<ol>
<li>singleton scope：从单例池中获取，如果没有就创建并放入单例池</li>
<li>prototype scope：从不缓存bean，每次请求都创建新的</li>
<li>request scope：从request对象范围内获取bean</li>
</ol>
</li>
<li><p>依赖注入：实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。紧接着，Spring根据BeanDefinition中的信息进行依赖注入。根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</p>
</li>
<li><p>初始化</p>
<ol>
<li><p>注入Aware接口：检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean</p>
</li>
<li><p>BeanPostProcessor：经过上述几个步骤后，bean对象已经被正确构造，但如果想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。</p>
<ul>
<li><p>postProcessBeforeInitialzation()</p>
</li>
<li><p>postProcessAfterInitialzation()</p>
</li>
</ul>
<p><strong>BeanPostProcessor接口对IOC容器中所有bean都生效，耦合度高，spring建议使用@postconstruct</strong></p>
</li>
<li><p>InitializingBean：此阶段无法修改对象本身，只能增加一些额外的逻辑。</p>
</li>
<li><p>init-method：init-method本质上仍然使用了InitializingBean接口。</p>
</li>
</ol>
<p>四个初始化步骤的调用顺序：Aware接口–&gt;@postconstruct–&gt;InitializingBean接口–&gt;指定init-method方法</p>
</li>
<li><p>判断并登记可销毁bean</p>
<ol>
<li>实现了DisposableBean或AutoCloseable接口，则为可销毁bean</li>
<li>自定义了destroyMethod</li>
<li>有@PreDestroy标注的方法</li>
</ol>
<p>singleton scope的可销毁bean存放于beanFactory的成员变量中</p>
</li>
<li><p>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）</p>
<ul>
<li>prototype 对象也能够销毁，不过需要容器主动调用</li>
</ul>
<p>同一bean中不同形式销毁方法的调用顺序：@PreDestroy–&gt;DisposableBean接口销毁–&gt;destroyMethod方法销毁</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">创建 --&gt; 依赖注入</span><br><span class="line">依赖注入 --&gt; 初始化</span><br><span class="line">初始化 --&gt; 可用</span><br><span class="line">可用 --&gt; 销毁</span><br></pre></td></tr></table></figure>

<p>创建前后的增强</p>
<ul>
<li>postProcessBeforeInstantiation<ul>
<li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li>
</ul>
</li>
<li>postProcessAfterInstantiation<ul>
<li>这里如果返回 false 会跳过依赖注入阶段</li>
</ul>
</li>
</ul>
<p>依赖注入前的增强</p>
<ul>
<li>postProcessProperties<ul>
<li>如 @Autowired、@Value、@Resource</li>
</ul>
</li>
</ul>
<p>初始化前后的增强</p>
<ul>
<li>postProcessBeforeInitialization<ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如 @PostConstruct、@ConfigurationProperties</li>
</ul>
</li>
<li>postProcessAfterInitialization <ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如代理增强</li>
</ul>
</li>
</ul>
<p>销毁之前的增强</p>
<ul>
<li>postProcessBeforeDestruction<ul>
<li>如 @PreDestroy</li>
</ul>
</li>
</ul>
<h4 id="spring循环依赖解决：三级缓存（set方法进行依赖注入）"><a href="#spring循环依赖解决：三级缓存（set方法进行依赖注入）" class="headerlink" title="spring循环依赖解决：三级缓存（set方法进行依赖注入）"></a>spring循环依赖解决：三级缓存（set方法进行依赖注入）</h4><p>只有单例模式的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean每次请求都会创建一个新的对象，所以非单例的bean不会放在缓存中。</p>
<ol>
<li>三级缓存中存放的内容<ol>
<li>一级缓存：成品对象–concurrenthashmap，每个bean在容器中只有一份即实现singleton</li>
<li>二级缓存：存放发生循环依赖时的半成品对象（可能是代理bean也可能是原始bean）–hashmap ，创造完成品对象删除 </li>
<li>三级缓存：存放工厂对象，发生循环依赖时会由工厂获取 产品。lambda表达式，<strong>保证在容器的运行过程中同名的bean对象只有一个</strong>–hashmap</li>
</ol>
</li>
<li>只有一级缓存无法解决：成品对象与半成品对象放在一起，会导致获取对象时获取到未初始化完成的对象</li>
<li>二级缓存可以解决循环依赖的问题，但是无法实现aop的功能，在进行aop时，会导致获取到非最终的bean</li>
<li>三级缓存作用：实现aop相关功能时需要创建代理对象，由于容器中只能存在单个实例，因此当一个对象需要被代理时就要使用代理对象对他进行覆盖，然而无法确定其时机。因此lambda完成了代理对象替换非代理对象的工作，确保返回的是唯一的对象。<strong>所有的bean对象在创建的时候都要优先放在三级缓存中，在后续的使用过程中，根据是否需要代理，返回对应的对象</strong></li>
</ol>
<p>三级缓存无法解决构造循环依赖，可以用@Lazy解决 </p>
<h3 id="Bean-后处理器"><a href="#Bean-后处理器" class="headerlink" title="Bean 后处理器"></a>Bean 后处理器</h3><ol>
<li>@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成</li>
<li>不同后处理器负责增强不同功能<ul>
<li>AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value</li>
<li>CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy</li>
<li>ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties</li>
</ul>
</li>
<li>ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等</li>
</ol>
<hr>
<p><strong>@Autowired bean 后处理器运行分析</strong></p>
<ol>
<li>AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata</li>
<li>InjectionMetadata 可以完成依赖注入</li>
<li>InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型</li>
<li>有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找</li>
</ol>
<h3 id="初始化和销毁顺序"><a href="#初始化和销毁顺序" class="headerlink" title="初始化和销毁顺序"></a>初始化和销毁顺序</h3><p>Spring 提供了多种<strong>初始化手段</strong>，如果同一个 bean 用了声明了 3 个初始化方法，那么它们的执行顺序是</p>
<ol>
<li>@PostConstruct 标注的初始化方法</li>
<li>InitializingBean 接口的初始化方法</li>
<li>@Bean(initMethod) 指定的初始化方法</li>
</ol>
<blockquote>
<p>被@PostConstruct 修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。<br>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct</p>
</blockquote>
<p>与初始化类似，Spring 也提供了多种<strong>销毁手段</strong>，执行顺序为</p>
<ol>
<li>@PreDestroy 标注的销毁方法</li>
<li>DisposableBean 接口的销毁方法</li>
<li>@Bean(destroyMethod) 指定的销毁方法</li>
</ol>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope</p>
<ul>
<li>singleton，容器启动时创建（未设置延迟），容器关闭时销毁</li>
<li>prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li>
<li>request，每次请求用到此 bean 时创建，请求结束时销毁</li>
<li>session，每个会话用到此 bean 时创建，会话结束时销毁</li>
<li>application，web 容器用到此 bean 时创建，容器停止时销毁</li>
</ul>
<p>对于单例对象来讲，依赖注入仅发生了一次，如果在 singleton 注入其它 scope 都会有问题，解决方法有</p>
<ul>
<li>@Lazy</li>
<li>@Scope(proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li>
<li>ObjectFactory</li>
<li>ApplicationContext.getBean</li>
</ul>
<h3 id="bean的垃圾回收"><a href="#bean的垃圾回收" class="headerlink" title="bean的垃圾回收"></a>bean的垃圾回收</h3><ol>
<li>关闭spring容器</li>
<li>执行GC</li>
<li>spring  bean重写finalize()方法</li>
</ol>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h3><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示出来。</p>
<p>比如Spring就是通过继承FactoryBean并重写相关方法的机制来创建SqlSessionFactory对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>是ApplicationContext的父接口，是spring的核心容器。实际上的控制反转、依赖注入、Bean生命周期的各种功能都由它的实现类提供。</p>
<img src="/2022/04/14/Spring/image-20220325104441524.png" class="" title="image-20220325104441524">

<p>BeanFactory的主要实现类</p>
<img src="/2022/04/14/Spring/image-20220325104702467.png" class="" title="image-20220325104702467">

<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>BeanFactory是底层的IOC容器，ApplicationContext是 BeanFactory 的子接口。它<strong>组合</strong>（类似于代理模式，核心的方法都是BeanFactory进行操作）并扩展了 BeanFactory 的功能，不仅仅是继承关系，如：</p>
<ul>
<li><p>国际化</p>
<p>语言支持：<code>applicationContext.getMessage()</code></p>
</li>
<li><p>通配符方式获取一组 Resource 资源</p>
<p><code>applicationContext.getResources(&quot;classpath*:META-INF/spring.factories&quot;)</code></p>
</li>
<li><p>整合 Environment 环境（能通过它获取各种来源的配置信息）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line"><span class="type">String</span> <span class="variable">java_home</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;java_home&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件发布与监听，实现组件之间的解耦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事件</span></span><br><span class="line">context.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(context));</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受事件</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接受事件&quot;</span> + event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2022/04/14/Spring/image-20220325110338651.png" class="" title="image-20220325110338651">


<h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>Spring 容器的实现</p>
<ul>
<li>DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</li>
<li>ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）</li>
<li>FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）</li>
<li>XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）</li>
<li>AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）</li>
<li>AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）</li>
<li>AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）</li>
<li>AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）</li>
</ul>
<p>另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是<strong>组合</strong>了 DefaultListableBeanFactory 的功能，并非继承而来</p>
<h4 id="DefaultListableBeanFactory实现"><a href="#DefaultListableBeanFactory实现" class="headerlink" title="DefaultListableBeanFactory实现"></a>DefaultListableBeanFactory实现</h4><p>是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现。</p>
<ul>
<li>beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象<ul>
<li>平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中</li>
<li>bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等</li>
</ul>
</li>
<li>beanFactory 需要手动调用 beanFactory 后处理器对它做增强<ul>
<li>例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition</li>
</ul>
</li>
<li>beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强<ul>
<li>例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的</li>
<li>bean 后处理的添加顺序会对解析结果有影响，如同时加 @Autowired，@Resource</li>
</ul>
</li>
<li>beanFactory 需要手动调用方法来初始化单例</li>
<li>beanFactory 需要额外设置才能解析 ${} 与 #{}</li>
</ul>
<h4 id="常见-ApplicationContext-实现"><a href="#常见-ApplicationContext-实现" class="headerlink" title="常见 ApplicationContext 实现"></a>常见 ApplicationContext 实现</h4><ol>
<li>AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器</li>
<li>AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器</li>
</ol>
<h3 id="BeanFactory-后处理器"><a href="#BeanFactory-后处理器" class="headerlink" title="BeanFactory 后处理器"></a>BeanFactory 后处理器</h3><ul>
<li>ConfigurationClassPostProcessor 可以解析<ul>
<li>@ComponentScan</li>
<li>@Bean</li>
<li>@Import</li>
<li>@ImportResource</li>
</ul>
</li>
<li>MapperScannerConfigurer 可以解析<ul>
<li>Mapper 接口</li>
</ul>
</li>
</ul>
<p>这些扩展功能由不同的BeanFactory 后处理器来完成，完成了对核心容器的扩展。</p>
<ol>
<li>@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能</li>
<li>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</li>
<li>这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义</li>
</ol>
<h3 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h3><ol>
<li>Aware 接口提供了一种【内置】 的注入手段，例如<ul>
<li>BeanNameAware 注入 bean 的名字</li>
<li>BeanFactoryAware 注入 BeanFactory 容器</li>
<li>ApplicationContextAware 注入 ApplicationContext 容器</li>
<li>EmbeddedValueResolverAware 注入 ${} 解析器</li>
</ul>
</li>
<li>InitializingBean 接口提供了一种【内置】的<strong>初始化手段</strong></li>
<li>对比<ul>
<li>内置的注入和初始化不受扩展功能的影响，总会被执行</li>
<li>而<strong>扩展功能受某些情况影响可能会失效</strong></li>
<li>因此 Spring 框架内部的类常用内置注入和初始化</li>
</ul>
</li>
</ol>
<h4 id="配置类-Autowired-失效分析"><a href="#配置类-Autowired-失效分析" class="headerlink" title="配置类 @Autowired 失效分析"></a>配置类 @Autowired 失效分析</h4><p>Java 配置类不包含 BeanFactoryPostProcessor 的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">bpp -&gt;&gt; config : 3.1 依赖注入扩展(如 @Value 和 @Autowired)</span><br><span class="line">bpp -&gt;&gt; config : 3.2 初始化扩展(如 @PostConstruct)</span><br><span class="line">ac -&gt;&gt; config : 3.3 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.4 创建成功</span><br></pre></td></tr></table></figure>

<p>Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">ac -&gt;&gt; config : 3.1 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.2 创建成功</span><br><span class="line"></span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyConfig1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//  ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行 processor1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>注意</strong></em></p>
<p>解决方法：</p>
<ul>
<li>用内置依赖注入和初始化取代扩展依赖注入和初始化</li>
<li>用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建</li>
</ul>
</blockquote>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p>
<p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p>
<ul>
<li>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</li>
<li>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</li>
</ul>
<p>简单比较的话：</p>
<ul>
<li>aspectj 在编译和加载时，修改目标字节码，性能较高</li>
<li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li>
<li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li>
</ul>
<p>AOP(术语)</p>
<ol>
<li>连接点:类中可以被增强的方法</li>
<li>切入点:实际增强的方法</li>
<li>通知(增强):<br> - 前置通知 before<br> - 后置通知 afterreturning(有异常不执行)<br> - 环绕通知 around<br> - 异常通知 afterthrowing<br> - 最终通知 after(有异常也执行)</li>
<li>切面:把通知应用到切入点过程</li>
</ol>
<h2 id="jdk-动态代理"><a href="#jdk-动态代理" class="headerlink" title="jdk 动态代理"></a>jdk 动态代理</h2><h3 id="使用jdk-动态代理"><a href="#使用jdk-动态代理" class="headerlink" title="使用jdk 动态代理"></a>使用jdk 动态代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(</span><br><span class="line">                Target.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;,</span><br><span class="line">                (p, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</p>
<h3 id="实现-jdk-动态代理"><a href="#实现-jdk-动态代理" class="headerlink" title="实现 jdk 动态代理"></a>实现 jdk 动态代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;    </span><br><span class="line">            <span class="comment">// ⬇️5. 进入 InvocationHandler</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="comment">// ⬇️6. 功能增强</span></span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="comment">// ⬇️7. 反射调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// ⬇️2. 调用代理方法</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟代理实现</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A12</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⬇️3. 进入代理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ⬇️4. 回调 InvocationHandler</span></span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A12.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A12.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理利用了多态、反射的知识</p>
<ol>
<li>方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部</li>
<li>通过接口回调将【增强逻辑】置于代理类之外</li>
<li>配合接口方法反射（是多态调用），就可以再联动调用目标方法</li>
<li>限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现</li>
</ol>
<h2 id="cglib-代理"><a href="#cglib-代理" class="headerlink" title="cglib 代理"></a>cglib 代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, </span><br><span class="line">                (MethodInterceptor) (p, method, args, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">// 另一种调用方法，不需要目标对象实例</span></span><br><span class="line"><span class="comment">//            Object result = methodProxy.invokeSuper(p, args);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li>
<li>限制⛔：根据上述分析 final 类无法被 cglib 增强</li>
</ul>
<h2 id="jdk-和-cglib-在-Spring-中的统一"><a href="#jdk-和-cglib-在-Spring-中的统一" class="headerlink" title="jdk 和 cglib 在 Spring 中的统一"></a>jdk 和 cglib 在 Spring 中的统一</h2><p>Spring 中对切点、通知、切面的抽象如下</p>
<ul>
<li>切点：接口 Pointcut，典型实现 AspectJExpressionPointcut</li>
<li>通知：典型接口为 MethodInterceptor 代表环绕通知</li>
<li>切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class Advice</span><br><span class="line">class MethodInterceptor</span><br><span class="line">class Advisor</span><br><span class="line">class PointcutAdvisor</span><br><span class="line"></span><br><span class="line">Pointcut &lt;|-- AspectJExpressionPointcut</span><br><span class="line">Advice &lt;|-- MethodInterceptor</span><br><span class="line">Advisor &lt;|-- PointcutAdvisor</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Pointcut</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Advice</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advice</span><br><span class="line">&lt;&lt;interface&gt;&gt; MethodInterceptor</span><br><span class="line">&lt;&lt;interface&gt;&gt; Pointcut</span><br><span class="line">&lt;&lt;interface&gt;&gt; Advisor</span><br><span class="line">&lt;&lt;interface&gt;&gt; PointcutAdvisor</span><br></pre></td></tr></table></figure>

<p>代理相关类图</p>
<ul>
<li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li>
<li>AopProxy 通过 getProxy 创建代理对象</li>
<li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li>
<li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Advised &lt;|-- ProxyFactory</span><br><span class="line">ProxyFactory o-- Target</span><br><span class="line">ProxyFactory o-- &quot;多&quot; Advisor</span><br><span class="line"></span><br><span class="line">ProxyFactory --&gt; AopProxyFactory : 使用</span><br><span class="line">AopProxyFactory --&gt; AopProxy</span><br><span class="line">Advised &lt;|-- 基于CGLIB的Proxy</span><br><span class="line">基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建</span><br><span class="line">AopProxy &lt;|-- ObjenesisCglibAopProxy</span><br><span class="line">AopProxy &lt;|-- JdkDynamicAopProxy</span><br><span class="line">基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建</span><br><span class="line">Advised &lt;|-- 基于JDK的Proxy</span><br><span class="line"></span><br><span class="line">class AopProxy &#123;</span><br><span class="line">   +getProxy() Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyFactory &#123;</span><br><span class="line">	proxyTargetClass : boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ObjenesisCglibAopProxy &#123;</span><br><span class="line">	advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JdkDynamicAopProxy &#123;</span><br><span class="line">	advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advised</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxyFactory</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxy</span><br></pre></td></tr></table></figure>



<ol>
<li>ProxyFactory 用来创建代理<ul>
<li>如果指定了接口，且 proxyTargetClass &#x3D; false，使用 JdkDynamicAopProxy</li>
<li>如果没有指定接口，或者 proxyTargetClass &#x3D; true，使用 ObjenesisCglibAopProxy<ul>
<li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口</li>
</ul>
</blockquote>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">        beanFactory.getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法  Template Method Pattern</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">            System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean); <span class="comment">// @Autowired, @Resource</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.inject(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">            processors.add(processor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>; <span class="comment">// 对依赖注入阶段的扩展</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例bean借鉴了思想，严格意义上并不是单例模式。因为只保证了一个容器有一个唯一bean，但是系统可以有多个容器</p>
<p>Spring 通过<code>ConcurrentHashMap</code>实现单例注册表的特殊方式实现单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果实例对象不存在，就注册到单例注册表中。</span></span><br><span class="line"></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="literal">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>链式调用，在build之前对象不可用</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>HandlerAdapter–控制器实现有多种</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将分散的调用组合起来，统一调用接口，它的特征是与具体工作的实现实现同一个接口，当调用组合对象的接口方法时，其实是委托具体干活的实现来完成</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>事件与监听者</p>
<h1 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">/* 完成context的初始化准备工作.</span></span><br><span class="line"><span class="comment">		1. 创建和准备了Environment对象:</span></span><br><span class="line"><span class="comment">			1. systemProperties	Java虚拟机等提供的</span></span><br><span class="line"><span class="comment">			2. systemEnvironment 操作系统提供的</span></span><br><span class="line"><span class="comment">			3. 自定义Properties  自定义properties yml文件中提供的</span></span><br><span class="line"><span class="comment">		2. 作用:如@value注入,使用的就是Environment对象中的值</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line">           <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">		<span class="comment">/* 生成一个beanFactory供context使用,容器的核心功能都由beanFactory提供.</span></span><br><span class="line"><span class="comment">		1. ApplicationContext扩展了beanFactory的功能,但是并没有重复实现beanFactory已有功能.</span></span><br><span class="line"><span class="comment">		2. beanFactory的作用是负责bean的创建,依赖注入和初始化.其中包含</span></span><br><span class="line"><span class="comment">			1. beanDefinationMap:作为bean的设计蓝图,规定了bean的特征,如依赖关系,单例多例,初始化销毁方法.</span></span><br><span class="line"><span class="comment">			2. singletonObjects</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">		<span class="comment">/* 完成context中的beanFactory初始化准备工作.</span></span><br><span class="line"><span class="comment">		1. 对beanFactory的一些成员变量进行初始化赋值:</span></span><br><span class="line"><span class="comment">			1. beanExpressionResolver	spring内部类型转换器,如解析$&#123;&#125;</span></span><br><span class="line"><span class="comment">			2. resolvableDependencies	存放特殊的bean以供使用,如applicationContext,beanFactory等</span></span><br><span class="line"><span class="comment">			3. beanPostProcessors	提供对各种注解的支持</span></span><br><span class="line"><span class="comment">			4. ApplicationContextAwareProcessor	用来解析Aware接口</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/* 空实现提供给子类进行扩展.允许在上下文子类中对beanFactory进行增强,如web环境下需要更多功能.模板方法设计模式</span></span><br><span class="line"><span class="comment">			beanFactory的一个扩展点</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">			<span class="comment">/* 调用注册好的beanFactory后处理器,可以用来补充或修改BeanDefination.</span></span><br><span class="line"><span class="comment">			beanFactory的一个扩展点</span></span><br><span class="line"><span class="comment">			如提供@Bean,@Configuration等注解的支持</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">			<span class="comment">/* 添加一些bean的后处理器,充当bean的扩展点,可以工作在bean的实例化,依赖注入,初始化阶段</span></span><br><span class="line"><span class="comment">			从beanDefinationMap中找到实现了BeanPostProcessors接口的对象并注册,在后续需要相应功能时提供支持</span></span><br><span class="line"><span class="comment">			如@Autowired,@Aspect,@PostContstruct</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">               <span class="comment">//BeanFactory增强结束-----------------------------------------------------------</span></span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">// 实现国际化功能,查找容器中是否存在一个MessageSource的bean(实现相关接口),如果没有则提供空实现</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 初始化事件广播器,查找容器中是否存在一个ApplicationEventMulticaster的bean,如果没有则新建默认的广播器</span></span><br><span class="line"><span class="comment">			调用ApplicationContext.publishEvent()来发布事件</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">// 空实现,供子类扩展使用.如spring boot中可以在此准备WebServer容器</span></span><br><span class="line">			onRefresh();</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 注册事件监听器</span></span><br><span class="line"><span class="comment">			监听器可以通过编程添加,从容器中获取,或来自与@EventListener的解析</span></span><br><span class="line"><span class="comment">			实现ApplicationListener接口,重写其onApplicationEvent()方法即可接收事件</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			registerListeners();</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 完成非延迟单例bean的创建和初始化.其中会使用到上文中准备的beanPostProcessors</span></span><br><span class="line"><span class="comment">			1. 单例池中缓存所有非延迟单例bean,对象的创建包含三个阶段:创建-依赖注入-初始化.每个阶段都有不同的bean后处理器参与</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">			1. 控制容器内需要生命周期管理的bean</span></span><br><span class="line"><span class="comment">			2. 调用context的start,即可触发所有实现LifeCycle接口bean的start</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="spring事件"><a href="#spring事件" class="headerlink" title="spring事件"></a>spring事件</h1><p>Spring提供了事件机制，其本质是JDK提供的事件机制的应用，利用的是观察者设计模式。<br>在一个完整的事件体系中存在以下的角色：</p>
<ol>
<li>事件：描述发生了什么事情、比如说请求处理完成、Spring 容器刷新完毕</li>
<li>事件源：事件的产生者、任何一个事件都必须有一个事件源。比如请求处理完成的事件源就是 DispatcherServlet 、Spring 容器刷新完毕的事件源就是 ApplicationContext</li>
<li>事件广播器：事件和事件监听器的桥梁、负责把事件通知给事件监听器</li>
<li>事件监听器：监听事件的发生、可以在监听器中做一些处理</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>常见的事件可能就是 ApplicationContextEvent ，抽象类，继承了JDK的EventObject接口，起到包装事件源的作用。它的子类 ContextRefreshedEvent 是常见的事件类型、在 Spring 将所有非延迟加载的 bean 实例化之后发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** System time when the event happened */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ApplicationEvent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> source the object on which the event initially occurred (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(source);</span><br><span class="line">		<span class="built_in">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the system time in milliseconds when the event happened.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>ApplicationListener可以通用地声明它感兴趣的事件类型。当在Spring ApplicationContext中注册时，事件将被相应地过滤，只有匹配的事件对象才会调用侦听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="启动之后直接执行某一段代码"><a href="#启动之后直接执行某一段代码" class="headerlink" title="启动之后直接执行某一段代码"></a>启动之后直接执行某一段代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//此类要交给spring管理</span></span><br><span class="line"><span class="meta">@Order(value=1)</span> <span class="comment">//首先执行</span></span><br><span class="line"><span class="comment">//@Order(value=2) //其次执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span>&#123;</span><br><span class="line">	<span class="meta">@Oberride</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArgumers args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">//代码</span></span><br><span class="line">		System.out.println(<span class="string">&quot;需要在springBoot项目启动时执行的代码---&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入Application容器"><a href="#注入Application容器" class="headerlink" title="注入Application容器"></a>注入Application容器</h2><p>两种方式：</p>
<ol>
<li>实现ApplicationContextAware接口</li>
<li>@Autowired ApplicationContext<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextProvider</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LoggerWithMDC</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerWithMDC.getLogger(<span class="built_in">this</span>.getClass(), <span class="string">&quot;assets-event&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        logger.info(<span class="string">&quot;setApplicationContext:&#123;&#125;&quot;</span>, applicationContext);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
两种最终结果相同，实现接口可以封装更多方法，如getBean，getBeansWithAnnotation等。</li>
</ol>
<h1 id="spring常见操作"><a href="#spring常见操作" class="headerlink" title="spring常见操作"></a>spring常见操作</h1>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2022/11/05/Zookeeper/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>一个领导者,多个跟随着组成的集群</li>
<li>集群中 只要有<strong>半数以上</strong>节点存活,集群就可以正常提供服务.</li>
<li>全局数据一致:每个Server保存一份相同的数据副本,Client无论连接到哪个Server,数据都是一致的</li>
<li>更新请求顺序执行,来自同一个Client的更新请求按照发送顺序依次执行</li>
<li>数据更新原子性,一次数据更新要么成功,要么失败</li>
<li>实时性,在一定时间范围内,Client能读到最新数据</li>
</ol>
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据模型的结构与文件系统类似,整体上来看是一棵树,每个节点叫做一个ZNode.每个ZNode默认能够<strong>存储1MB数据</strong>,每个ZNode可以通过其<strong>路径唯一标识</strong>.</p>
<p><strong>结点状态stat的属性</strong></p>
<ul>
<li><code>cZxid</code>数据结点创建时的事务ID——针对于<code>zookeeper</code>数据结点的管理：我们对结点数据的一些写操作都会导致<code>zookeeper</code>自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务<code>ID</code></li>
<li><code>ctime</code>数据结点创建时的时间</li>
<li><code>mZxid</code>数据结点最后一次更新时的事务ID</li>
<li><code>mtime</code>数据结点最后一次更新时的时间</li>
<li><code>pZxid</code>数据节点最后一次修改此<code>znode</code>子节点更改的<code>zxid</code></li>
<li><code>cversion</code>子结点的更改次数</li>
<li><code>dataVersion</code>结点数据的更改次数</li>
<li><code>aclVersion</code>结点的ACL更改次数——类似<code>linux</code>的权限列表，维护的是当前结点的权限列表被修改的次数</li>
<li><code>ephemeralOwner</code>如果结点是临时结点，则表示创建该结点的会话的<code>SessionID</code>；如果是持久结点，该属性值为0</li>
<li><code>dataLength</code>数据内容的长度</li>
<li><code>numChildren</code>数据结点当前的子结点个数</li>
</ul>
<p><strong>结点类型</strong></p>
<ul>
<li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话( <code>Session</code>）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 <code>Znode</code>都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，<code>Zookeeper</code>的<strong>临时节点不允许拥有子节点</strong></li>
<li>持久化结点：该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除</li>
<li>持久化顺序编号节点：创建节点时设置顺序标识,顺序号是一个单调递增的计数器,由父节点维护</li>
<li>临时顺序编号节点： 客户端与 Zookeeper断开连接后 ，该 节 点 被 删 除 ，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><ul>
<li>SID：服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。</li>
<li>ZXID：事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关。</li>
<li>Epoch：每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</li>
</ul>
<p><strong>选举Leader规则</strong>：</p>
<ol>
<li>EPOCH大的直接胜出</li>
<li>EPOCH相同，事务id大的胜出</li>
<li>事务id相同，服务器id大的胜出</li>
</ol>
<h1 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h1><h2 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h2><p>Paxos算法：一种基于消息传递且具有高度容错特性的一致性算法。<br>Paxos算法解决的问题：就是如何快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性。</p>
<p>Paxos算法描述：</p>
<ol>
<li>在一个Paxos系统中，首先将所有节点划分为Proposer（提议者），Acceptor（接受者），和Learner（学习者）。（每个节点都可以身兼数职）。</li>
<li>一个完整的Paxos算法流程分为三个阶段：</li>
<li>Prepare准备阶段<ul>
<li>Proposer向多个Acceptor发出Propose请求Promise（承诺）</li>
<li>Acceptor针对收到的Propose请求进行Promise（承诺）</li>
</ul>
</li>
<li>Accept接受阶段<ul>
<li>Proposer收到多数Acceptor承诺的Promise后，向Acceptor发出Propose请求</li>
<li>Acceptor针对收到的Propose请求进行Accept处理</li>
</ul>
</li>
<li>Learn学习阶段：Proposer将形成的决议发送给所有Learners</li>
</ol>
<p>Paxos 算法缺陷：在网络复杂的情况下，一个应用 Paxos 算法的分布式系统，可能很久无法收敛，甚至陷入<strong>活锁</strong>的情况。</p>
<h2 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h2><p>Zookeeper 设计为只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader 客户端将数据同步到其他 Follower 节点。即 Zookeeper 只有一个 Leader 可以发起提案。Zab 协议包括两种基本的模式：消息广播、崩溃恢复。</p>
<p>ZAB协议定义的四种节点状态:</p>
<ol>
<li>Looking：选举状态</li>
<li>Following：从节点所处的状态</li>
<li>Leading：主节点所处状态</li>
<li>Observing：观察者节点所处状态</li>
</ol>
<h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>ZAB协议针对事务请求的处理过程类似于一个<strong>两阶段提交</strong>过程</p>
<ol>
<li>广播事务阶段</li>
<li>广播提交操作</li>
</ol>
<p>这两阶段提交模型有可能因为Leader宕机带来数据不一致</p>
<ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader服务器将客户端的请求转化为事务Proposal提案，同时为每个Proposal 分配一个全局的ID，即zxid。</li>
<li>Leader服务器为每个Follower服务器分配一个单独的队列，然后将需要广播的 Proposal依次放到队列中去，并且根据FIFO策略进行消息发送。</li>
<li>Follower接收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个Ack响应消息。</li>
<li>Leader接收到超过<strong>半数以上</strong>Follower的Ack响应消息后，即认为消息发送成功，可以发送commit消息。</li>
<li>Leader向所有Follower广播commit消息，同时自身也会完成事务提交。收到commit的服务器把本地数据文件中的数据写到内存中。</li>
<li>Zookeeper采用Zab协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposal。</li>
</ol>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半 Follower的联系，那么就会进入崩溃恢复模式。</p>
<p>Zab协议崩溃恢复要求满足以下两个要求：</p>
<ol>
<li>确保已经被Leader提交的提案Proposal，必须最终被所有的Follower服务器提交。 （<strong>已经产生的提案，Follower必须执行</strong>）</li>
<li>确保丢弃已经被Leader提出的，但是没有被提交的Proposal。（<strong>丢弃胎死腹中的提案</strong>）</li>
</ol>
<p>崩溃恢复主要包括两部分：Leader选举和数据恢复。</p>
<h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><p>Leader建立完成后，Leader周期性地向Follower发送心跳，当Leader崩溃后，Follower发现socket通道关闭，于是Follower开始进入到Looking状态，重新回到Leader选举状态，<strong>此时集群不能对外提供服务</strong></p>
<p>根据上述要求，Zab协议需要保证选举出来的Leader需要满足以下条件：</p>
<ol>
<li>新选举出来的Leader不能包含未提交的Proposal。即新Leader必须都是已经提交了Proposal的Follower服务器节点。</li>
<li>新选举的Leader节点中含有最大的zxid。这样做的好处是可以避免Leader服务器检查Proposal的提交和丢弃工作。</li>
</ol>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><ol>
<li>完成Leader选举后，在正式开始工作之前（接收事务请求，然后提出新的Proposal），Leader服务器会首先确认事务日志中的所有的Proposal 是否已经被集群中过半的服务器Commit。</li>
<li>Leader服务器需要确保所有的Follower服务器能够接收到每一条事务的Proposal，并且能将所有已经提交的事务Proposal应用到内存数据中。等到Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过，并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>http</title>
    <url>/2023/11/23/http/</url>
    <content><![CDATA[<blockquote>
<p>服务端开发离不开和 http 打交道，无论是 API 请求、RPC 请求，都有可能使用 http 协议。http 太常见了， spring 提供的注解开发可能让我们忽略了协议内不同内容是如何存放，header、body、表单都如何使用。参考极客时间-透视 http 协议，从头到尾梳理一遍 http 的详细知识。</p>
</blockquote>
<h2 id="http-是什么"><a href="#http-是什么" class="headerlink" title="http 是什么"></a>http 是什么</h2><p>http 全称<strong>超文本传输协议</strong>，拆分为三个名词详细理解：</p>
<ul>
<li>超文本：普通的文本指的是文字数据，超文本不但包含了文字，它也包括了语音、图片、视频等数据，是一切资源的泛称。同时它含有超链接，可以从一个超文本跳转到另外一个超文本，形成复杂的网状结构。</li>
<li>传输：数据在双方的流动叫为传输，http 是一个<strong>双向传输</strong>协议，一般情况下把发起数据传输的称为请求方，接受数据的称为响应方。</li>
<li>协议：首先协议可以分为两个部分，它需要最少两个参与者，参与者要想互相理解对方传输的内容，这离不开规范。简单来说协议就是规定了双方使用同样可以理解的语音进行交流</li>
</ul>
<p>作为一种协议规范，它本身不是一种程序或软件，HTTP 通常跑在 TCP&#x2F;IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL&#x2F;TLS 协议实现安全通信。</p>
<p>http 具有简单灵活、无状态、跨语言、明文传输的特点。</p>
<ul>
<li>简单灵活：使用 k：v 的文字键值对，通俗易懂。</li>
<li>无状态：http 本身不会保存任何数据，即使和同一服务器进行多次通信，它也是无感知的。</li>
<li>明文传输：协议里的报文（也就是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</li>
<li>没有身份认证能力、数据完整性校验机制，容易被冒充身份。</li>
</ul>
<h2 id="协议的内容"><a href="#协议的内容" class="headerlink" title="协议的内容"></a>协议的内容</h2><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>http 的请求和响应格式类似，都是由三部分组成：</p>
<ul>
<li>起始行：描述请求或响应的基本信息	GET &#x2F;path HTTP&#x2F;1.1</li>
<li>header 集合：使用 k-v 键值对描述报文</li>
<li>消息正文（body）：实际传输的数据，可以文本、图片、视频等二进制数据</li>
</ul>
<p>起始行和 header 统称为请求头，正文称为请求体。http 协议规定报文必须有请求头，且请求头后必须要有一个“空行”，<strong>可以没有请求体</strong></p>
<p>。<img src="/2023/11/23/http/image-20231205205621667.png" class="" title="image-20231205205621667"></p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</p>
<img src="/2023/11/23/http/image-20231207213347547.png" class="" title="image-20231207213347547">

<ul>
<li>version：HTTP 协议的版本号，通常是 HTTP&#x2F;1.1。</li>
<li>状态码：是一个十进制数字，以代码的形式表示服务器对请求的处理结果。<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
</li>
<li>原因短语：是状态码的简短文字描述，例如 ok、Not Found。</li>
</ul>
<h4 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h4><p>属于提示信息，是协议处理的中间状态，实际能够用到的时候很少，可以忽略。</p>
<h4 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h4><p>表示服务器收到并成功处理了客户端的请求。</p>
<p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<p>“<strong>206 Partial Content</strong>”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99&#x2F;2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>
<h4 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h4><p>重定向，即表示资源位置发生了变化，需要客户端使用新的URI重新进行请求。</p>
<p>“<strong>301 Moved Permanently</strong>”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</p>
<p>与它类似的是“<strong>302 Found</strong>”，曾经的描述短语是“<strong>Moved Temporarily</strong>”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>
<p>301 和 302 都会在响应头里使用字段<strong>Location</strong>指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</p>
<p>“<strong>304 Not Modified</strong>” 用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p>
<h4 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h4><p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p>
<p>“<strong>400 Bad Request</strong>”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<p>“<strong>403 Forbidden</strong>”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>
<p>“<strong>404 Not Found</strong>”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<p>4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>
<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
<h4 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h4><p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p>
<p>“<strong>500 Internal Server Error</strong>”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>
<p>“<strong>501 Not Implemented</strong>”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>
<p>“<strong>502 Bad Gateway</strong>”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>
<p>“<strong>503 Service Unavailable</strong>”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“<strong>Retry-After</strong>”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<h2 id="安全与幂等"><a href="#安全与幂等" class="headerlink" title="安全与幂等"></a>安全与幂等</h2><p>安全有两个含义：分别是传输数据的安全、服务器数据的安全。其中传输过程的安全可以通过 https 协议来完成，请求方法中只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。</p>
<p>幂等指的是多次执行某个操作结果都是相同的。在这个定义下，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。而 POST、PUT 操作会修改数据状态，多次重复操作后数据会有不同的表现形式，因此是不幂等的。</p>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>http 协议天生就是不安全的，可以给通信过程中定义以下四个条件，只有满足这些条件我们才认为此次网络通信是安全的。</p>
<ul>
<li>完整性：数据在传输前后没有经过修改。</li>
<li>机密性：传输过程中的数据对第三方不可见。</li>
<li>身份认证能力：确保发送的目的地是自己熟知的。</li>
<li>不可否认：发送过的行为无法否认。</li>
</ul>
<p>https 协议的默认端口号是443，其余的请求应答等（除去安全部分）都和 http 相同。https 可以实现安全传输的核心原因在于下层的通信协议发生了改变（SSL&#x2F;TSL 属于传输层协议），收发报文不再使用 Socket API，而是调用专门的安全接口。</p>
<img src="/2023/11/23/http/image-20231211110959590.png" class="" title="image-20231211110959590">

<h4 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h4><p><strong>对称加密</strong></p>
<p>加密和解密使用同一套密钥，加解密速度快，难点在于对密钥的传输，如果密钥被窃取，那么加密也就失去了意义。</p>
<p><strong>非对称加密</strong></p>
<p>分为公钥和私钥，公钥加密的数据可以使用私钥解开，但是加解密性能不好，实际传输过程使用会对拖垮服务。</p>
<p>TLS 里使用的<strong>混合加密</strong>方式，使用的就是把对称、非对称加密混合的办法：</p>
<ol>
<li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</li>
<li>然后用随机数产生对称算法使用的“<strong>会话密钥</strong>”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</li>
<li>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</li>
</ol>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>黑客可以伪造身份发布公钥。如果使用假的公钥，混合加密就完全失效了。所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。</p>
<p>实现完整性的手段主要是<strong>摘要算法</strong>（Digest Algorithm），也就是常说的散列函数、哈希函数。它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，并且细微的不同都会造成摘要结果的剧烈变化。</p>
<p>目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。</p>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。因此只要在原文后附上它的摘要，就能够保证数据的完整性。</p>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p><strong>CA</strong>（Certificate Authority，证书认证机构）。它具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p>
<p>公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的。</p>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>统一资源标识符（URI）是一个字符串，用来唯一的标识一个资源，这个资源可以是互联网上的资源、也可以是磁盘上的文件、甚至可以是一封邮件，它通常由 schema、host、port、path、query param 组成，有些部分可以省略。</p>
<img src="/2023/11/23/http/image-20231207204846046.png" class="" title="image-20231207204846046">

<ul>
<li>scheme：协议名，表示资源使用哪种协议来访问，包括：http、https、ftp、file。</li>
<li>authority：表示资源所在的主机名，表现形式为主机加端口号，其中主机名不可以省略，端口号可以省略。</li>
<li>path：表示资源所在的位置，以 &#x2F; 开头。</li>
<li>查询参数：以 ？开始，多个k&#x3D;v以 &amp; 连接。</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>uri 内除了英文和数字以外也存在包含中文、&amp;等特殊字符的场景，由于在 URI 里只能使用 ASCII 码，因此这种场景就需要进行编码操作。编码对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式，直接**把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个%**。有了编码操作后，uri可以支持任意的字符集用任何语言来标记资源。</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>http1.1 以前使用的都是短连接进行管理，所谓短连接就是每次请求-响应结束后就关闭 TCP 连接，而 TCP 连接的建立需要三次握手、关闭需要四次挥手，这就导致可能建立连接的花费比传输数据还要高。</p>
<p>后续 http 改进了这一点，默认使用长连接：Connection: keep-alive，所谓长连接即通信结束后服务器不会立刻释放掉此次连接，在连接空闲超过指定时间，或请求次数达到指定数目后再关闭连接。这也会引发出一个新的问题，服务器维护一个建立的连接需要耗费一定的资源，如果每个请求都是空闲请求，那么资源很快会被打满，无法给真正需要通信的对象服务。</p>
<h3 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h3><p>web 服务器的瓶颈不在 CPU 资源，作为一种 IO 密集型服务，处理能力的关键在于网络收发，而网络 I&#x2F;O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。普通的多线程处理模型此时会切换线程，多个并发看下来阻塞情况不会太严重，但是由于需要频繁切换进程、以及需要保护临界区资源，多数资源就耗费在了非业务处理上。</p>
<p>nginx 使用多路复用技术（epoll），把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。这种方式可以消除掉 IO 阻塞，把资源都用来做核心业务，每个请求处理单独来看是分散、阻塞的，但因为都复用到了一个线程里，所以资源的利用率非常高。</p>
]]></content>
  </entry>
  <entry>
    <title>rpc</title>
    <url>/2024/06/30/rpc/</url>
    <content><![CDATA[<h2 id="RPC-的定义"><a href="#RPC-的定义" class="headerlink" title="RPC 的定义"></a>RPC 的定义</h2><p>RPC 的全称是 Remote Procedure Call，即远程过程调用，实现了跨网络调用其他服务就像调用本地服务一样的模式。简单来说 RPC 替我们封装了网络层繁琐的开发开发，通过增强代理的方式嵌入进去，这样我们只需要编写业务逻辑即可调用远程服务。RPC 的使用范围非常广泛，不仅仅约束在接口维度，包括MQ Client 和 MQ Server 间的通信、Redis Client 和 Redis Server 间的通信、JDBC 和 MySQL 间的通信都属于 RPC 通信。</p>
<img src="/2024/06/30/rpc/826a6da653c4093f3dc3f0a833915259.jpg" class="" title="img">

<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>由于跨网络的特性，一次 RPC 调用通常要经过序列化、协议编码、解码、反序列化的过程。当被调用者接收到一堆二进制字节后首先要对这些二进制进行解码和反序列化，这样才能定位到本次调用的具体方法。基于性能的考虑，RPC 调用通常是基于 TCP 层，TCP 接收到的二进制数据是没有分隔的，TCP 窗口可能会对多次调用进行合并，下游必须解析出合并前的数据边界，这就需要指定的协议格式了。也就是说 <strong>RPC 协议是为了避免语义不一致的事情发生，需要在发送请求的时候设定一个边界，然后在收到请求的时候按照这个设定的边界进行数据分割</strong>。这个边界语义的表达，就是所说的协议。</p>
<p>RPC 协议和 http 协议一样，同属于应用层协议。多数框架不使用 http 作为通信协议主要有以下几个考虑：</p>
<ol>
<li>RPC 调用的每个请求都需要有响应，而 http 请求是无状态协议，无法对每次请求调用关联上对应的相应，每次请求都要重建链接。</li>
<li>http 的协议头过于臃肿，存在不少无用的内容，基于性能的考虑。</li>
</ol>
<p>一个完善的协议通常包括固定部分、不定长的协议头、不定长的协议体</p>
<img src="/2024/06/30/rpc/2a202f980458baca9fc50c53275c6772.jpg" class="" title="img">

<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。接口的请求对象需要序列化为二进制数据，然后交给 RPC 协议进行编码，这样才能进行网络发送。</p>
<p>序列化协议有多种：JDK 原生序列化、JSON、Hessian、Protobuf等。考虑选择序列化协议的考虑点：</p>
<ol>
<li>性能：生成的二进制内容越少，网络传输速度越快，序列化速度越快性能越好。</li>
<li>兼容：跨语言、跨版本的向后兼容能力。</li>
<li>安全性：是否存在安全漏洞。</li>
</ol>
<h3 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h3><p>网络通信是整个 RPC 调用流程的基础。一次 RPC 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。服务调用者通过网络 IO 发送一条请求消息，服务提供者接收并解析，处理完相关的业务逻辑之后，再发送一条响应消息给服务调用者，服务调用者接收并解析响应消息，处理完相关的响应逻辑，一次 RPC 调用便结束了。</p>
<p>常见的网络 IO 模型分为四种：同步阻塞 IO（BIO）、同步非阻塞 IO（NIO）、IO 多路复用和异步非阻塞 IO（AIO）。在这四种 IO 模型中，只有 AIO 为异步 IO，其他都是同步 IO。</p>
<p>RPC 通信中一般都会选择 IO 多路复用方案。为了保证可靠的传输，底层的通信协议通常选择 TCP 协议。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>项目中使用 RPC 的时候通常通过 maven 引入一个服务提供方的依赖后，就可以进行依赖注入了，接着调用依赖中的方法即可拿到方法结果。服务提供方不会把接口的具体实现放在依赖中，但是我们还是调用到了服务方部署的服务，这用的就是动态代理技术。</p>
<p>RPC 会自动给接口生成一个代理类，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类。这样在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样就可以在生成的代理类里面，加入远程调用逻辑。</p>
<p>RPC 框架选择动态代理方案的时候会从三个角度去考虑：</p>
<ul>
<li>因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小。</li>
<li>生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效。</li>
<li>编码复杂度，如API设计是否好理解、社区活跃度、还有就是依赖复杂度等等。</li>
</ul>
<p>一个完整的 RPC 框架包含以下部分。</p>
<ul>
<li>入口层：在 RPC 调用的起点帮助用户屏蔽了远程调用的细节，同时可以按照权重、健康度、分组等对所有的可以调用的远程服务进行过滤找到最适合的一个调用服务，链路追踪则是在RPC调用端在访问服务端时，在发送请求消息前会触发分布式跟踪埋点，在接收到服务端响应时，也会触发分布式跟踪埋点，并且在服务端也会有类似的埋点。这些埋点最终可以记录一个完整的Span，而这个链路的源头会记录一个完整的Trace，最终Trace信息会被上报给分布式链路跟踪系统。</li>
<li>集群层：RPC 框架通过集群化消息总线，对服务发现、连接管理、路由等进行控制，使用推拉结合的方式不完全保障数据的强一致性，极大降低了集群的负载压力。</li>
<li>协议层：RPC 框架的协议由专门的插件负责，可以支持多种协议。</li>
<li>传输层：最终的网络传输模块，可以使用 TCP 或和 HTTP 传输。</li>
</ul>
<img src="/2024/06/30/rpc/image-20240716151001307.png" class="" title="image-20240716151001307">
]]></content>
  </entry>
  <entry>
    <title>java容器</title>
    <url>/2021/12/29/java%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><img src="/2021/12/29/java%E5%AE%B9%E5%99%A8/image-20210914185116246-fbc941bd2cb249e5af06169021c82c74.png" class="" title="image-20210914185116246">

<h3 id="1-Set-无序的、不可重复的"><a href="#1-Set-无序的、不可重复的" class="headerlink" title="1. Set(无序的、不可重复的)"></a>1. Set(无序的、不可重复的)</h3><ul>
<li>TreeSet(有序，唯一,不能存储null): 基于红黑树(自平衡的排序二叉树)实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet(无序，唯一，可以存储一个null)：基于<code>HashMap</code>实现，支持快速查找，底层采用<code>HashMap</code>来保存元素，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet(可以存储一个null)：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li>
</ul>
<h3 id="2-List-有序的、可重复的，可以存储多个null值"><a href="#2-List-有序的、可重复的，可以存储多个null值" class="headerlink" title="2. List(有序的、可重复的，可以存储多个null值)"></a>2. List(有序的、可重复的，可以存储多个null值)</h3><ul>
<li>ArrayList：基于动态数组<code>Object[]</code>实现，支持随机访问，线程不安全。</li>
<li>Vector：和 ArrayList 类似<code>Object[]</code>实现，但它是线程安全的。</li>
<li>LinkedList：基于<strong>双向链表</strong>实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p>java.util.Arrays.asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Queue-有序的、可重复的"><a href="#3-Queue-有序的、可重复的" class="headerlink" title="3. Queue(有序的、可重复的)"></a>3. Queue(有序的、可重复的)</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><img src="/2021/12/29/java%E5%AE%B9%E5%99%A8/map-5cf72e426f3e4eecb9188f54c5a25f0a.png" class="" title="map">

<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap</li>
<li><del>HashTable</del></li>
<li>LinkedHashMap：继承自 <code>HashMap</code>，使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h3 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h3><p><strong>HashMap 的性能表现非常依赖于哈希码的有效性</strong></p>
<ol>
<li><p>JDK1.8之前<br>JDK1.8之前 HashMap 底层是 数组和链表 结合在一起使用也就是链表散列。<br>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。链表插入节点时使用头插法插入。扩容则是需要元素个数大于等于阈值且要插入的节点没有空位时才会扩容。</p>
</li>
<li><p>JDK1.8之后<br>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。使用尾插法进行链表操作。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>loadFactor 加载因子<br>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p>threshold  临界值<br>threshold &#x3D; capacity * loadFactor，当 Size&gt;&#x3D;threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p>
</li>
</ul>
<h1 id="2-疑难点"><a href="#2-疑难点" class="headerlink" title="2. 疑难点"></a>2. 疑难点</h1><h2 id="Collection疑难点"><a href="#Collection疑难点" class="headerlink" title="Collection疑难点"></a>Collection疑难点</h2><p><a href="https://javaguide.cn/java/collection/arraylist-source-code/">ArrayList源码分析</a></p>
<h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h3><ol>
<li>是否保证线程安全： <code>ArrayList</code>和<code>LinkedList</code>都是不保证线程安全</li>
<li>底层数据结构：<code>Arraylist</code>底层使用的是<code>Object</code>数组；<code>LinkedList</code>底层使用的是<strong>双向链表</strong>数据结构</li>
<li>插入和删除是否受元素位置的影响：  <ul>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。</li>
<li>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。</li>
<li>内存空间占用： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在链表的结构上</li>
</ol>
<h3 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h4><p>（JDK8）ArrayList 有三种方式来初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p>
<h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h4><h5 id="2-1-add方法"><a href="#2-1-add方法" class="headerlink" title="2.1. add方法"></a>2.1. <code>add</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>add</code>方法调用了<code>ensureCapacityInternal(size + 1)</code></p>
<h5 id="2-2-ensureCapacityInternal-方法"><a href="#2-2-ensureCapacityInternal-方法" class="headerlink" title="2.2. ensureCapacityInternal()方法"></a>2.2. <code>ensureCapacityInternal()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。<br>否则直接进入<code>ensureExplicitCapacity()</code>方法</p>
<h5 id="2-3-ensureExplicitCapacity-方法"><a href="#2-3-ensureExplicitCapacity-方法" class="headerlink" title="2.3. ensureExplicitCapacity()方法"></a>2.3. <code>ensureExplicitCapacity()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。</li>
<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</li>
<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>
<li>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</li>
</ul>
<h5 id="2-4-grow-方法"><a href="#2-4-grow-方法" class="headerlink" title="2.4. grow()方法"></a>2.4. <code>grow()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右</strong></p>
<ul>
<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 hugeCapacity 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>
<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>
</ul>
<h4 id="3-System-arraycopy-和-Arrays-copyOf"><a href="#3-System-arraycopy-和-Arrays-copyOf" class="headerlink" title="3. System.arraycopy() 和 Arrays.copyOf()"></a>3. System.arraycopy() 和 Arrays.copyOf()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   复制数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                       Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要是为了给原有数组扩容</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">   	<span class="comment">// 申请一个新的数组</span></span><br><span class="line">       <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">       System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Map疑难点"><a href="#Map疑难点" class="headerlink" title="Map疑难点"></a>Map疑难点</h2><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">重新认识HashMap</a></p>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ol>
<li>线程是否安全：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。</li>
<li>效率：因为线程安全的问题，HashMap 要比 Hashtable 效率高一点，Hashtable基本被淘汰</li>
<li>对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li>初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。</li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带容量与负载因子的构造函数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line"><span class="comment">//确保不会超出最大容量</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保负载因子合法</span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//tableSizeFor()返回一个大于等于当前cap的一个数字，并且这个数字一定是2的次方数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带容量的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-与-equals-的相关规定："><a href="#hashCode-与-equals-的相关规定：" class="headerlink" title="hashCode()与 equals() 的相关规定："></a><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</h3><ol>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li><code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p>HashMap 通过 key 的 hashCode <strong>经过扰动函数（hash函数）处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度）</strong>。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的<code>hashCode()</code>方法，也就是说<strong>使用扰动函数之后可以减少碰撞</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 1.8 HashMap 的 hash 方法</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// 让h的高16位也参与运算</span></span><br><span class="line">     <span class="comment">// ^ ：按位异或，相同返回0，不同返回1</span></span><br><span class="line">     <span class="comment">// &gt;&gt;&gt;:无符号右移16位，忽略符号位，空位都以0补齐</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>右移16位，正好是hashcode的一半，自己的高半区和低半区异或运算就是<strong>为了混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。混合后的低位掺杂了高位的部分特征，这样高<strong>位的信息也会变相保留下来</strong>。</p>
<h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p><strong>++为了加快哈希计算以及减少哈希冲突++</strong></p>
<p><strong>加快计算</strong>：为了找到 KEY 的位置在哈希表的哪个槽里面，需要计算 hash(KEY) % 数组长度，但是 % 计算比 &amp; 慢很多，所以用 &amp; 代替 %，为了保证 &amp; 的计算结果等于 % 的结果需要把 length 减 1，也就是 hash(KEY) &amp; (length - 1)<br>因为扩容为 2 的倍数，根据 hash 桶的计算方法，元素哈希值不变而通过 % 计算的方式会因为 length 的变化导致计算出来的 hash 桶的位置不断变化。数据一致在漂移，影响性能！</p>
<p><strong>减少冲突</strong>：当length 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性；当length 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 hash &amp; (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间</p>
<p>因此，length 取 2 的整数次幂，是为了使不同 hash 值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列</p>
<h3 id="HashMap使用红黑树原因"><a href="#HashMap使用红黑树原因" class="headerlink" title="HashMap使用红黑树原因"></a>HashMap使用红黑树原因</h3><h4 id="为什么不使用二叉排序树"><a href="#为什么不使用二叉排序树" class="headerlink" title="为什么不使用二叉排序树"></a>为什么不使用二叉排序树</h4><p>问题主要出现在二叉排序树在添加元素的时候极端情况下会出现线性结构。由于二叉排序树左子树所有节点的值均小于根节点的特点，如果我们添加的元素都比根节点小，会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷，导致查询时间增长。</p>
<h4 id="为什么不使用平衡二叉树"><a href="#为什么不使用平衡二叉树" class="headerlink" title="为什么不使用平衡二叉树"></a>为什么不使用平衡二叉树</h4><p>红黑树不追求”完全平衡”，即不像AVL那样要求节点的 |balFact| &lt;&#x3D; 1，它只要求部分达到平衡，但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。<br>AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。<br>红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。</p>
<h3 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h3><p><strong>树化的两个条件：</strong></p>
<ol>
<li>链表长度超过树化阈值8</li>
<li>数组容量&gt;&#x3D;64<blockquote>
<p>出现红黑树的概率极小，正常情况下都是链表，阈值设置为8是为了减小树化的门槛，红黑树的节点占用空间比链表更大。链表过长的首要解决办法是数组扩容，只有数组长度够大才会进行树化操作。</p>
</blockquote>
</li>
</ol>
<p><strong>退化的两种情况：</strong></p>
<ol>
<li>在扩容拆分树时，树元素个数&lt;&#x3D;6会退化成链表</li>
<li>remove树节点时，若root、root.left、root.right、root.left.left中有一个为null，也会退化成链表</li>
</ol>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">	<span class="comment">//tab 引用当前散列表</span></span><br><span class="line">	<span class="comment">//first 桶中的头元素</span></span><br><span class="line">	<span class="comment">//e 临时node元素</span></span><br><span class="line">	<span class="comment">//n table数组长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 桶中不止一个节点，可能是链表 也可能是红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在链表中</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><img src="/2021/12/29/java%E5%AE%B9%E5%99%A8/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95-8433688f12514189a606a099192540fa.png" class="" title="HashMap的put方法.png">
<ol>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用红黑树插入方法<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>，如果不是就遍历链表插入(插入的是链表尾部)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//引用当前hashmap的散列表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">//表示当前Node元素</span></span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">//n:散列表数组的长度</span></span><br><span class="line">    <span class="comment">//i:当前键值对存放在散列表桶位的下标</span></span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//table:类的成员变量，散列表。</span></span><br><span class="line">    <span class="comment">//延迟初始化，第一次调用put时会初始化hashmap对象中最耗费内存的散列表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果散列表的当前桶位是null，那么直接创建一个链表头部节点即可。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">//当前桶位已经有值了,并且这个桶位的值已经赋值给变量p。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//e:桶位中要存放的键值对</span></span><br><span class="line">        <span class="comment">//k:临时变量key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//表示桶位中的元素key与要插入的key完全一致，后续需要进行替换操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果当前桶位的节点已经是红黑树了，那么直接往树里面添加新的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则肯定就是链表，此时链表的头节点已经比较完毕，与key不同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断是否已经到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//创建一个新的节点链接到链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//判断是否链表已经达到树化的条件，桶位外挂链表达到8就树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">//binCount从0开始，因此减一</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环比较链表中每一个元素，看是否能找到key相等的。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//建立循环条件</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发现有key相同的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//替换为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//回调函数</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//表示散列表结构被修改的次数，替换node元素的value不计数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//插入元素，size自增，判断现在是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>resize方法是将散列表进行初始化，或者基于当前容量扩大一倍。扩容会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。<br>Java8中扩容只需要满足一个条件：当前<strong>存放</strong>新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）,此刻触发扩容机制，将其容量扩大为2倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//引用扩容前的散列表</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//扩容前table数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//扩容前的扩容阈值,触发本次扩容的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap:新的table数组的长度</span></span><br><span class="line">    <span class="comment">//newThr:下次触发扩容的条件</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列表已经初始化过了，表示一次正常的扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//当扩容到一定程度，就不再扩容，且设置扩容条件为int最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左移运算符，num &lt;&lt; 1,相当于乘以2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//oldCap*2小于最大容量且oldCap大于等于默认容量，那么下次扩容阈值就扩大1倍。</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【暗含oldCap=0，散列表还未初始化】</span></span><br><span class="line">    <span class="comment">// 1.new HashMap(initCap,loadFactor)</span></span><br><span class="line">    <span class="comment">// 2.new HashMap(initCap)</span></span><br><span class="line">    <span class="comment">// 3.new HashMap(map)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">	<span class="comment">//【暗含oldCap=0且oldThr=0】</span></span><br><span class="line">	<span class="comment">//使用了默认的构造方法 new HashMap()</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当newThr=0时，计算新的扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建扩容后的散列表</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//本次扩容之前，table不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历oldTab中所有的桶位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">//当前node节点</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//当前桶位有数据</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//此时oldTab[j]已经用e引用过了，可以垃圾回收oldTab[j]</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//数组上没有外挂结点，直接将这个元素搬到新的散列表的某个位置中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//该桶位已经树化</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//链表的情况</span></span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">//低位链表：存放扩容之后的数组的下标位置，与扩容前下标位置一致</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//高位链表：存放扩容之后的数组的小标位置：当前数组下标位置 + 扩容前数组的长度</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//循环遍历整个链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p>主要体现在实现线程安全的方式上不同</p>
<ul>
<li>JDK1.8 ConcurrentHashMap 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>.Hashtable的底层数据结构类似都是采用 <strong>数组+链表</strong>的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作；而Hashtable使用synchronized 来保证线程安全，效率非常低下。</li>
</ul>
<img src="/2021/12/29/java%E5%AE%B9%E5%99%A8/JDK1.8%20%E7%9A%84%20ConcurrentHashMap-3ad1263b22994eb59e2a8565f513fb58.png" class="" title="JDK1.8 的 ConcurrentHashMap.png">

<p>JDK1.8后的<code>ConcurrentHashMap</code>取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))） synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h3 id="ConcurrentHashMap和SynchronizedMap的区别"><a href="#ConcurrentHashMap和SynchronizedMap的区别" class="headerlink" title="ConcurrentHashMap和SynchronizedMap的区别"></a>ConcurrentHashMap和SynchronizedMap的区别</h3><p>SynchronizedMap 是 Collections 集合类的私有静态内部类，其定义和构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1978198479659022715L</span>;</span><br><span class="line">          <span class="comment">// 用于接收传入的Map对象，也是类方法操作的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     </span><br><span class="line">          <span class="comment">// 锁对象</span></span><br><span class="line">        <span class="keyword">final</span> Object mutex;   </span><br><span class="line">  </span><br><span class="line">              <span class="comment">// 以下是SynchronizedMap的两个构造方法</span></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="built_in">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">            <span class="built_in">this</span>.m = m;</span><br><span class="line">            <span class="built_in">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//主要方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SynchronizedMap 实现线程安全的方法也是比较简单的，所有方法都是先对锁对象 mutex 上锁，然后再直接调用 Map 类型成员变量 m 的相关方法。这样一来，线程在执行方法时，只有先获得了 mutex 的锁才能对 m 进行操作。因此，跟 Hashtable 一样，在同一个时间点，只能有一个线程对 SynchronizedMap 对象进行操作，虽然保证了线程安全，却导致了性能低下。</p>
<h1 id="3-集合的线程安全"><a href="#3-集合的线程安全" class="headerlink" title="3. 集合的线程安全"></a>3. 集合的线程安全</h1><h2 id="ArrayList线程安全"><a href="#ArrayList线程安全" class="headerlink" title="ArrayList线程安全"></a>ArrayList线程安全</h2><p>故障现象：<code>java.util.ConcurrentModificationException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"><span class="comment">//2高频</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList</code>:<br>写操作在一个复制的数组上进行（容量+1），读操作还是在原始数组中进行，读写分离，互不影响。<br>写操作需要加锁，防止并发写入时导致写入数据丢失。<br>写操作结束之后需要把原始数组指向新的复制数组。</p>
<h2 id="HashSet线程安全"><a href="#HashSet线程安全" class="headerlink" title="HashSet线程安全"></a>HashSet线程安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">List&lt;String&gt; synSet = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"><span class="comment">//2，底层直接new CopyOnWriteArrayList&lt;&gt;()</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="HashMap线程安全"><a href="#HashMap线程安全" class="headerlink" title="HashMap线程安全"></a>HashMap线程安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Map&lt;String, String&gt; map=<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="4-容器操作"><a href="#4-容器操作" class="headerlink" title="4. 容器操作"></a>4. 容器操作</h1><h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//很少使用</span></span><br><span class="line">   <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入泛型	list.toArray(new String[0]);</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">       <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">           <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">           <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">       System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">       <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">           a[size] = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><ol>
<li><code>Arrays.asList()</code>方法返回的是<code>java.util.Arrays</code>的一个内部类,这个内部类并没有实现集合的修改方法，修改会抛出异常。</li>
<li><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></li>
<li><code>Arrays.stream(myArray).collect(Collectors.toList())</code></li>
</ol>
<h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><ol>
<li>使用普通 for 循环</li>
<li>foreach循环里不能进行增加删除操作，Iterator 的 remove&#x2F;add方法可以安全删除</li>
</ol>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2021/08/29/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="分布式事务理论"><a href="#分布式事务理论" class="headerlink" title="分布式事务理论"></a>分布式事务理论</h1><p>传统的一个工程内为了保证数据的一致性，使用本地事务。本地事务只能解决同一工程中的事务问题，而现在的场景更加复杂，关系到两个工程模块，怎么保证要么都成功，要么都失败？</p>
<p>分布式事务就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p>
<p>分布式事务场景：不同应用相同数据库，相同应用不同数据库，不同应用不同数据库。</p>
<p>分布式事务产生的原因：分布式系统异常除了本地事务那些异常之外，还有：机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失…</p>
<h2 id="1-分布式事务基础"><a href="#1-分布式事务基础" class="headerlink" title="1.   分布式事务基础"></a>1.   分布式事务基础</h2><p>数据库的 ACID 四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论。</p>
<h3 id="1-1-CAP"><a href="#1-1-CAP" class="headerlink" title="1.1.   CAP"></a>1.1.   CAP</h3><p>分布式存储系统的CAP原理（分布式系统的三个指标）：</p>
<ol>
<li><p><strong>C</strong>onsistency（一致性）：在分布式系统中的所有数据备份，在<strong>同一时刻是否同样的值</strong>。</p>
<p>对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</p>
</li>
<li><p><strong>A</strong>vailability（可用性）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（要求数据需要备份）</p>
</li>
<li><p><strong>P</strong>artition tolerance（分区容忍性）：大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。</p>
</li>
</ol>
<p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性是我们无法避免的</strong>。所以我们只能在一致性和可用性之间进行权衡，没有系统能同时保证这三点。要么选择CP、要么选择AP。</p>
<p>问题：zookeeper分布式协调组件 是 <strong>CP</strong> 还是 AP</p>
<p>动画：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p>我们的妥协：BASE</p>
<h3 id="1-2-BASE"><a href="#1-2-BASE" class="headerlink" title="1.2.   BASE"></a>1.2.   BASE</h3><p>​		BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来看看BASE中的三要素：</p>
<ol>
<li><p>Basically Available（<strong>基本可用</strong>）</p>
<p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。<br>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p>
</li>
<li><p>Soft state（软状态）</p>
<p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，<strong>允许不同节点间副本同步的延时</strong>就是软状态的体现。mysql replication的异步复制也是一种体现。</p>
</li>
<li><p>Eventually consistent（最终一致性）</p>
<p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
</li>
</ol>
<p>BASE模型是传统ACID模型的反面，不同于ACID，BASE强调牺牲高一致性，从而获得可用性，数据<strong>允许在一段时间内的不一致，只要保证最终一致就可以了</strong>。</p>
<h2 id="2-分布式事务解决方案"><a href="#2-分布式事务解决方案" class="headerlink" title="2.   分布式事务解决方案"></a>2.   分布式事务解决方案</h2><p>分布式事务是企业集成中的一个<strong>技术难点</strong>，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，<strong>几乎可以说是无法避免</strong>。</p>
<p>主流的解决方案如下：</p>
<ol>
<li>基于XA协议的两阶段提交（2PC）</li>
<li>TCC编程模式</li>
<li>消息事务+最终一致性</li>
</ol>
<h3 id="2-1-两阶段提交（2PC）"><a href="#2-1-两阶段提交（2PC）" class="headerlink" title="2.1.   两阶段提交（2PC）"></a>2.1.   两阶段提交（2PC）</h3><p>2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit<br>phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。</p>
<p>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</p>
<p>第二阶段：事务协调器要求每个数据库提交数据。</p>
<p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p>
<p>目前主流数据库均支持2PC【2 Phase Commit】</p>
<p>XA 是一个两阶段提交协议，又叫做 XA Transactions。</p>
<p>MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。</p>
<p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。</p>
<ol>
<li>两阶段提交涉及多次节点间的网络通信，通信时间太长！</li>
<li>事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多。</li>
<li>XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换会导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。</li>
</ol>
<p>对应的开源框架：atomikos</p>
<h3 id="2-2-TCC补偿式事务"><a href="#2-2-TCC补偿式事务" class="headerlink" title="2.2.   TCC补偿式事务"></a>2.2.   TCC补偿式事务</h3><p>是一种编程式分布式事务解决方案。</p>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC模式要求从服务提供三个接口：Try、Confirm、Cancel。</p>
<ul>
<li>Try：主要是对业务系统做检测及资源预留</li>
<li>Confirm：真正执行业务，不作任何业务检查；只使用Try阶段预留的业务资源；Confirm操作满足幂等性。</li>
<li>Cancel：释放Try阶段预留的业务资源；Cancel操作满足幂等性。</li>
</ul>
<p>整个TCC业务分成两个阶段完成：</p>
<p>第一阶段：主业务服务分别调用所有从业务的try操作，并在活动管理器中登记所有从业务服务。当所有从业务服务的try操作都调用成功或者某个从业务服务的try操作失败，进入第二阶段。</p>
<p>第二阶段：活动管理器根据第一阶段的执行结果来执行confirm或cancel操作。如果第一阶段所有try操作都成功，则活动管理器调用所有从业务活动的confirm操作。否则调用所有从业务服务的cancel操作。</p>
<p>举个例子，假如 Bob 要向 Smith 转账100元，思路大概是：</p>
<p>我们有一个本地方法，里面依次调用</p>
<ol>
<li><p>首先在 Try 阶段，要先检查Bob的钱是否充足，并把这100元锁住，Smith账户也冻结起来。</p>
</li>
<li><p>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</p>
</li>
<li><p>如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</p>
</li>
</ol>
<p>缺点：</p>
<ul>
<li>Canfirm和Cancel的<strong>幂等性</strong>很难保证。</li>
<li>这种方式缺点比较多，通常在<strong>复杂场景下是不推荐使用</strong>的，除非是非常简单的场景，非常容易提供回滚Cancel，而且依赖的服务也非常少的情况。</li>
<li>这种实现方式会造成<strong>代码量庞大，耦合性高</strong>。而且非常有局限性，因为有很多的业务是无法很简单的实现回滚的，如果串行的服务很多，回滚的成本实在太高。</li>
</ul>
<p>不少大公司里，其实都是自己研发 TCC 分布式事务框架的，专门在公司内部使用。国内开源出去的：ByteTCC，TCC-transaction，Himly。</p>
<h3 id="2-3-消息事务-最终一致性"><a href="#2-3-消息事务-最终一致性" class="headerlink" title="2.3.   消息事务+最终一致性"></a>2.3.   消息事务+最终一致性</h3><p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。</p>
<p>虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。</p>
<p>适用于高并发最终一致</p>
<p>低并发基本一致：二阶段提交</p>
<p>高并发强一致：没有解决方案</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式数据库</title>
    <url>/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="选择分布式数据库"><a href="#选择分布式数据库" class="headerlink" title="选择分布式数据库"></a>选择分布式数据库</h2><p>以实际使用场景来看，假设有一个广告系统记录了所有用户在任何时刻触发不同广告的消耗明细，每天大约能产生 5000W 条用户消耗数据明细。现在需要实现一个供流量主可以实时查询这些数据的功能，此时应该选用哪种类型的数据库，在这个应用场景下数据库需要满足以下特点：</p>
<ol>
<li>数据量巨大，且面向 C 端用户查询。</li>
<li>频繁写入且频繁查询，要支持范围查询，且查询性能需要在毫秒级。</li>
<li>数据存在倾斜的可能性。</li>
</ol>
<h3 id="传统数据库的瓶颈"><a href="#传统数据库的瓶颈" class="headerlink" title="传统数据库的瓶颈"></a>传统数据库的瓶颈</h3><p>MySQL 数据库天生是单机数据库，即它只能运行在一台物理机器实例上，我们没有办法把他拆分开让同一个数据库同时运行在多台机器上。因此它的性能和物理机器实例的配置呈正相关，受到机器配置的制约，机器的天花板上限较低。但是它的好处就是架构较为简单，使用起来更加方便。</p>
<p>单体数据库面临高并发场景的时候，还是会碰到写入性能不足的问题，要解决这个问题，那么就是进行分库分表。分库分表本质是在多个单体数据库前增加一个代理层，由代理层进行数据路由。进而会带来这几个问题：</p>
<ol>
<li>分表键的选择。在数据存储时根据<strong>分表键、分表的数量</strong>进行路由，这两个参数一经选择很难改变，后续所有查询都要根据这个规则进行。如果以后发现分表数量不够需要增加或者分表键需要修改，那么存量的数据查询会产生问题。</li>
<li>高并发写的支持。即使我们可以选择主从来分担主库的读压力，但是<strong>所有写操作都必须在主库进行</strong>，多数情况下 MySQL 集群只有一个主库，所有写操作必须在主库进行，单机器实例面对超高并发的写事务、加锁操作会存在瓶颈。</li>
<li>代码的侵入性。分库分表通常是在代码层面选择不同数据库，因此代码中通常会带上相关的硬编码，对后续业务迁移变化带来风险。</li>
</ol>
<p>ks 当前的分库分表组件如下，通过独立的逻辑层（Shard-JDBC）建立数据分片和路由规则，使应用能够使用多个单体数据库，实现存储能力、并发能力的扩展。但是<strong>组件耦合作为系统的一部分</strong>，需要额外的维护分表配置，对应用侵入较严重。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240406230729007.png" class="" title="image-20240406230729007">

<p>由于底层的数据库仍然是一个个的单体架构组成，因此代理层需要额外实现以下功能来完成业务使用：</p>
<ol>
<li>全局性的事务支持（ks 分片组件不支持，需要把事务要都落在同一实例上，避免跨实例的事务，否则可能会有不一致）。</li>
<li>额外的计算能力。由于数据存储在不同单体节点，每个数据节点只能看到一部分数据，有些查询运算是无法处理的，比如排序、多表关联等。所以，代理节点要增强查询计算能力，支持跨多个单体数据库的查询。</li>
<li>分片信息管理。需要维护分片的数据信息，ks 通过 kconf 和 zk 来维护。</li>
</ol>
<p><strong>为什么 MySQL 单体数据库容易发生瓶颈？</strong></p>
<p>我们都知道 MySQL 作为一种持久化数据库，必然要和磁盘进行交互。而操作系统对磁盘的访问是以块为结构，其中一块的大小为 4kb，为了能够最大提升读取一次磁盘的效率，B+ 树选择让树的一个节点大小等于磁盘的一块大小，其中一个节点保存m个有序数组元素，为了尽可能多的存储索引数据，B+树把节点分为叶子节点和内部节点，其中叶子节点保存一行的数据，内部节点只有 key 和索引，这样做有两个好处：</p>
<ol>
<li>由于内部节点不保存具体数据，因此相同大小可以保存更多索引，这样可以查找时可以更少的磁盘 IO。</li>
<li>磁盘的一次 IO 读出了更多的索引，一个节点保存 m 个有序数组，导致 B+树的高度降低，也有效减少了磁盘 IO。</li>
</ol>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/B+%E6%A0%91.png" class="" title="B+树">

<p>B+树为了维持这样的平衡M叉树结构，插入、删除时必须定位到 key 对应的位置再进行插入和删除，其中有几个方面会产生瓶颈：</p>
<ol>
<li>如果单个节点的内存已满，还需要和相邻的节点以及父节点进行分裂合并操作。</li>
<li>每张表的<strong>一次新增就是对磁盘的一次随机 IO</strong>，而MySQL服务的上层应用同时会对不同的表进行新增删除。</li>
</ol>
<p>虽然MySQL 使用了 redoLog 来避免每次新增都去写磁盘，但是该 log 是环形固定容量，待日志容量受限很小的数据变化也要去修改数据页，也就是说一旦单体数据库多表吞吐量打满就会开始大量的随机 IO，磁盘操作代价会导致系统性能急剧下降。</p>
<h3 id="什么是分布式数据库"><a href="#什么是分布式数据库" class="headerlink" title="什么是分布式数据库"></a>什么是分布式数据库</h3><p>与上述介绍不同的是，分布式数据库把所有技术细节收敛到数据库内部，对外以一个整体面对系统应用。分布式数据库就是一个提供高容量、高并发、高可用、可扩展的关系型数据库。</p>
<p>分布式数据库有两个方向：</p>
<ol>
<li>进化后的单体式数据库（PGXC）。上边说的 sharding-MySQL 继续进化其实就是一种分布式数据库，但是它的单一节点仍然是一个单体数据库。</li>
<li>原生分布式数据库（NewSQL）。基础是一个 K&#x2F;V 键值对数据库，其计算和存储分离，最小的存储单位称为一个分片，可以动态扩展。</li>
</ol>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240407204610504.png" class="" title="image-20240407204610504.png">

<p>单体式数据库实现高可用的一个重要手段：主从复制，这是一种粗粒度的完整复制整个主库的手段。而NewSQL采用了精细化的数据控制，每个分片空间通常控制在百 M 之内，通过以分片为单位采用 Paxos 或 Raft 等共识算法。这样NewSQL 就实现了更小粒度的高可靠单元，获得了更高的系统整体可靠性。</p>
<p>分布式数据库可以提供海量并发、海量存储的关键能力在于分片（Regin），分片根据特定规则将切分好的数据记录分布到多个节点上，从而实现更强的存储和计算能力。</p>
<h4 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h4><h5 id="Hash-分片"><a href="#Hash-分片" class="headerlink" title="Hash 分片"></a>Hash 分片</h5><p>根据数据记录中指定关键字的 Hash 值将数据记录映射到不同的分片中，关键在于 hash 键和 hash 函数的选择。</p>
<p>这种策略通过 hash 函数将数据<strong>均匀</strong>分布到所有分片中，这是它的优点。</p>
<p>但是如果分片数发生了变化，数据就要重新 Hash 计算，从而带来大规模的数据迁移。因此这种方式对于<strong>扩展性是不友好</strong>的。另外业务上的热点数据如果被分配到同一个分片上，也是系统的一个潜在瓶颈。</p>
<h5 id="Range-分片"><a href="#Range-分片" class="headerlink" title="Range 分片"></a>Range 分片</h5><p>NewSQL 的 Range 分片，多数是用<strong>主键</strong>作为关键字来分片的，当然主键可以是系统自动生成的，也可以是用户指定的。但是<strong>主键必须保证唯一性</strong>，用户实现唯一性就会导致这种控制比较复杂，使用成本较高。但如果使用自动生成主键的话基本可以认为，分片是一个系统自动处理的过程，用户是感知不到的。这样做的显然提升了系统的易用性。</p>
<h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><p>当单个分片的数据量超过设定值时，分片可以一分为二，这样就可以保证每个分片的数据量较为均衡，避免了大量数据聚集在相同的分片中。多个数据量较少的分片，会在一定的周期内被合并为一个分片。同时分片也会被均衡地调度到各个节点上，节点间的数据量也保持总体平衡。</p>
<p>除了维持数据量的平衡外，分布式数据库还会控制节点的访问压力。如果R2、R3 中存储的数据都是热点数据，这时候系统会根据负载情况，将 R2 和 R3 分别调度到不同的节点，来均衡访问压力。</p>
<h2 id="分布式数据库的ACID"><a href="#分布式数据库的ACID" class="headerlink" title="分布式数据库的ACID"></a>分布式数据库的ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。分布式数据库实现原子性常见的有两种协议：TCC、2PC。</p>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>一种面向应用层的补偿式的分布式协议，核心步骤包括 try、confirm、cancel，对业务代码侵入较重。TCC 规定协议的参与方有两种角色，分别是<strong>事务管理器和事务参与者，</strong>其中事务管理器只能有一个，而事务参与者可以为多个。</p>
<blockquote>
<p>补偿机制：</p>
<p>在分布式事务出现异常时，通过一系列的操作，尽可能使得分布式事务状态回滚到之前的状态，从而避免分布式事务产生不一致的情况。</p>
</blockquote>
<ul>
<li>try 阶段：尝试执行阶段，检查所需要的资源，具有排他性。</li>
<li>confirm 阶段：所有 try 分支都返回成功，事务管理器会进行confirm，此阶段不执行检查操作，会直接进行业务操作，如果因为网络原因导致 confirm 失败，会一直重试。</li>
<li>cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源。如果由于网络问题，或者服务器临时故障，那么事务管理器会进行重试，最终成功。</li>
</ul>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/tcc-e34cb994.png" class="" title="TCC 模式">

<p>可以看到 try、confirm、cancel 三个操作都需要业务来自己实现对应接口，由于相应的业务操作都需要编码实现，因此 TCC也叫做由业务方细粒度控制的<strong>侵入式分布式事务</strong>。</p>
<blockquote>
<p><a href="https://seata.apache.org/zh-cn/docs/user/mode/tcc">https://seata.apache.org/zh-cn/docs/user/mode/tcc</a></p>
<p>Seata TCC 模式</p>
</blockquote>
<p>TCC的<strong>优点</strong>：</p>
<ol>
<li>完全不依赖底层数据库，可以实现跨数据库的分布式事务功能。</li>
<li>自由编码实现，可以自己控制锁力度，并发量会更高一点。</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要业务系统自行实现 Try，Confirm，Cancel 三个操作，对业务系统有着非常大的入侵性，设计相对复杂。</li>
<li>不同操作依赖网络进行交互，因此设计阶段操作接口必须满足幂等性，防止重试时造成数据不一致。</li>
</ol>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>又被称为两阶段提交，两个阶段分别是 prepare 和 commit，具有事务管理器、资源管理器两个角色。两阶段提交依赖底层数据库的事务能力，底层的单体数据库也被称为资源管理器。</p>
<p>借助于底层单体数据库的事务回滚和提交能力，使用一个全局的事务管理器就能实现一个分布式事务。</p>
<p>第一阶段：向数据库发送要执行的 sql，并得到是否可以提交的回复。</p>
<p>第二阶段：一阶段都返回成功则向数据库提交事务，否则向数据库提出回滚操作。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240518205539667.png" class="" title="image-20240518205539667">

<p><strong>优点：</strong>利用了单体数据库的事务能力，不侵入业务代码，同时实现简单，这是它最大的优点。</p>
<p>缺点：</p>
<ol>
<li>事务管理器存在单点故障，如果数据库在 commit 前管理器挂了，那么所有单体数据库都会被阻塞。</li>
<li>执行时数据库需要锁定对应的行，如果其他事务刚好也要操作这些数据行，那它们就只能等待。这种设计可能会导致分布式事务出现高延迟和性能的显著下降。</li>
<li><strong>事务管理器需要和所有单体数据库通信</strong>，如果因为网络原因某些数据库没有收到 commit 指令，那么会出现数据不一致的情况。</li>
</ol>
<h4 id="Percolator-（2PC-的改进）"><a href="#Percolator-（2PC-的改进）" class="headerlink" title="Percolator （2PC 的改进）"></a>Percolator （2PC 的改进）</h4><p>Percolator模型是对 2PC 的改进，TIDB 的分布式事务就是基于这个模型实现的。针对 2PC 的单点故障、数据不一致、进行了改进。</p>
<p>准备阶段时事务管理器会给每个分片发送对应数据执行请求，每个分片收到请求后写入一个新记录，新纪录会被加上锁，只有当前事务才能读取到锁内容，所有分片的行锁只有一个主锁，主锁会随机分配到某个分片上，其余的锁指向主锁记录。与此同时还会写下本次操作日志。</p>
<p>准备阶段结束的时候，两个分片都增加了私有版本记录，余额正好是转账顺利执行后的数字。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/e610bcb9d4fa5b53cf9e7f293b4da425.jpg" class="" title="img">

<p>之后进入提交阶段，其中事务管理器<strong>只会和拥有主锁的分片</strong>进行通信发出 commit 指令，相比于 2PC 模型，单独的网络通信就解决了网络通信造成的数据不一致现象。通过这种巧妙的设计减少了事务管理器和分片的通信次数，但是其余分片的副锁仍然存在，此时其他事务读取到分片数据时会根据指针去查找主锁记录，由于主锁已经释放，这条数据就对所有事务开放了，但是增加了一次指针读取操作。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/f2a39536e65c8e0f4c282a0e05274160.jpg" class="" title="img">

<p>因此Percolator模型增加了一个子线程，通过Lazy+异步线程更新非主锁的记录。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/c8dc734cd33a8149eeb1ffb2f435e6d2.jpg" class="" title="img">

<p>Percolator 通过日志和异步线程的方式弱化了单点故障。</p>
<p>一是，Percolator 引入的异步线程可以在事务管理器宕机后，回滚各个分片上的事务，提供了善后手段，不会让分片上被占用的资源无法释放。二是，事务管理器可以用记录日志的方式使自身无状态化，日志通过共识算法同时保存在系统的多个节点上。这样，事务管理器宕机后，可以在其他节点启动新的事务管理器，基于日志恢复事务操作。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>单体数据库通常使用 MVCC 来维护一份数据的历史版本，通过全局递增的<strong>事务管理器</strong>为每个事务分配一个事务 id，通过分配活跃的事务id 列表来实现不同的隔离方式。</p>
<p>分布式数据库的两种阵营采用了两种不同的方式满足隔离性</p>
<ul>
<li>PGXC：它的底层数据源就是由一个个单体数据库组成的，因此它的实现方式和单体数据库类似，区别在于分布式数据库需要一个全局事务管理器来颁发事务 id 和维护全局事务列表。这也是它的一个风险点-单点风险。</li>
<li>NewSQL：NewSQL 架构的分布式数据库没有普遍使用快照处理读写事务。如TiDB 如果两个事务操作同一个数据项。其中，事务 T1 执行写操作，由 Prewrite 和 Commit 两个阶段构成，T2 在这两个阶段之间试图执行读操作，但是 T2 会被<strong>阻塞</strong>，直到 T1 完成后，T2 才能继续执行。</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>分布式事务的一致性可以根据是否跨节点分为两个场景：</p>
<ul>
<li>不跨region：相当于传统的单节点数据库，和单实例一样，事务保证性即可，无需复杂的确认过程。至于多个副本之间的数据一致性，通过<strong>raft协议</strong>和事务日志应用保证leader和follower region之间的数据一致性。</li>
<li>跨region：通过两阶段提交，事务完成primary row后即可返回，后台线程和日志重试保证seconary row 异步提交</li>
</ul>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>TiDB也通过将数据持久化到磁盘中来实现持久性，确保一旦事务提交成功，数据不会丢失。</p>
<h2 id="分布式数据库的优化"><a href="#分布式数据库的优化" class="headerlink" title="分布式数据库的优化"></a>分布式数据库的优化</h2><p>由于分布式数据库的计算节点和数据存储节点是分离开来的，但是通常情况下查询数据都会带着查询语句，查询计算和数据存储密不可分。因此带来一个新的问题，即应该将数据传输到计算节点，还是应该将计算逻辑传输到数据节点。由于计算逻辑通常相对较轻，数据传输量比较大，因此多数分布式数据库都选择了把计算逻辑下沉到存储节点，这也叫做计算下推。</p>
<h3 id="计算下推"><a href="#计算下推" class="headerlink" title="计算下推"></a>计算下推</h3><p>如下图所示，当计算节点接收到客户端发来的查询条件时，会把查询条件发送到存储节点上，存储节点筛选数据通过网络传送到计算节点上，由计算节点进行 merge 操作并一起返回到客户端。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240520151735451.png" class="" title="image-20240520151735451.png">

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>计算下推是为了查询时减少无必要的网络 IO，本质是为了加速查询效率。单体数据库的索引可以分为一级索引（也叫主键索引或聚族索引）、二级索引，其中二级索引的叶子节点存储的是一级索引的值，如果一个查询命中了二级索引，通常需要进行一次回表来获取数据，这次回表会增加查询时间。</p>
<p>和单体数据库类似，分布式数据库按照索引的实现方式可以分为分区索引和全局索引。分布式数据库索引存在两个问题：</p>
<ol>
<li>索引和数据不在一个分区中：这也意味着如果使用索引需要增加一次网络 IO</li>
<li>索引和数据在一个分区中，但是索引类型是分区索引（局部索引）。如果期望的是全局唯一性索引，不可避免的读操作需要网络 IO 回表，写操作需要分布式事务。</li>
</ol>
<p>所以，在使用分布式数据库时，是否有必要建立全局索引，是一个非常谨慎的决定。</p>
<p>为了尽可能实现索引和数据保存在同一个分区内，分布式数据库对索引进行了特殊的设计。分布式数据库的每个分区会对应存储一系列数据，通过 hash 或 range 方法最终会得到一个不重叠的 key 范围。当客户端进行操作时，相同的 key 最终都会落到同一个分区中。当新增一个键值对（Key&#x2F;Value）时，系统会先判断这个 Key 与哪个分片的区间匹配，而后就分配到那个匹配的分片中保存，匹配算法一般采用左前缀匹配方式。</p>
<p>索引 key 的命名方式如下所示：</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/c0ca6200c5c48e7bdd55665ba7a000d6.jpg" class="" title="分布式数据库&#x2F;c0ca6200c5c48e7bdd55665ba7a000d6.jpg">

<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/be44d5f54d968507bb1a22103427c188.jpg" class="" title="分布式数据库&#x2F;be44d5f54d968507bb1a22103427c188.jpg">

<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/7421287e27f875d8990f0f8f2492fdec.png" class="" title="img">

<h2 id="TiDB-的简单介绍"><a href="#TiDB-的简单介绍" class="headerlink" title="TiDB 的简单介绍"></a>TiDB 的简单介绍</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>TiDB 是基于 KV 存储实现的一种关系型分布式数据库，兼容 MySQL 协议和 MySQL 生态，并支持完整的分布式事务。它有三大模块组成，分别是：TiDB Server、TiKV、PD，之间的交互关系如下图。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240526102902064.png" class="" title="image-20240526102902064.png">

<ul>
<li>TiDB Server：用于计算使用，是无状态的，负责解析执行客户端发送来的 sql 语句，并接收整合存储模块发送的数据一并返回给客户端。这个模块不会成为分布式数据库的瓶颈，容量不够可以迅速扩张。</li>
<li>TiKV：分布式数据库的存储单元，所有数据最终都是保存在此，TiDB使用开源的高性能单体数据库RocksDB作为存储引擎。简单来说 TiDB 自己不会负责持久化数据到磁盘，而是交由RocksDB来实现，RocksDB 是一个单机的 Key-Value Map。</li>
<li>PD：负责调度整个存储引擎，掌握全局信息，可以对全局进行调度，作为一个中心节点，实现对系统的整体状况进行把控和调整。比如新增节点时数据的分化迁移，主从节点数量的控制，请求负载均衡、管理节点状态，包括手动上线&#x2F;下线节点，以及自动下线失效节点。PD 不断的通过 Store 或者 Leader 的心跳包收集信息，获得整个集群的详细数据，并且根据这些信息以及调度策略生成调度操作序列，每次收到 Region Leader 发来的心跳包时，PD 都会检查是否有对这个 Region 待进行的操作，通过心跳包的回复消息，将需要进行的操作返回给 Region Leader，并在后面的心跳包中监测执行结果。</li>
</ul>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240525143347079.png" class="" title="image-20240525143347079.png">

<p>为了保证数据的高可用，TiKV使用一致性协议 Raft 来实现主从节点的复制，其中客户端的每个数据变更都会落地转化为一条 Raft 日志，通过 Raft 的日志复制功能，将数据安全可靠地同步到 Group 的多数节点中。数据的写入是通过 Raft 这一层的接口写入，而不是直接写 RocksDB。基于此拥有了一个分布式的 KV存储系统。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/2_f87f04d11f.png" class="" title="Raft">

<p>接下来就是确定要把数据写入到哪个 KV 节点中，通常有两种方式：一种是按照 Key 做 Hash，根据 Hash 值选择对应的存储节点；另一种是<strong>分 Range</strong>，某一段连续的 Key 都保存在一个存储节点上。TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，每段区间叫做一个 <strong>Region</strong>，并且通过 PD 模块尽量保持每个 Region 中保存的数据不超过一定的大小(这个大小可以配置，目前默认是 96mb)。每一个 Region 都可以用 StartKey 到 EndKey 这样一个左闭右开区间来描述。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/3_e764da277c.png" class="" title="Region">

<p>PD 模块会均匀的把所有Region划分到不同节点上，其中一个节点上的多个 Region 共用一个RocksDB实例，这样设计的原因是因为随机 I&#x2F;O 的性能远低于顺序 I&#x2F;O，所以 TiKV 使用同一个 RocksDB 实例来存储这些数据，以便不同 Region 的写入可以合并在一次 I&#x2F;O 中，并且尽量保证每个节点上服务的 Region 数量差不多。TiKV 是以 Region 为单位做数据的复制，也就是一个 Region 的数据会保存多个副本。Replica 之间是通过 Raft 来保持数据的一致，一个 Region 的多个 Replica 会保存在不同的节点上，构成一个 Raft Group。其中一个 Replica 会作为这个 Group 的 Leader，其他的 Replica 作为 Follower。<strong>所有的读和写都是通过 Leader 进行</strong>，再由 Leader 复制给 Follower。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/4_7d840f500e.png" class="" title="KeyValue">

<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="读写实现（RocksDB）"><a href="#读写实现（RocksDB）" class="headerlink" title="读写实现（RocksDB）"></a>读写实现（RocksDB）</h4><p><a href="https://github.com/facebook/rocksdb">RocksDB</a> 是由 Facebook 基于 LevelDB 开发的一款提供键值存储与读写功能的 <strong>LSM-tree</strong> 架构引擎。用户写入的键值对会先写入磁盘上的 WAL (Write Ahead Log)，然后再写入内存中的跳表（SkipList，这部分结构又被称作 MemTable）。LSM-tree 引擎由于将用户的随机修改（插入）<strong>转化为了对 WAL 文件的顺序写</strong>，同时每次修改都是以页为结构进行整体修改，提升了每次修改的数据量，因此具有很高的写吞吐。</p>
<blockquote>
<p>MemTable往往是一个跳表（Skip List）组织的有序数据结构。对比B+树，当数据量特别大时，由于B+树更新和删除数据时需要沿着B+树逐层进行页分裂和页合并，严重影响数据写入性能。</p>
<p>Immutable：不可修改的MemTable，由MemTable到达一定容量后转化而成。</p>
<p>SSTable：键值存储，有序，内部包含了一系列分割的 Block 块，每个 Block 块的index存储在SSTable的尾部，用于帮助快速查找特定的Block。当一个SSTable被打开的时候，index会被加载到内存，然后根据key在内存index里面进行一个二分查找，查到该key对应的磁盘的offset之后，然后去磁盘把响应的块数据读取出来。</p>
</blockquote>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240526113135902.png" class="" title="image-20240526113135902.png">

<p>写入步骤（删除也会转为写入标记）：</p>
<ol>
<li>当有一个数据写入请求时，RocksDB 通过使用两阶段提交写前日志的方式完成数据写入，此时数据会在 WAL LOG 中被标记写入完成，同时内存中的 Memtable 也会被更新（跳表结构）。</li>
<li>Memtable达到指定大小后会将其切换成 Immutable 并生成一个新的Memtable继续使用，后台线程会把Immutable持久化为SStable。<strong>如果写入流量很大，同时上一个Immutable还未成功持久化，此时就会阻塞写请求</strong>。</li>
<li>内存中的数据达到一定阈值后，会刷到磁盘上生成 SST 文件 (Sorted String Table)，SST 又分为多层（默认至多 6 层），每一层的数据达到一定阈值后会挑选一部分 SST 合并到下一层，每一层的数据是上一层的 10 倍（因此 90% 的数据存储在最后一层）。此步骤也称为Major Compaction，这个阶段会<strong>真正的清除掉被标记删除掉的数据以及多版本数据的合并，避免浪费空间</strong>。</li>
</ol>
<p>读取：为了提高读取性能以及减少对磁盘的读取，RocksDB 将存储在磁盘上的文件都按照一定大小切分成 block（默认是 64KB），读取 block 时先去<strong>内存</strong>中的 BlockCache 中查看该块数据是否存在（内存加速），然后在level 0 SSTable中查找，最后在level N SSTable中查找。如果数据一直到到最底层才被找到，LSM Tree把这种读取和查找了无关SSTable的现象叫做读放大。</p>
<p>合并需要将合并涉及的SSTable读入内存，并把合并后产生的新的SSTable写入磁盘，会增加磁盘IO和CPU的消耗，这种写入磁盘的数据量大于实际数据量现象成为写放大。</p>
<p><strong>读放大可以通过布隆过滤器来快速确定数据不在SSTable中，但是写放大由于内存原因通常无法避免。</strong></p>
<h4 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h4><p>KV 模型通常实现的是一种非关系型数据库，关系型数据库作为当下存储主流，TiDB 基于 KV 模型通过具体的数据、索引映射关系实现了关系型数据库。在关系系数据库中通常要保存三种类型的数据：表的元信息、索引数据、表的行数据。</p>
<p>TiDB 对每个表分配一个 TableID，每一个索引都会分配一个 IndexID，每一行分配一个 RowID（如果表有整数型的 Primary Key，那么会用 Primary Key 的值当做 RowID），其中 TableID 在整个<strong>集群内唯一</strong>，IndexID&#x2F;RowID 在<strong>表内唯一</strong>。其中编码规则必须实现 key 在全局内是唯一的。</p>
<p>表的行数据按照以下规则编码保存到 KV 模型中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Key<span class="punctuation">:</span> tablePrefix<span class="punctuation">&#123;</span>tableID<span class="punctuation">&#125;</span>_recordPrefixSep<span class="punctuation">&#123;</span>rowID<span class="punctuation">&#125;</span></span><br><span class="line">Value<span class="punctuation">:</span> <span class="punctuation">[</span>col1<span class="punctuation">,</span> col2<span class="punctuation">,</span> col3<span class="punctuation">,</span> col4<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>由于索引存在唯一索引和非唯一索引，因此索引存在以下两种编码方式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一索引</span></span><br><span class="line">Key<span class="punctuation">:</span> tablePrefix<span class="punctuation">&#123;</span>tableID<span class="punctuation">&#125;</span>_indexPrefixSep<span class="punctuation">&#123;</span>indexID<span class="punctuation">&#125;</span>_indexedColumnsValue</span><br><span class="line">Value<span class="punctuation">:</span> rowID</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非唯一索引</span></span><br><span class="line">Key<span class="punctuation">:</span> tablePrefix<span class="punctuation">&#123;</span>tableID<span class="punctuation">&#125;</span>_indexPrefixSep<span class="punctuation">&#123;</span>indexID<span class="punctuation">&#125;</span>_indexedColumnsValue_rowID</span><br><span class="line">Value<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>

<p>通过这种编码规则能够对每行数据构造出唯一的 Key，无论是 Row 还是 Index 的 Key 编码方案，一个 Table 内部所有的 Row 都有相同的前缀，一个 Index 的数据也都有相同的前缀。这样具体相同的前缀的数据，在 TiKV 的 Key 空间内，是排列在一起。同时保证编码前和编码后的比较关系不变，那么就可以将 Row 或者 Index 数据有序地保存在 TiKV 中。采用这种编码后，一个表的所有 Row 数据就会按照 RowID 的顺序排列在 TiKV 的 Key 空间中，某一个 Index 的数据也会按照 Index 的 ColumnValue 顺序排列在 Key 空间内。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240525164017741.png" class="" title="image-20240525164017741.png">

<h4 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h4><h5 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h5><p>该协议中有三种角色：提议者（Proposer）、接受者（Acceptor）、学习者（Learner），分布式系统中的每个节点可以身兼数职，也就是说既可以当做提议者发起提议，也可以对提议进行投票。</p>
<ul>
<li>提议者：提议一个值，尝试征求投票表决。</li>
<li>接受者：参与共识协商，对每个提议进行投票表决，并存储提议的值。</li>
<li>学习者：被动接受最终通票通过的决议，不参与投票表决，通常是 master-slave 中的 slave 角色。</li>
</ul>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616112927229.png" class="" title="image-20240616112927229.png">

<p>在 Paxos 协议中每个提议包括一个提议编号 n 和提议值 v，计为 [n, v ] ，发起共识包括两个步骤：</p>
<ol>
<li>准备（Prepare）阶段：该阶段是为了获取到发起正式提议时的提议编号，<strong>接受者只会接受提议编号大的提议</strong>。（编号其实代表了系统中的全局逻辑时间，编号越大代表优先级越高）。准备阶段的意义，是发现接受者节点上，已经通过的提案的值。（不同提议者<strong>不能拥有相同的提议编号</strong>，否者接受者无法区分不同提议）</li>
<li>接受（Accept）阶段：只对编号最大的提议做回应，<strong>如果之前接受过提议则把提议值作为相应结果返回</strong>，否则返回空。</li>
</ol>
<p>准备阶段提议者发出请求并带上自身提议号 ，各节点第一次收到请求时都会返回响应并记下当前提议号，并承诺不会接受比该提议号更小的提议</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616171114544.png" class="" title="image-20240616171114544.png">

<p>另外当接受者2、3收到提议编号为 3 的提议后，对比自身保存的最大提议号并更新，随后返回响应，并承诺不会接受比该提议号更小的提议。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616171749809.png" class="" title="image-20240616171749809.png">

<p>此时三个接受者的最大提议号都是 3，准备阶段结束，进入接受阶段。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616172905869.png" class="" title="image-20240616172905869.png">

<p>这种算法提出较早，存在一些缺陷，比如容易陷入活锁（即多数节点都在处于投票阶段，永远不会产生结果）；每次只能对一个值进行同步，且同步需要两个阶段，节点之间的 rpc 成本高。</p>
<h5 id="Raft-协议（采用）"><a href="#Raft-协议（采用）" class="headerlink" title="Raft 协议（采用）"></a>Raft 协议（采用）</h5><p>Raft 算法对Paxos 进行了简化，是现在分布式系统开发首选的共识算法。Raft 算法把每个节点分为领导者（Leader）、跟随者（Follower）和候选人（Candidate） 3 种状态，任何时候节点只会处于上述状态中的一种，整个集群中只能存在一个 leader，所有数据都要听从 leader 节点指挥。</p>
<ul>
<li>Leader：平常的主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“还在leader 节点还存活”。</li>
<li>Follower：接受和处理来自 Leader 的信息，如果 leader 节点不存活了就站出来推举自己当 leader。</li>
<li>Candidate：候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。</li>
</ul>
<ol>
<li>集群内的节点在初始阶段是没有 leader 的，此时所有节点都处于 follower 身份，Raft 算法实现了随机超时时间的特性。也就是说，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。等待超时时间最小的会因为没有等到领导者的心跳信息，发生超时，此时节点会转化为Candidate身份。</li>
<li>最先转化身份的节点给自己投票后，会携带上任期编号发送请求投票 rpc 给其他节点，其他节点如果在该编号的任期内还没投过票，就会把票投给他，并增加自己的任期编号。</li>
<li>接受超过半数的票后，候选者会成为 leader，此后一直发送心跳信息来维持自己的 leader 身份。</li>
</ol>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616181844322.png" class="" title="image-20240616181844322.png">

<p>Raft 算法中的任期是一个单调递增的数字，任期编号随着随着选举的变化而变化：</p>
<ol>
<li>follower 在等待心跳超时后，推举自己为候选人时，会增加自己的任期号。</li>
<li>任期编号的大小，会影响领导者选举和请求的处理。如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。如果自己任期编号为 1，接收到了任期编号为 3 的投票请求，会更新自己的编号到较大的编号值。</li>
<li>如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求。</li>
</ol>
<p>选举的规则：</p>
<ol>
<li>领导者周期性地向所有跟随者发送心跳消息（即不包含日志项的日志复制 RPC 消息），阻止跟随者发起新的选举。</li>
<li>如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举。</li>
<li>在一次选举中，赢得大多数选票的候选人，将晋升为领导者。</li>
<li>在一个任期内，领导者一直都会是领导者，直到它自身出现问题（比如宕机），或者因为网络延迟，其他节点发起一轮新的选举。</li>
<li>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“<strong>先来先服务</strong>”的原则进行投票。</li>
<li>日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的候选人。</li>
</ol>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240616184135560.png" class="" title="image-20240616184135560.png">

<p>如果多个节点同时心跳超时进而发生选举，就会瓜分选票，导致需要不断重复选举。为了避免这种情况发生，Raft 采用了<strong>随机超时时间</strong>的办法，把超时时间都分散开来，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，这样就能减少因选票瓜分导致选举失败的情况。这些超时时间包括两个方面：</p>
<ol>
<li>leader 的心跳超时时间</li>
<li>候选者等待选举超时的时间间隔</li>
</ol>
<p>在 TiDB 中所有客户端发出的修改请求都通过 Raft 协议以日志项的形式写入到磁盘中，修改的最终数据结果保存在内存中。其中日志项是一种特殊的数据格式，保存的字段有：</p>
<ul>
<li>日志索引：单调递增，表示日志的下标</li>
<li>任期编号：生成当前日志的 leader 节点的任期号码</li>
<li>客户端的指令：用户发出的修改指令</li>
</ul>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/d5c7b0b95b4289c10c9e0817c71f036d.jpg" class="" title="image-d5c7b0b95b4289c10c9e0817c71f036d.jpg">

<p>Raft 协议使用优化的两阶段提交来保存每个日志项，当领导者接收到客户端发送的请求后会先在本地新增一个日志并修改状态为待提交；随后给所有跟随者发送日志复制请求，跟随者本地保存后返回成功，<strong>如果领导者收到多数成功响应后提交本地日志并给客户端返回成功</strong>。</p>
<img src="/2024/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/b863dc8546a78c272c965d6e05afde29.png" class="" title="image-b863dc8546a78c272c965d6e05afde29">

<p>当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没应用，那么跟随者就将这条日志项应用到本地的状态机中（优化的逻辑，减少了一次 rpc 通信），优化的背景是心跳信息和日志复制消息都会带上领导者最新的日志索引。</p>
<p>与此同时 Raft 协议强制以领导者节点的日志为准，当发现领导者和跟随者日志不同时会依次向前寻找，直到找到最先出现不同的索引，然后以领导者日志为准进行覆盖更新。</p>
]]></content>
  </entry>
  <entry>
    <title>算法思想</title>
    <url>/2021/10/13/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h1><img src="/2021/10/13/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6-771dd4ec27c24ec3af073bf57b82c2f1.png" class="" title="算法复杂度.png">

<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">bubbleSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比较交换的时候可以让相同的元素不发生交换，因此冒泡是一个稳定的排序算法。但是每次交换冒泡需要赋值三次，效率不如其他算法。</p>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">selectionSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j]; <span class="comment">// 数据移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序在移动元素的时候只需一次，因此它的效率比冒泡要好，同时也是一种稳定的排序算法。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>希尔排序，也称缩小增量排序，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">shellSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> step; i &lt; length; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - step;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">mergeSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">middle</span> <span class="operator">=</span> Math.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">merge</span><span class="params">(left, right)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序稳不稳定关键要看merge() 函数，在合并的过程中，如果<code>A[p…q]</code>和<code>A[q+1…r]</code>之间有值相同的元素，可以先把<code>A[p…q]</code>中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，<strong>归并排序是一个稳定的排序算法</strong>。</p>
<p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，**不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)<strong>。实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以</strong>空间复杂度是 O(n)**。</p>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> index=help(nums,left,right);</span><br><span class="line">        quicksort(nums,left,index-<span class="number">1</span>);</span><br><span class="line">        quicksort(nums,index+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">help</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> t=nums[right];</span><br><span class="line">        <span class="type">int</span> index=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;t)&#123;</span><br><span class="line">                swap(nums,index,i);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,index,right);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> t=nums[a];</span><br><span class="line">        nums[a]=nums[b];</span><br><span class="line">        nums[b]=t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素在经过第一次分区操作之后，两个元素的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p>
<p>如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n&#x2F;2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。</p>
<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="1-寻找左侧边界的二分搜索"><a href="#1-寻找左侧边界的二分搜索" class="headerlink" title="1. 寻找左侧边界的二分搜索"></a>1. 寻找左侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> :</p>
<ol>
<li><code>left + (right - left) / 2</code>和<code>(left + right) / 2</code>的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。</li>
<li>左右边界，mid，取值。</li>
</ol>
<h3 id="while循环的条件"><a href="#while循环的条件" class="headerlink" title="while循环的条件"></a>while循环的条件</h3><p>初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，这个区间其实就是每次进行搜索的区间。后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</p>
<h3 id="边界判断"><a href="#边界判断" class="headerlink" title="边界判断"></a>边界判断</h3><p>由于 while 的退出条件是 left &#x3D;&#x3D; right + 1，区间的形式就是 [right + 1, right]，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界,因此，最后返回结果的代码应该检查越界情况</p>
<h2 id="2-寻找右侧边界的二分查找"><a href="#2-寻找右侧边界的二分查找" class="headerlink" title="2. 寻找右侧边界的二分查找"></a>2. 寻找右侧边界的二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯算法-DFS"><a href="#回溯算法-DFS" class="headerlink" title="回溯算法(DFS)"></a>回溯算法(DFS)</h1><p>回溯算法其实就是<strong>DFS</strong>算法，本质上就是一种暴力穷举算法。采用试错的思想，尝试分步的去解决问题。在分步解决问题的过程中，它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。代码框架如下所示：</p>
<ol>
<li><p>路径：也就是已经做出的选择。</p>
</li>
<li><p>选择列表：也就是你当前可以做的选择。</p>
</li>
<li><p>结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p>要在递归之前做出选择，<strong>在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p>
<h1 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h1><p>把一些问题抽象成图,本质就是在一幅<strong>图</strong>中找到从起点 start 到终点 target 的<strong>最近距离</strong>，但是空间复杂度高，而 DFS 的空间复杂度较低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cur.adj()</code> 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划问题的一般形式就是求最值，核心问题是穷举。动态规划存在重叠子问题和最优子结构，可以通过dp数组来进行剪枝优化，最后写出状态转移方程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 初始化 base <span class="keyword">case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>++贪心选择性质：每一步都做出一个局部最优的选择，最终的结果就是全局最优。++</p>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>分治算法通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。分治算法也需要满足一些条件，原问题结果应可以通过合并子问题结果来计算。</p>
<ol>
<li>不思考整体，而是把目光聚焦局部</li>
<li>明确递归函数的定义是什么，相信并且利用好函数的定义</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>一文说清线程缓存</title>
    <url>/2025/09/20/%E4%B8%80%E6%96%87%E8%AF%B4%E6%B8%85%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="什么是线程缓存以及为什么要用到线程缓存？"><a href="#什么是线程缓存以及为什么要用到线程缓存？" class="headerlink" title="什么是线程缓存以及为什么要用到线程缓存？"></a>什么是线程缓存以及为什么要用到线程缓存？</h1><p>每个线程都有独立的存储空间，使得相同的变量在不同线程中能够有不同的值，互不影响，每个变量只在当前线程中使用。简单来说就是<strong>多线程环境下解决线程安全问题的工具</strong>。</p>
<p>线程缓存相比于其他缓存，具有以下优点：</p>
<ul>
<li><strong>性能更优</strong>，直接存于线程变量副本中，没有其他 IO 开销，同时避免了锁同步的开销</li>
<li><strong>数据隔离</strong>，多线程中天然不存在竞争，保证每个线程对数据的修改不会影响其他线程中的变量</li>
<li><strong>简化代码</strong>，需要在多个层次的调用中传递数据的场景中，使用线程缓存可以简化参数传递逻辑，避免在方法调用中显式传递参数，从而提高代码的可读性（<strong>双刃剑</strong>）。</li>
</ul>
<p>线程缓存典型的使用场景：</p>
<ul>
<li>数据库连接对象：使用池化技术加线程缓存来使用和管理数据库连接</li>
<li>用户上下文信息：RPC 请求中通过拦截器记录一些公共参数，如用户信息、客户端信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);  </span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();  </span><br><span class="line">threadLocal.set(<span class="string">&quot;threadLocal1&quot;</span>);  </span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&quot;</span> + threadLocal.get());  <span class="comment">// threadLocal1</span></span><br><span class="line">executorService.submit(() -&gt; &#123;  </span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&quot;</span> + threadLocal.get());  <span class="comment">// null</span></span><br><span class="line">    threadLocal.set(<span class="string">&quot;threadLocal2&quot;</span>);  </span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&quot;</span> + threadLocal.get());  <span class="comment">// threadLocal2</span></span><br><span class="line">&#125;);  </span><br><span class="line">Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&quot;</span> + threadLocal.get());	<span class="comment">// threadLocal1</span></span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal-分析"><a href="#ThreadLocal-分析" class="headerlink" title="ThreadLocal 分析"></a>ThreadLocal 分析</h1><h2 id="Thread与ThreadLocal关系"><a href="#Thread与ThreadLocal关系" class="headerlink" title="Thread与ThreadLocal关系"></a>Thread与ThreadLocal关系</h2><p>Thread 类中有threadLocals、inheritableThreadLocals两个变量，负责存储当前线程的缓存对象。<br>变量可以保存多个对象，通过数组对象进行存储，其中对象的 key 为ThreadLocal，value 为 object 对象。</p>
<img src="/2025/09/20/%E4%B8%80%E6%96%87%E8%AF%B4%E6%B8%85%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98/file-20250930153836516.png" class="">
<p>其中inheritableThreadLocals 保存的是可继承的线程变量，基本原理是创建子线程时把父线程的inheritableThreadLocals对象深拷贝到当前线程变量中。</p>
<p>以线程池新建线程为例，跟踪代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Executors.DefaultThreadFactory</span><br><span class="line"></span><br><span class="line">DefaultThreadFactory.newThread</span><br><span class="line"></span><br><span class="line"><span class="title function_">Thread</span><span class="params">(ThreadGroup g, Runnable target, String name,  </span></span><br><span class="line"><span class="params">               <span class="type">long</span> stackSize, AccessControlContext acc,  </span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> inheritThreadLocals)</span> &#123;<span class="comment">// inheritThreadLocals默认为 true</span></span><br><span class="line">               <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)  <span class="comment">// 深拷贝父线程（即当前创建线程）的inheritThreadLocals对象</span></span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =  </span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">               &#125; </span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocalMap-设计"><a href="#ThreadLocalMap-设计" class="headerlink" title="ThreadLocalMap 设计"></a>ThreadLocalMap 设计</h2><p>可以看到ThreadLocalMap并没有实现 Map接口，而是定义了一个Entry数组来保存所有数据，在我看来这种设计有以下几点好处：</p>
<ul>
<li><strong>保持代码的简洁性</strong>，如果实现 map 接口，需要实现接口下的所有方法，其中一些方法在线程缓存场景是用不到的，增加了代码维护成本</li>
<li><strong>性能与存储考虑</strong>，通过数组以及线性探测法，能够减少链表带来的存储与查询成本</li>
<li><strong>定制的垃圾回收策略</strong>，通过 key 的弱引用设计，尽量减少内存泄露的发生。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;  </span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  </span><br><span class="line">        Object value;  </span><br><span class="line">  </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  </span><br><span class="line">            <span class="built_in">super</span>(k);  <span class="comment">// k 为弱引用，当只有弱引用存在时，只要发生 gc 就会被垃圾回收，此时 key 为 null，下次 set 时会进行清理。</span></span><br><span class="line">            value = v;  <span class="comment">// v为强引用，</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
ThreadLocal 为了防止内存泄露，会有一个兜底清除的机制（弱引用的设计 &amp;&amp; 垃圾清理设计）。这种兜底机制的设计使得即使开发者偶尔忘记调用 remove()，系统也能在其持续操作中消除大部分不必要的遗留；不过，开发中仍然应该严格执行移除操作。</li>
</ul>
<blockquote>
<p>Java 中不同引用的介绍</p>
<ul>
<li>强引用：new 对象的方式即强引用，对象只要存在强引用就不会进行垃圾回收</li>
<li>软引用：没有强引用存在时，若内存不足才会进行垃圾回收</li>
<li>弱引用：对象只有弱引用存在时，只要发生 gc 就被回收</li>
<li>虚引用：虚引用不会决定对象的生命周期，必须和 ReferenceQueue 一起使用，当垃圾回收器准备回收一个对象时，会把它的虚引用加入到关联的 ReferenceQueue 中</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">strongRefObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(strongRefObj);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(strongRefObj);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚引用</span></span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();  </span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(strongRefObj, referenceQueue);  </span><br><span class="line">  </span><br><span class="line">strongRefObj = <span class="literal">null</span>;  </span><br><span class="line">System.gc();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Give some time for GC to process  </span></span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">    Thread.currentThread().interrupt();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// After GC  </span></span><br><span class="line">System.out.println(<span class="string">&quot;Soft Reference after GC: &quot;</span> + softReference.get());  <span class="comment">// May still be available  </span></span><br><span class="line">System.out.println(<span class="string">&quot;Weak Reference after GC: &quot;</span> + weakReference.get());  <span class="comment">// Likely null  </span></span><br><span class="line">System.out.println(<span class="string">&quot;Phantom Reference after GC: &quot;</span> + phantomReference.get());  <span class="comment">// Always null</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，强引用是可以和其他引用共存的，ThreadLocal 选用弱引用是为了当发生 gc 的时候<strong>尽量释放那些由于开发者忘记 remove 的内存</strong></p>
<h2 id="关键代码设计"><a href="#关键代码设计" class="headerlink" title="关键代码设计"></a>关键代码设计</h2><h3 id="set-代码"><a href="#set-代码" class="headerlink" title="set 代码"></a>set 代码</h3><ul>
<li>ThreadLocal 发生hash 冲突时采用了线性探测法</li>
<li>set 寻找空槽时若碰到 key 为 null 的槽位，会进行<strong>替换</strong>（减少没有 remove 导致的内存泄露）</li>
<li>set 完成后进行<strong>启发式扫描</strong>（cleanSomeSlots），时间复杂度为 log N，再次减少没有 remove 导致的内存泄露</li>
<li>如果没有扫描到且entry 数组到达阈值，就<strong>扩容并清除</strong>所有无效数据，再次减少没有 remove 导致的内存泄露<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();  </span><br><span class="line">    <span class="comment">// 获取线程存储的 Map 对象，子类重写方法，可能是threadLocals、inheritableThreadLocals</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);  </span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;  </span><br><span class="line">	    <span class="comment">// key 为 threadLocal 自身，key 可以被自动 gc</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        createMap(t, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;  </span><br><span class="line">    Entry[] tab = table;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  <span class="comment">// 通过 key 定位存储的数组</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];  </span><br><span class="line">         e != <span class="literal">null</span>;  </span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;  </span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;  <span class="comment">// 已经存在当前 key，直接覆盖</span></span><br><span class="line">            e.value = value;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;  </span><br><span class="line">            replaceStaleEntry(key, value, i);  <span class="comment">// 替换旧值</span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);  <span class="comment">// 定位到存储下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;  </span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)  <span class="comment">// 启发式清理无效 key</span></span><br><span class="line">        rehash();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="get-代码"><a href="#get-代码" class="headerlink" title="get 代码"></a>get 代码</h3><ul>
<li>每个 Thread 都有两个 ThreadLocalMap 对象，分别是threadLocals、inheritableThreadLocals，分别对应 ThreadLocal 和 InheritableThreadLocal，后者用于实现父子线程传递的 ThreadLocal<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();  </span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);  </span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;  </span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> setInitialValue();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类可重写</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父子线程传递时，为子线程接收的值保留一个扩展点</span></span><br><span class="line">T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ThreadLocal-架构设计思考"><a href="#ThreadLocal-架构设计思考" class="headerlink" title="ThreadLocal 架构设计思考"></a>ThreadLocal 架构设计思考</h2><h3 id="Q：为什么说-ThreadLocal-使用不当会存在内存泄露？"><a href="#Q：为什么说-ThreadLocal-使用不当会存在内存泄露？" class="headerlink" title="Q：为什么说 ThreadLocal 使用不当会存在内存泄露？"></a>Q：为什么说 ThreadLocal 使用不当会存在内存泄露？</h3><p>由于线程是一个比较“重”的资源，通常情况下我们会使用线程池来进行复用，这就导致线程的生命周期＞提交任务的生命周期，如果任务执行完毕但是 ThreadLocal 保存的对象没有被释放，就会导致当前线程一直持有该对象，进而导致内存泄露。<br>反过来说如果没有线程池，任务方法执行完毕，方法栈内存就会释放，也就不会有内存问题了。简单来说就是<strong>线程把方法栈的变量拷贝到了线程对象中，变相扩大了对象的生命周期</strong>。</p>
<h3 id="Q：为什么-ThreadLocal-使用-Map-来保存数据？"><a href="#Q：为什么-ThreadLocal-使用-Map-来保存数据？" class="headerlink" title="Q：为什么 ThreadLocal 使用 Map 来保存数据？"></a>Q：为什么 ThreadLocal 使用 Map 来保存数据？</h3><ol>
<li>一个线程可以创建多个 ThreadLocal 对象，并且同一线程的所有 ThreadLocal 对象都保存在 Thread 的变量中，为了保存这种 1：N 的关系。</li>
<li>为了能够快速定位到当前 ThreadLocal 保存的值，所以使用了 Map 结构，其中 key 为ThreadLocal 对象，value 为 ThreadLocal 对象保存的值。</li>
</ol>
<h3 id="Q：为什么-ThreadLocal-不复用-JDK-的-Map-接口，而是使用-entry-数组？"><a href="#Q：为什么-ThreadLocal-不复用-JDK-的-Map-接口，而是使用-entry-数组？" class="headerlink" title="Q：为什么 ThreadLocal 不复用 JDK 的 Map 接口，而是使用 entry 数组？"></a>Q：为什么 ThreadLocal 不复用 JDK 的 Map 接口，而是使用 entry 数组？</h3><ol>
<li>ThreadLocal 无需使用 Map 接口中的所有方法，如果重新实现 Map 接口，会导致多个实现方法用不到。</li>
<li>已有的实现如 HashMap，在处理 hash 冲突时使用了拉链法，链表会造成内存空间的浪费，于此同时 ThreadLocal 需要更详细的内存泄露清理控制（如 key 的弱引用设计），因此也不适用于已有 Map 类</li>
</ol>
<h3 id="Q：为什么-ThreadLocal-中-entry-数组的-key-使用弱引用？"><a href="#Q：为什么-ThreadLocal-中-entry-数组的-key-使用弱引用？" class="headerlink" title="Q：为什么 ThreadLocal 中 entry 数组的 key 使用弱引用？"></a>Q：为什么 ThreadLocal 中 entry 数组的 key 使用弱引用？</h3><p>这个系统设计是为了避免长期的内存泄露问题，当开发者忘记remove 时，系统能够在该对象不可达后进行一个<strong>兜底的延迟清除</strong>，<strong>这并不意味着开发者可以不使用 remove 方法进行清理</strong>。</p>
<h3 id="Q：为什么-ThreadLocal-中-entry-数组的-value-不适合弱引用？"><a href="#Q：为什么-ThreadLocal-中-entry-数组的-value-不适合弱引用？" class="headerlink" title="Q：为什么 ThreadLocal 中 entry 数组的 value 不适合弱引用？"></a>Q：为什么 ThreadLocal 中 entry 数组的 value 不适合弱引用？</h3><p>弱引用是可以和强引用并存的，当只剩下弱引用时下次垃圾回收就会回收该对象。这时随着线程方法的执行，ThreadLocal值可能会随时变成空值，影响线程稳定。</p>
<h1 id="Scope是什么？"><a href="#Scope是什么？" class="headerlink" title="Scope是什么？"></a>Scope是什么？</h1><p><a href="https://github.com/PhantomThief/scope">GitHub 源码地址</a><br>Scope 对 ThreadLocal 进行了封装，有以下几点好处：</p>
<ul>
<li>框架方法内置了清理能力，能够防止内存泄露</li>
<li>提供了跨线程传递 Scope 的能力</li>
</ul>
<h2 id="Scope、ScopeKey、ThreadLocal的关系"><a href="#Scope、ScopeKey、ThreadLocal的关系" class="headerlink" title="Scope、ScopeKey、ThreadLocal的关系"></a>Scope、ScopeKey、ThreadLocal的关系</h2><img src="/2025/09/20/%E4%B8%80%E6%96%87%E8%AF%B4%E6%B8%85%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98/file-20251207104117574.png" class="">

<p>其中 Scope 作为容器，内部有一个线程安全的 HashMap，来保存当前线程下所有的ScopeKey数据，随后把当前的 <strong>Scope 对象放在 ThreadLocal 中</strong>供其他地方使用。<br>ScopeKey 作为缓存的 key，内部提供了 get、set 方法来对其 value 进行操作，其底层是调用的ConcurrentMap。操作数据时首先通过ThreadLocal 来<strong>获取整个 Scope 容器，然后根据 ScopeKey 获取具体数据</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scope.beginScope();  <span class="comment">// 初始化 Scope 容器</span></span><br><span class="line">ScopeKey&lt;String&gt; scopeKey1 = ScopeKey.allocate();  </span><br><span class="line">scopeKey1.set(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">ScopeKey&lt;String&gt; scopeKey2 = ScopeKey.allocate();  </span><br><span class="line">scopeKey1.set(<span class="string">&quot;2&quot;</span>);  </span><br><span class="line">System.out.println(scopeKey2.get());</span><br><span class="line">Scope.endScope();  <span class="comment">// 销毁 Scope 容器</span></span><br><span class="line"></span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">threadLocal1.set(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal2 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">threadLocal2.set(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">System.out.println(threadLocal1.get());</span><br><span class="line">threadLocal1.remove();	<span class="comment">// 释放ThreadLocal</span></span><br></pre></td></tr></table></figure>
<p>相同线程初始化两个线程缓存后，其底层存储如下所示：</p>
<ul>
<li>不同的ThreadLocal底层<strong>存储在不同的 entry 数组</strong>中</li>
<li>不同的 ScopeKey 保存在相同的 Scope 容器内，一个线程只会有一个 Scope 容器，该 Scope 容器保存在 ThreadLocal 中，也就是说<strong>所有的 ScopeKey 保存在同一个entry 数组中</strong></li>
</ul>
<p>看到这里可以发现：如果线程中申请多个ScopeKey，会存在性能瓶颈（二次 Hash 的情况）</p>
<img src="/2025/09/20/%E4%B8%80%E6%96%87%E8%AF%B4%E6%B8%85%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98/file-20251207111536780.png" class="">

<h2 id="Scope如何实现自动清理与跨线程传递？"><a href="#Scope如何实现自动清理与跨线程传递？" class="headerlink" title="Scope如何实现自动清理与跨线程传递？"></a>Scope如何实现自动清理与跨线程传递？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动清理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">supplyWithNewScope</span><span class="params">(<span class="meta">@Nonnull</span> ThrowableSupplier&lt;T, X&gt; supplier)</span> <span class="keyword">throws</span> X &#123;  </span><br><span class="line">    beginScope();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> supplier.get();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        endScope();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨线程传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">supplyWithExistScope</span><span class="params">(<span class="meta">@Nullable</span> Scope scope,  </span></span><br><span class="line"><span class="params">        ThrowableSupplier&lt;T, X&gt; supplier)</span> <span class="keyword">throws</span> X &#123;  </span><br><span class="line">    <span class="type">Scope</span> <span class="variable">oldScope</span> <span class="operator">=</span> SCOPE_THREAD_LOCAL.get();  </span><br><span class="line">    SCOPE_THREAD_LOCAL.set(scope);  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> supplier.get();  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (oldScope != <span class="literal">null</span>) &#123;  </span><br><span class="line">            SCOPE_THREAD_LOCAL.set(oldScope);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            SCOPE_THREAD_LOCAL.remove();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Scope 工具的标准使用中，框架在 Supplier 执行前后保证了beginScope()、endScope()的执行，其底层就是初始化 ThreadLocal 和释放 ThreadLocal。<br>至于跨线程传递则是把<strong>当前线程使用的 Scope 容器替换为其他线程保存的 Scope 容器</strong>，使用完毕后再替换回来。</p>
<h2 id="Scope工具设计思考"><a href="#Scope工具设计思考" class="headerlink" title="Scope工具设计思考"></a>Scope工具设计思考</h2><h3 id="Q：Scope-一定能避免内存泄露吗？"><a href="#Q：Scope-一定能避免内存泄露吗？" class="headerlink" title="Q：Scope 一定能避免内存泄露吗？"></a>Q：Scope 一定能避免内存泄露吗？</h3><p>使用提供的工具类时能够避免，其他情况仍然需要调用endScope()方法来清除 ThreadLocal</p>
<h3 id="Q：Scope如何提供跨线程的能力？"><a href="#Q：Scope如何提供跨线程的能力？" class="headerlink" title="Q：Scope如何提供跨线程的能力？"></a>Q：Scope如何提供跨线程的能力？</h3><p>在切换线程时，对线程引用的 <strong>Scope 容器进行引用传递</strong>，来达到跨线程的目的。因此 Scope <strong>不是线程安全</strong>的，多个线程进行操作的是同一个 Scope容器。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类只允许创建一个对 象(或者实例)，那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h2 id="如何实现一个单例"><a href="#如何实现一个单例" class="headerlink" title="如何实现一个单例"></a>如何实现一个单例</h2><ol>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例; </li>
<li>考虑对象创建时的线程安全问题;</li>
<li>考虑是否支持延迟加载;</li>
<li>考虑 getInstance() 性能是否高(是否加锁)</li>
</ol>
<ul>
<li>饿汉式<br>在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是<strong>线程安全</strong>的。不过，这样的实现方式不支持延迟加载(在真正用到 IdGenerator 的时候，再创建实例)。</li>
<li>懒汉式<br>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</li>
<li>双重检测<br>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建 之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</li>
<li>静态内部类<br>利用 Java 的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实 现起来也比双重检测简单。</li>
<li>枚举<br>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特 性，保证了实例创建的线程安全性和实例的唯一性。</li>
</ul>
<p><strong>集群环境下的单例：</strong><br>把这个单例对象序列化并存储到外部共享存储区(比如文件)。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式分为三种更加细分的类型:<strong>简单工厂、工厂方法</strong>和抽象工厂。</p>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>面试分享</title>
    <url>/2021/12/20/%E9%9D%A2%E8%AF%95%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h2><p><strong>http的缺点：</strong></p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<p>用 SSL建立<strong>安全通信线路</strong>之后，就可以在这条线路上进行HTTP通信了。<br><strong>HTTP+ 加密 + 认证 + 完整性保护&#x3D;HTTPS</strong>，简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。</p>
<p><strong>加密方式：</strong></p>
<ul>
<li>加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做<strong>对称加密</strong>。</li>
<li>公开密钥加密使用一对<strong>非对称</strong>的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</li>
</ul>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</p>
<p>公开密钥加密方式还是存在一些问题的，那就是无法证明公开密钥本身就是货真价实的公开密钥。为了解决上述问题，可以使用由数字证书认证机构和其相关机关颁发的公开密钥证书。</p>
<img src="/2021/12/20/%E9%9D%A2%E8%AF%95%E5%88%86%E4%BA%AB/https%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-a4d70d3bf2534a4cb742d08f83206e39.png" class="" title="https非对称加密.png">
<p>首先服务器把经过认证机构的公开密钥发送给客户端，客户端对接收到的密钥进行验证，接着使用该密钥把对称加密的密钥加密后发送给服务器，接下来的通信过程都使用对称加密进行。</p>
<h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><blockquote>
<p>转载 <a href="https://www.cnblogs.com/ityouknow/p/10856177.html">cookie和session</a></p>
</blockquote>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h2 id="http状态码含义"><a href="#http状态码含义" class="headerlink" title="http状态码含义"></a>http状态码含义</h2><blockquote>
<p><a href="https://www.jianshu.com/p/b58025e61b2d">状态码</a></p>
</blockquote>
<h2 id="数据库死锁"><a href="#数据库死锁" class="headerlink" title="数据库死锁"></a>数据库死锁</h2><blockquote>
<p><a href="https://blog.csdn.net/qq_16681169/article/details/74784193">数据库死锁解决</a><br><a href="https://www.cnblogs.com/wezheng/p/8366029.html">https://www.cnblogs.com/wezheng/p/8366029.html</a></p>
</blockquote>
<h2 id="spring的aop是什么？如何实现的"><a href="#spring的aop是什么？如何实现的" class="headerlink" title="spring的aop是什么？如何实现的"></a>spring的aop是什么？如何实现的</h2><blockquote>
<p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary/#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-aop-%E7%9A%84%E4%BA%86%E8%A7%A3">aop</a></p>
</blockquote>
<h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><blockquote>
<p><a href="https://www.cnblogs.com/songgj/p/11297016.html">设计原则</a></p>
</blockquote>
<h2 id="实例变量可以是GC-root-吗"><a href="#实例变量可以是GC-root-吗" class="headerlink" title="实例变量可以是GC root 吗"></a>实例变量可以是GC root 吗</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/129607250">什么是被 GC Roots 直接引用的对象</a><br><a href="https://blog.csdn.net/weixin_38007185/article/details/108093716">GC Roots 是什么</a></p>
</blockquote>
<h2 id="Mybatis-和-的区别"><a href="#Mybatis-和-的区别" class="headerlink" title="Mybatis # 和 $ 的区别"></a>Mybatis # 和 $ 的区别</h2><blockquote>
<p><a href="https://juejin.cn/post/6844904017269620744">Mybatis中#{}与${}的区别</a></p>
</blockquote>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>1.MySQL事物有哪些特性?</p>
<p>2.简述一下MySQL事务两阶段提交的过程及故障恢复的过程？</p>
<p>3.MySQL事物隔离级别有哪几种？分别有哪些特性</p>
<p>4.描述一下MVCC的原理</p>
<p>5.InnoDB引擎有哪些特性及原理是什么</p>
<p>6.描述一下InnoDB Buffer  pool的工作机制以及有哪些逻辑链表，其中LRU链表的算法的原理是什么</p>
<p>7.描述一下Index Condition Pushdown(ICP)、Multi-Range Read (MRR)的原理及适用的场景</p>
<p>8.描述一下B树及B+树各自的优缺点？</p>
<p>9.什么情况下MySQL的索引”失效”不可用？</p>
<p>10.举几个你遇到的MySQL中的隐式转换案例</p>
<p>11.描述一下一条update sql语句在MySQL内部执行的过程？</p>
<p>12.MySQL执行sql时一个表只能用到一个索引吗？</p>
<p>13.描述一下MySQL多表关联中Join的算法的原理</p>
<p>14.MySQL常用的SQL调优手段或工具有哪些？</p>
<p>15.MySQL的启动方式有哪些？ 这几种启动方式间有什么关系</p>
<p>16.MySQL为什么需要设置双1才能保证主从数据的一致性？</p>
<p>17.描述一下主从复制模式after_sync与after_commit的原理及优缺点</p>
<p>18.描述一下主从复制的原理及SQL_thread对索引的利用</p>
<p>19.如果线上从库延迟时间太久，如何快速恢复延迟</p>
<p>20.show slave status状态中second behind计算方式</p>
<p>21.主从复制线程均正常（为Yes，也没报错），Master的binlog已到binlog.00080，但slave上看到Master_Log_File却只到binlog.00070，可能的原因有哪些?</p>
<p>22.在主从服务器上，同一个表的表空间文件大小相差特别大，可能原因是什么，怎么解决？</p>
<p>23.描述一下MySQL并行复制的原理及5.6、5.7版本并行复制的区别</p>
<p>24.MySQL GTID工作原理及不支持的操作</p>
<p>25.MHA、MGR、PXC各自的优缺点及使用场景，简述一下MGR的数据同步原理</p>
<p>26.创建表的各种规范</p>
<p>27.MySQL 数据库CPU使用率突然升到100%该如何处理</p>
<p>28.MySQL有哪些行锁，是如何解决幻读的？</p>
<p>29.explain出来的各种item的意义</p>
<p>30.用xtrabackup做mysql物理备份，建议授予哪些权限？</p>
<p>31.监控MySQL的性能，应该主要观察那几个监控项？</p>
<p>32 MySQL 8.0有哪些新特性？</p>
<p>33.项目选型中确定要使用MySQL，你做为MySQL DBA需要准备什么?</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
</search>
